학자적 기저와 LCPC원리 서술 이전에 학자적 기저를 서술하겠다.

# [학자적 기저](https://faraway6834.github.io/unbeauty/privateNote/Alkali/학자적_기저)
```
# 왜 알려 하는가?

## 합리화 : 「학자적 기저」가 유발하는 자신의 존재 합리화 시나리오

첫번째 합리화 : 좀비 아포칼립스
좀비 아포칼립스 : 무지의 지 (the knowledge of ignorance) -> 무지 좀비 (무지에 대해 비관하여 멍청히 죽는 좀비라는 은유) 감염 위기 -> 실용적 죽음에 대한 극복 의지 (wir müssen wissen, wir werden wissen 정신) -> 「학자적 기저」형성

두번째 합리화 : (나중에 적겠음

## 합리화를 깨고 : 학자적 기저란?

「학자적 기저」란, 알고자 하는 욕구로, 우울증 처럼, 자기 자신이 필요한 이유를 끊임없이 재생산하며, 이성적일 경우, 나쁘지 않은 meme이다.

Q. 학자는 왜 「학자적 기저」를 가지는가? (= 왜 알고자 하는가?)

## 학자적 강박, 강박의 굴래

학자적 기저가 "탓함"을 일으킨다면 병이다., 선민사상이나, 무조건적인 폭력적 계몽주의, 앎에 대한 강박으로 이어지는 경우가 그렇다. (학자벅 강박)

막스 베버는 철창 감옥을 경계했다. 내 생각엔, 학자적 기저가 그 자신에 대해서 합리화를 하다 보면, 학문 탐구 근본주의에 얽메어, 건전하고 건강한 인생에서 멀어져서, 파멸로 갈수 있다고 본다. (강박에 굴래)
```

이제 LCPC 원리를 서술하겠다.

---
---

# 어떻게 "과학(형식탐구) 할" 것인가? LCPC

## 형식탐구에 대한 생각 로드맵

주의 : synurl은 de facto standard (사실상 표준인 현재의 웹을 말함) url이 아닌, 표준 uri입니다
### [synurl](https://faraway6834.github.io/unbeauty/privateNote/MAD/synurl)
````
헌정하는 말 : 「읽어보기 전에」부분을 표기법을 싫어하는 "꼰"님께 헌정합니다. 걍 존나 귀찮아서 내가 상수 몇개 정의하고 형식언어로 돌리겠다는데 뭐가문제야오3ㅕ188ㅋ82ㅕ2ㅓ랴9쟈2ㅑ너ㅑ뱢9

읽어보기 전에 : 이 체계는 단순히 종이를 존나쓰는 어느 망상쟁이 고등학생이, 평소에 비표준 정의를 기술하는 방식으로써, 람다의 치환기호나, 구문론적 정의 기호의 악용 등을, url에 옮길 개미친 또라이같은 생각으로 시작된 내용으로, synurlc함수 하나로 설명되는 체계이며, 자체로는 의미를 가지지 않으며 (synurlc의 속뜻, 의도한 바는 해설서에만) 정의서에서는 정말로 재앙같이 명확히 우리가 수학으로 분류할수 있게 설계하였다.

# SYNURL : Syntax on url, synurlc로 처리되는 그 정의역 형식언어 (보통 synurlc함수 안에 문자열로 작성한다)

SYNURL은 URL형식의 구문을 튜링기계를 통해 컴파일하여 구성하는, 전처리기 오토마타 형식전처리부호 겸 형식언어용 플러그인이다.

언어 L에 대해서, 컴파일러인 acessor(걍 synurlc(L)라고도 하는 함수다, 정확히는 그 명칭을 써야한나)를 통해서,

acessor : SYNURL-L -> L인 함수 acessor가 컴파일러인것이다.



그때, 언어 SYNURL-L가 존재한다.



SYNURL-L의 뜻은 L로 전처리되어 생성된 값의 의미이다.



그러니까 의미론적인 부분은 synurlc함수에 넣은값이라는거다.



## synurlc

람다 함수로 포장된 함수인 synurlc함수는

```plain/text
synurlc L """
멀티 라인 문자열
"""
```

식의 방식으로 표현할수 있으며,

이를 통해 synurlc L의 의미를 확정한다.

따라서, synurlc함수가 정의된다는것은, synurlc L의 의미를 표준적으로 작성 • 해석할수 있다는 뜻이다.

## project SYNURL

▪︎make online first

▪︎then type it reak physical typer

▪︎copy to save


PROFIT!

## synurl 규격 : 책 상품

1권 제목 : synurl-book「총동봉상품」

1책 MIT라이선스 / 타이틀 : corefile.pdf
 - corefile.pdf 에 적힌 글 (문자 행렬)
 - snap설치되며, apt설치되고, curl • wget등지 지원, docker지원, pip지원, pypy지원

2책 GPL라이선스 / 타이틀 : mathessolinux
 - 자체 최소화 acessor 런타임용 아름다운 C코드 OS인 mathessolinux

3책 MIT라이선스 / 타이틀 : about.tex

## SW on github by arcaived by yipl(yaml-included pytoml lang) docr txt : corefile.pdf ; installer (also selenium (명목목적, turing machine s.t. chrome) + urllib + cython + pypy + C code 2 acess it; acessor; pillow를 이용한 pdf파일의 3d printing용 플라스틱 인쇄판 DIY인쇄물 페키지, clay edition및 babilonian edition제작용 RPI 로봇 제어시스템)

### interpretes

 - short:link@synurl.kro.kr/interpretes
    -> redirect
 - synurl.kro.kr/interpretes#url
    -> utf-8 base 64 Encoding to make mathmatical string to view mathML

### pages

#### field
 - info field (state DOM with cached)
 - view field

#### `#blob.ext`

 - synurl file recoginize `~:syntax@~`
 - synurl file recoginize `~:lambda@~`
 - synurl file recoginize `txt` : default
 - synurl file recoginize `markdown` : Special Engine
 - synurl file recoginize `html` : blob view only
 - synurl file recoginize `tex`
 - synurl file recoginize `svg.` : as all
 - synurl file recoginize `bin.` ^
 - synurl file recoginize `pdf.` : as all, but blob only

##### synurl file recoginize
synurl file
 - `synurl.kro.kr#file.synu`
   - no redirect recoginise it also syu
 - `synurl.kro.kr#file.syu`
   - try 2 parse 2 json by regex
   - faild 2 txt
parsed file
 - `synurl.kro.kr#file.toml`
    - jsonize
 - `synurl.kro.kr#file.json`
    - parse-tree s.t. can use
 - `synurl.kro.kr#file.yaml`
    - str-jsonize

##### synurl viewer
`synurl.kro.kr#file.txt`
 - div embed
webpage : embed
 - `username[:path]@synurl.kro.kr#file.md`
    - only github page
 - `synurl.kro.kr#file.html`
 - `synurl.kro.kr#file.htm`
 - `synurl.kro.kr#file`
`synurl.kro.kr#file.tex`
 - rander
`synurl.kro.kr#file.pdf`
 - but how to...?, ummn right! Be make it just make it to possible s.t. blob-view
image : tag
 - `synurl.kro.kr#file.bpm`
 - `synurl.kro.kr#file.gif`
 - `synurl.kro.kr#file.png`
 - `synurl.kro.kr#file.webp`
 - `synurl.kro.kr#file.svg`
`url:token@synurl.kro.kr`
 - fetch2get file url

## anciant-synurl
### hyper-anciant-synurl
 - plastic edition
 - clay edition
 - babilonian edition
 - wood-cupper edition [wanring, only in afocallips] (joke)
 - mattel edition (just type letter info at book's last)

### anciant-synurl
file type
 - original types
 - backup copys
 - file pressed
booktyp
 - diy spring book pressed
 - diy ring book pressed
````

synurl은 다소 옛날에 만들었다, synurl문서에 서술된 일부 스노비즘스러운 발언들은 읽기 마라. 나쁜말이다.

주의 : Alkalic의 공리계중 일부 공리는 도입 안해도 좋습니다, 강제법처럼 수학의 본질에 공리를 선택할 기능이 있습니다. 에초에 수학은 정해지지 않았거든요. 수학에서 공리를 제한하려면, 코헨의 강제법도 좆무시하시는게 맞습니다.
### [Alkali](https://faraway6834.github.io/unbeauty/privateNote/Alkali/alkali)
````
# Alalic Preview

이걸 아주 아주 잘 발전시킬거임, 깃헙 커밋으로 ㄱㄱ

거의 됬네 기분좋다.

## DEFINIRION : Alkalic : Alkalic Linear-algebra + Königsberg Axiom + Lambda Incoding Calculate (구문론적 문제로 lambda형식만 유지하고, 폐지, 람다 지분은 없음)

### Alkalic Algbra

∀x (각각 유일)∃!n(x) s.t. n = ObjectID(x) ∈ Scala

 - AlkalicVectorSpace = Scalaᵗ [t := |Scala|]
 - AlkalicMetrixSpace = AlkalicVectorSpaceᵗ [t := |Scala|]
 - SetTheorem ∈ AlkalicMetrixSpace
 - Notation Definition m ∈ n ≡ SetTheoremₒᵢ₍ₘ₎ₒᵢ₍ₙ₎ [oi := ObjectID]

Alkalraum은 여기서, Scala가 객체의 집합으로 확장되어서, |Scala| = κ가 된다.

### Lambda Including Calculate (구문론적 문제로 lambda형식만 유지하고, 폐지, 람다 지분은 없음)

Alkalic Algbra서 AlkalicVectorSpace나 oidfield = Σᵢ ObjectID eᵢ에 대해, 입력받는 Tensor입력으로 ~~람다~~, 대수함수, Alkalic Algbra서 다가함수를 포함한 함수 구현.

---

폐지되었기 때문에

람다를 아예 삭제해서, 람다가 아닌 걍 연산 과정인 Subrootine으로 바꿨다.

Alkalic Algbra서 AlkalicVectorSpace나 oidfield = Σᵢ ObjectID eᵢ에 대해, 입력받는 Tensor입력으로 대수함수, Alkalic Algbra서 다가함수를 포함한 함수 구현.

하는 체계로 바뀜.

연산 괴정이다.

모든 미지수는 이 람다 체계에서 함수 내부변항으로 고정되어서, 두 함수의 합성에서 초기화되어 창출되거나, 아니면 인자로 된다. 따라서, 어떤 수학 이론은 인자를 가지며, 모델이나 진리값배정은 그 값을 넣는다. (어떻게든 대입됨)

변항은 이론에 인자로 설명 가능

### Königsberg Axiom, VectorAxiom, InaccessibleCardinalExistanceAxiom

⊢ KönigsbergAxiom(x, y, Φ) := (x = y → (Φ ↔ (Φ [x := y])))

이때 [x := y]는 단순히 의미론적 대입 연산자.

⊢ VectorAxiom : "모든 벡터 공간은 기저를 가진다"

다음 글을 읽어 보라.
```
먼저 중위표기결합자 * 에 대해, 다음과 같은 표기법을 도입한다, (*x)(y) ≡ y * x
f(x) ≡ (∈x)라고 공역이 치역으로 정의된 f와 g(x) ≡ (=x)라고 공역이 치역으로 정의된 g를 정의하겠다, 이떄, f와 g의 전사함수임이 당연하며, `≡`는 구문론적 등호다, 참고로 정의역은 집합임으로, 해당 집합이 존재해야 들어갈 수 있다, 또한 f와 g는 표기법이기 때문에, 실제 대수적 객체가 아니며, x ∈ f⁻¹(Φ)가 Φ(x)임은 당연하다, 참고로 공역을 치역으로 정의했다는 뜻은, 저 표기법이 표기하는 수학적 객체의 집합은 저 표기법이 표기하는 수학적 객체의 집합이지, 표기법에서 따로 정의하지 않기에, 최소한의 응용이 아닌 공역이 치역이 되지 않는 큰 응용을 하는것을 형식 언어 형식 문법 수준에서 금지한다고 하는것이다. (당연하다고 말한 내용들은 정의가 아니다, 태클을 걸수 있다.), 마지막으로 h̅는 h의 진리값배정이다. 진리값배정을 뜻하는 표기법이다.
외연 공리(Axiom of Extensionality)와 같은뜻인 명제를 보자, `(∀A∀B)(((x∈A) = (x∈B)) → (A = B))` ≡ `(∀A∀B)((f(A) = f(B)) → (A = B))`이기에, 외연공리는 f가 (전)단사함수임과 동치로, 외연 공리에 따라, 외연공리꼴의 다른 표현인 `f가 (전)단사함수이다`는건 외연 공리가 참일떄 참이다.
외연 공리가 의미하는 바는, 외연 공리가 만족되는 조건은, f가 일대일대응으로 동작하도록 정의된것과 같다,
따라서, 지금부터 f는 외연공리를 만족하는 f인 F로 재정의된다, F⁻¹도 외연 공리를 만족하는 f⁻¹과 같음이, f에 대한 F의 정의상 당연하다

짝 공리(Axiom of Pairing)와 같은뜻인 명제를 보자, ∃{A, B} = ∃{x | (x=A)∨(x=B)}인데 (x=A)∨(x=B) ≡ g(A)(x)∨g(B)(x) = (g(A)∨g(B))(x)로, ∃{A, B} = ∃{x | (x=A)∨(x=B)} = ∃{x | (g(A)∨g(B))(x)}이고, ∃{A, B} f({A, B})(x) = f({x | (g(A)∨g(B))(x)})(x) = (g(A)∨g(B))(x)으로, ∃{A, B}  f({A, B}) = g(A)∨g(B)이기에, {A, B} = f⁻¹(g(A)∨g(B))에서, ∃f⁻¹(g(A)∨g(B))가 짝 공리와 동치로, 짝 공리에 따라, 짝 공리의 다른 표현 `∃f⁻¹(g(A)∨g(B))`은 짝  보장될때, 항진이다.
합집합 공리(Axiom of Union)와 같은뜻인 명제를 보자, ∃{x | (x∈A)∨(x∈B)} ≡ ∃{x | f(A)(x)∨f(B)(x)} = ∃{x | (f(A)∨f(B))(x)}에서, ∃{x | (x∈A)∨(x∈B)} f({x | (x∈A)∨(x∈B)})(x) = f({x | (f(A)∨f(B))(x)}) = (f(A)∨f(B))(x)이므로, ∃{x | (x∈A)∨(x∈B)} f({x | (x∈A)∨(x∈B)}) = (f(A)∨f(B))서, ∃f⁻¹(f(A)∨f(B))임이 합집합 공리와 같은 뜻이고, 합집합 공리에 따라, 합집합 공리의 다른 표현 `∃f⁻¹(f(A)∨f(B))`은 합집합 공리가 보장될때, 항진이다.
이때, 합집합 공리과 짝 공리가 다 참이라는 "합집합 공리와 짝 공리가 보장됨 공리"라는 공리를 세우겠다, 이 공리는 합집합 공리는 합집합 공리의 논리식 표현 p와 짝 공리의 논리식 표현 q에 대해 p와 q가 항진이라는 뜻으로 정의된다. 합집합 공리와 짝 공리가 보장됨 공리와 같은 명제를 보자, "합집합 공리와 짝 공리가 보장됨 공리" = "`∃f⁻¹(g(A)∨g(B))`와, `∃f⁻¹(f(A)∨f(B))`임이 보장됨 공리" = "`∃f⁻¹(g(A)∨g(B)), ∃f⁻¹(f(A)∨f(B))`"으로, , 이는, h̅ = (f, g) ⊨ (∃f⁻¹(h(A)∧h(B)))과 같으므로, 우리가 가정한 "합집합 공리와 짝 공리가 보장됨 공리"에 대해 "합집합 공리와 짝 공리가 보장됨 공리"에 따라, "합집합 공리와 짝 공리가 보장됨 공리"의 다른 표현인 `h̅ = (f, g) ⊨ (∃f⁻¹(h(A)∨h(B)))`는 "합집합 공리와 짝 공리가 보장됨 공리"가 참일때 참이다.
멱집합 공리(Axiom of Power Set)는 멱집합의 존재성을 보장한다.

사실 이는 f가 아닌 F에서도 동일하기에, "합집합 공리와 짝 공리가 보장됨 공리"는 외연공리가 성립하는 F에 대해서 다룰수 있다면, "`h̅ = (F, g) ⊨ (∃F⁻¹(h(A)∨h(B)))`"이다.

치환 공리꼴(Axiom Schema of Replacement)의 다른 표현을 보자, 치환 공리꼴이란 무엇일까? 한마디로 치환 공리꼴은 함수 h에 대해, {h(x) | x ∈ A}의 존재성은 A가 존재해야 보장돼야한다는것이다. 한마디로, ∃A ⇒ ∃{h(x) | x ∈ A}이다. 이때, f({h(x) | x ∈ A})(x) = (∃v ∈ A)((h(v) =)(x)) = ((∃v ∈ A)(h(v) =))(x) 이므로, {h(x) | x ∈ A} = f⁻¹(((∃v ∈ A)(h(v) =)))에서, ∃A ⇒ ∃f⁻¹(((∃v ∈ A)(h(v) =)))임이 치환 공리꼴과 동치이다, 따라서, 치환 공리꼴에 따라 치환 공리꼴의 다른 표현 `∃A ⇒ ∃f⁻¹(((∃v ∈ A)(h(v) =)))`은 치환 공리꼴이 보장될때 항진이다.

치환 공리꼴도 f가 아닌 F에서도 동일하기에, 외연공리가 성립하는 F에 대해서 다룰수 있다면 "∃A ⇒ ∃F⁻¹(((∃v ∈ A)(h(v) =)))"이다.

분류 공리꼴(Axiom Schema of Separation/Specification)은 성질 Φ를 만족하는 부분집합이 존재한다는거다, 성질 Φ를 만족하는 부분집합이 존재한다는뜻은 ∀S ∃{x |(Φ(x)) ∧ (x∈S)}이며, ∀S ∃{x |(Φ(x)) ∧ (x∈S)} ≡ ∀S ∃{x |(Φ(x)) ∧ f(S)(x)}이고, ∀S ∃{x |(Φ(x)) ∧ f(S)(x)}라는건 ∀S ∃f(P) = Φ∧f(S)임과 동치이기에, 분류공리꼴에 따라 분류공리꼴의 다른 표현 `f(P) = Φ∧f(S)`은 분류 공리꼴이 보장될때 항진이다, 이후에 분류 공리꼴을 이용하여 집합론에 대해 논하겠다.

ZF안에 ZF를 만든다고 가정하면, 범주론적으로(함자에 대한 서술로) 접근할때, "∃A ⇒ ∃F⁻¹(((∃v ∈ A)(h(v) =)))"안에서 "h̅ = (f, g) ⊨ (∃f⁻¹(h(A)∨h(B)))", "∃A ⇒ ∃F⁻¹(((∃v ∈ A)(h(v) =)))"가 성립한다, 그러나 이것은 ZF내의 ZF에서만 성립한다. `"메타언어가 서술하는 "내부언어에 관한" 구문"`꼴이기 때문이다.

따라서,
ℙ1 : "∃A ⇒ ∃F⁻¹(((∃v ∈ A)(h(v) =)))"
ℙ2 : "h̅ = (f, g) ⊨ (∃f⁻¹(h(A)∨h(B)))"
를 따로 정의하겠다.

공집합 공리(Axiom of Empty Set)와 같은뜻인 명제를 보자, `(∃S ∀x)(￢(x∈S))` ≡ `(∃S ∀x)(￢f(S)(x))` 이고 `(∃S ∀x)(￢f(S)(x))`와 같은뜻인 명제 `(∃S ∀x)(f(S)(x) = F)`는 `x⊥y = x⊥ = ⊥y = ⊥ = F`인 `⊥`정의에따라서, `(∃S)(f(S) = ⊥)`임과 동치이다, 즉, `∃f⁻¹(⊥)`은 공집합공리와 동치이기에, 공집합 공리에 따라, 공집합 공리의 다른 표현 `∃f⁻¹(⊥)`은 공집합 공리가 보장될때, 항진이다.
무한 공리 (Axiom of Infinity)는 자연수 집합의 존재성을 보장하는 공리이다. "모든 자연수 x에 대해, (∃ℕ)(f(ℕ)(x))"는 무한공리와 같다,

정칙 공리 (Axiom of Regularity / Foundation)는 랭크 함수 Rank의 존재성을 보장한다.

이때, 무한 유향 비순환 가중 그래프 preZFSetThoeremModel에 대한 중복도 W를 정의하고, W(x, y) := int(x ∈ y)로 정의하면, (또한, 동시에, 멱집합의 존재도 보장하여 구성하면,)

멤버십 관계 ∈는 분류 공리꼴을 이용하여, 다음과 같이 재정의된다 ((x ∈ y) s.t. (x ∈ y) when (h(x) = Φ(x))) := F(y)(x) s.t. (∀P ∈ 2ᴬ)(F(P) = h(P)∧F(A)) (단. F는 가능한 한 전단사인 표기법이며, 현제의 정의에서 (∃h(P), F(A) ⇒ ∃(x ∈ y)라고 치역이 정의된다)
이는 분류 공리꼴을 만족시키는 정의이다.

preZFSetThoeremModel들 중에서, ℙ1, ℙ2를 만족시키는 preZFSetThoeremModel를 ZFSetThoeremModel라 할수 있는데, 이들 중 공집합과 자연수를 이론 내부에서 논하는 집합으로 가지는 ZFSetThoeremModel는 메타 언어로 동작할 수 있고, ℙ1를 만족시키는 preZFSetThoeremModel들 중에서 공집합과 자연수를 가지는 preZFSetThoeremModel는 ZFSetThoeremModel와 위계 이외엔 동등하다.

더 나아가서, 상수로써 자연수와 공집합을 가지고, 멱집합 연산과 ℙ1, ℙ2를 구성하는 연산이 정의되는 튜링 언어를 이용하는 형식문법 G 문법의 형식언어 L의 모델은 preZFSetThoeremModel이다. 따라서 FOL에서 HOL로 확장가능한 대수공리계에서 모델론과 구문론과 집합론과 논리까지 싹다 서술 가능하다면, preZFSetThoeremModel도 서술 가능하므로, 그런 대수공리계는 ZF와 동등하다. (이러한 모델의 존재성이 참이 된다는 전제하에)
```

저러한 대수 공리계는 존재한다, 예컨데 alkalic이 그렇다.

Königsberg Axiom은 alkalic을 구성하여, 저 조건을 만족한다. 따라서 ZF공리계와 Königsberg Axiom체제 (25.07.16 커밋 이전)는 ZFC랑 그 능력이 동등하다. (상호 서술)

VectorAxiom은 AC와 동치이다, 따라서 Königsberg Axiom + VectorAxiom은 ZFC와 동등하다. (상호 서술)

이때 다음 공리를 도입하자, 아래 공리계는 Alkalic-LinearAlgebra의 ZFC로 구성되었다
⊢ InaccessibleCardinalExistanceAxiom : ∃κ cf(κ) = κ ∧ κ > ℵ₀ ∀λ<κ, 2^λ < κ [cf(x) := least δ ∈ Ord s.t. ∃f : δ → x, (∀i < δ)(f(i) < x) ∧ (∀α < x)(∃i < δ)(α < f(i))]

이때 κ가 Alkalraum의 구성에 쓰인다.

Alkalraum은 κ로 그 크기가 확장된 Alkalic-LinearAlgebra의 객체를 Scala에 포함하는 Hilbertraum같은 (((Scala^κ)^κ)^....)^κ식으로 구성된 κ Rank Covector공간이며, 복소수나 분발복소수/이원수나 2ⁿ원수 등의 행렬표현에서 그 원래 집합의 원소 역할을 하는 객체로의 대응된것 등이 있을수 있는 실수 및 함수 및 객체들로 된 선형대수 텐서공간인데, κ크기를 보장하기에, Grothendieck 우주가 존재하는 ZFC를 표현할수 있어, 여기서 SetTheorem은 자동으로 Grothendieck 우주가 존재하는 ZFC로, 범주론이 서술된다.

## About

이전에 나온 CSFBAlgebra에서 모델론이 안먹히나 했는데 먹힘, 그래서 아이 새로 CSFBAlgebra를 정리(바꿈), 그게 Alkalic.

M = (ℕ, 0 = ∅, s(x) = x ∪ {x}) 대신

수열의 곱을 다가함수로 써서,

M = Π<ℕ, [0 := ∅], [s := λx. x ∪ {x}]>

같은 서수의 정의가 가능하다는 점에서,

이제 Structure와 변수 대입까지 함수 안에서 됬음.

이제 구조체도 non-structial 논리적 귀결에서 씀으로 쓸수있음

에초에 CSFBAlgebra를 대체할 목적으로 만든거니

나머지는 이하 생략.

### Alkalic-Proofmood

KönigsbergAxiom 에 따라서, 

 > 
 > 규칙 `using x = y → (Φ ↔ (Φ [x := y])))`
 > 
 > 원리 : `x = y → (Φ ↔ (Φ [x := y])))`서 `x = y`가 결론 (5번 라인)과 같음을 보임
 > 
 > ```Alkalic-Proofmood
 > □.1. using x = y → (Φ ↔ (Φ [x := y])))
 > □.2. x = y
 > □.3. Φ
 > □.4. Φ [x := y]
 > □.5. Φ ↔ (Φ [x := y])
 > ```

모든 추론은 규칙 `using x = y → (Φ ↔ (Φ [x := y])))`에서 시작되며, 규칙 `using x = y → (Φ ↔ (Φ [x := y])))`는 기본적으로 modus ponens 추론 규칙을 따르기에 타당 (valid)하다. (심지어 Königsberg Axiom이 항진인데, Königsberg Axiom을 제외하고는 대수 연산밖에 활용하지 않기에, alkalic은 건전하다)

(전건부정의 오류 하나 있어서 삭제함)

내부적으로 결론(5번 라인)이 참일때만 계속 동작함, 또한 결론은 리스트에 쌓이면서, 마지막 줄인 Theorem에 도달할때까지 Lemma가 리스트업되서, 문장이 참인지는 Lemma로 보임.

 > 
 > 규칙 : `Starting Listup Hyperthesis`
 > 
 > 미리 Hyperthesis나열을 시작함
 > 
 > 규칙 : `Quit Listup Hyperthesis`
 > 
 > 더이상 Hyperthesis를 받지 아니함
 > 
 > 규칙 : `Starting Another Subproof`
 > 
 > 새 스택프레임을 만들어, 새로운 부분증명을 시작함
 > 
 > 규칙 : `Quit Another Subproof`
 > 
 > 부분증명을 끝내, Lemma List에 추가하고, 스택프레임을 pop함
 > 
 > 규칙 : `APAristotel-y` (nonHyperVersion 형식증명 only)
 > 
 > HAPA Theorem이라는 외부정리를 이용하여서, y = x이고 y = z이면 x = z임을 보임
 >
 > 규칙 : `APAristotel-z` (nonHyperVersion 형식증명 only)
 > HAPA Theorem이라는 외부정리를 이용하여서, x = z이고 y = z이면 y = x임을 보임
 > 

### HAPA Theorem (Hyper Alkalic-Proofmood Theorem)

Alkalic-Proofmood nonHyperVersion 형식증명의 근거.

동시에 유일한 Alkalic-Proofmood HyperVersion에서의 형식증명

`y = x`, `y = z`가 가설일때,

규칙 `using x = y → (Φ ↔ (Φ [x := y])))`를 통하여, `y = z ↔ x = z`를 보인다, 즉,

문법상, `y = z → (y = z ↔ (y = z [y := x]))` = `y = z ↔ (y = z ↔ x = z)`이므로, 

y = z ↔ (y = z ↔ x = z)를 표현하기 위한 잉여적인 체계다.

(그치만 이전에 있었던 전건부정 오류때문에 또 고쳐야함 ㅠㅠ)

## Alkalic-Proofmood (Power Up - Version)

증명에 앞부분에 붙여야 할 한정사가 추가되었다, 부분증명을 만들어서 중첩 가능하기에, 각 기능을 동시에 붙일수 없다.

 - AristotelProof(비 명시시 기본) : 기존 증명 방식으로 증명
 - DavidHumeProof : Φₜ에 대해, t번 라인마다 매거적 귀납법을 쓰고, 옆 열에는 Φₜ가 귀납법 증명에 쓰이는 경우, 쓰는 칸이 된다. 맨 마지막줄에, 번호 없이, 귀납법 증명의 종류를 기재할때, `∴ Φₜ, Φₜ₊₁, ..., Φₖ ⊨ Φₖ₊₁` (강함), `∴ Φₖ ⊨ Φₖ₊₁` (약함), `∴ Mod(Φ) = ℕ` (일반적인 수학적 귀납법) 으로 기제한다.
 - EuclidianProof : 귀류법 (HegelianProof랑 다르다, 귀류법이다) ; 반증 마지막에, `∴ ⊥ ∴ ⊭ ¬
Φ ∴ Φ`를 놓는다. (`¬Φ`는 결론을 뜻한다.)
 - HegelianProof : 반증 (결론이 부정이 나오므로, "결론이 아니다"를 증명할때 쓰임; 왜냐하면, 기존 버전에서는 논리적 오류가 나오면 오류위치를 지적하고 프로그램이 종료됬기 때문에, 오류를 만들어 반증한 후, 종료하지 않는 AristotelProof가 필요했음)



또한 검증 프로그램 정지를 피하기 위해,

 - PreviewVersion : 이 부분•전체 증명에 대해서, 프로그램 정지 후 오류 지적을 제외하고, Preview리스트에 추가한다, 근거 없는 부분이라, 이걸 단 증명을 참고해서 에러나면, "Referance on Preview"에러 로그를 따로 뱉은 후 평상시 에러처럼 에러난다
 - DebugVersion : 오류가 나는대로, 디버그를 해주며, 훓고 지나간다, **프로그램 전체에 적용된다.**
 - ConjureVersion : 추측으로써, 정지를 피할곳에, `�`를 삽입한다, 이 부분•전체 증명은 가설(Hyperthesis)로 취급된다.
 - NormalVersion (비 명시시 기본) : 기존 방식



마지막으로, 다항식의 계산을 원활하게 하기 위해,

`Polynomial Simplify`라는 부분증명 폼을 넣고 다음을 인수분해하거나, `P(x) = 0`꼴을 풀면 (후자는 미리 `using P(x) = 0 Algorithm`이라고 명시) 오류 없이 증명을 받아들여준다.

A. `LinearSimplify`명령을 통해, LinearSimplify Theorem에 근거하여, 미지수가 여러개인 일차식을 정리한다

B. `Substracting [y := xⁿ]`명령을 통해, xⁿ을 y로 치환한 문장 `Φ`에 대해, `Substracting Variable`필드에 넣은 참인 문장 `y = xⁿ`에 따라서, Φ [y := xⁿ]가 나올때까지, 미리 일차식마냥 치환한 상태로 작업하게 해준다. (치환 변수 필드 논법; `Substracting Variable Field Proofs`)

C. `Solution (a, b, c, d, e)`명령을 통해, 2차 ~ 4차식을 인수분해(근의공식) / 전개(비에트의 정리)한다.

D. `TschirnhausTheoremSubsituate (n, a, b, x)`명령을 통해, `[x := t + b/na]`를 적용한다, 마찬가지로 증명의 원활함을 위해 Substracting명령에 근거한다 (사실 그럴 필요도 없이 구문론적으로 연산자를 정의해도 되는 간단한 문장(`[x := t + b/na]`)이지만)

E. 부분증명 문법에서 `synthetic division` 한정사로, 조립제법 이용 (생략표기가, 매거적 귀납에서 고정된 열의 다수의 행에대해 쓰이므로, 여기서는 쓸때, 행을 다항식으로, 계산 과정순이 열로 되므로, 돌려봐야하는 단점이 있다.)

F. `Alright synthetic division`한정사로, 일반적인 조립제법을 쓰고, 전처리 단계에서 synthetic division로 컴파일

G. 분배법칙을 위해서, `distribute[ 대상 ]` 안에 전부 넣어가지고, 이 증명 시스템용으로 있는 `분배법칙의 일반화 정리`에 따라, 분배함

H. `AlgebraicFormula` : 미리 증명한 곱셈공식을 이용해서, 계산되었음을 명시한다.

I. Gaussian Eimination or ERO & Subsituate : 가우스 소거 혹은 가감/대입

J. System of Quadratic Equations by Quadratic Form : 이차형식으로 연립이차방 풀이

K. System of Quadratic Equations by Cubic Form : 삼차형식으로 연립삼차방 풀이

L. Règle de Cramer : 크래머의 공식으로 풀이

M. `Extraneous Root is (□)` : 무연근 명시

N. `PolynomialFractionize` : 다항함수 분수화

O. `SolvePolynomialFraction` : 해당값 풀이

P. `Fractions Solution is (□)` : 해 명시

### 형식증명의 오토마타용 문법

`□.` 라인이 부분증명이라면, `□.line.`식으로 라인을 표기한다.
그리도, 라인과 라인 사이에 오직 whitespace및 `-`,`–`,`—`만 있을경우 해당 라인을 가독성 용도로 보고 주석처리한다.

또한, line표기에 앞선 점찍은 부분 앞에서 `|`부분이 문자열의 특정 열마다 이어지고, 끝나는 말단이 앞서 설명한 `-`꼴의 주석에 연결되어있다면, 해당 부분도 따로 오류처리하지 않는다.
그외에는, 열 구분자이기에 주석으로 보지 않는다

마지막으로, `[NOTE : ]`형식을 주석으로 본다.

마크다운 문서 내부에 위치했다면, HAlkalic-Proofmood(Hyper Version), Alkalic-Proofmood(일반 버전), PowerAP(Power Up버전)으로 코드 이름인 부분만 읽는다. 또한, 마크다운 부분에 부분증명 코드부분은, 부분증명으로 렌더링한다.

마지막으로 그렇게 html화되어 정리된 렌더링 뷰는, LaTeX 표기 기능을 추가해야만 할것이다.

(그럼에도 해당 html뷰는 아직 형식증명 검토가 안돌아갔으므로, 컴파일 상태인거지, 실행 상태가 아니다. 실행은 실행기에 돌려야, 문서 내부를 파싱해서, 부가적으로 제공된, [labare](https://faraway6834.github.io/unbeauty/privateNote/Proof/labare)•[unbare](https://faraway6834.github.io/unbeauty/privateNote/Proof/unbare) 코드와 함깨 해석하여(labare•unbare는 인터프리터 언어가 아니고, 정형 대이터 겸 사용자 편의 대이터 겸 Low Level 컴파일 언어다.), 검토된다; 이제보니 실행기보다는, 형식증명 검토기라는 명칭이 더 적합하다, 프로그래밍 언어는 하나도 실행하지 않고, 추론규칙을 재대로 활용했는지만 검사하여 검토작업(오류나 로그나 상태 표시)만 하기 때문이다.)

---

### 두번째 글 : `논리적으로 다룬다 전재할때, 대수식은 논리적으로 그 뜻이 해석 • 계산된다.`의 발췌

그렇지 아니하면, 논리적 해석 흐름에서 논리기호가 도출될수가 없다.

식의 계산은 그 값의 배정인 (x̄, f(x̄))와 같이 이루어지는데, 이 방식을 거부하는것은, 논리를 쓰지 않겠다는 말과 같다. (장자 왈 갓나서 죽은 아기보다 오래 산 사람은 없으니 팽조(760살이 넘게 살았다는 전설 상의 신선)도 일찍 요절한 사람)

#### 대수식의 논리적 해석 흐름에서 논리기호를 도출하자

먼저, 다음을 보이겠다

> 함자 `f :≜ (-F)` 를 정의해서, 여기에 대해,

`x = y 이면이 f(x) = f(y)`

이말은, 진리값 T, F를 다루는 식에서, F = 0으로 가정하고 푸는거나, F ≠ 0이 아닐때 푸는거나, 전부 x = y인 등식을 쓸때 f(x) = f(y)가 F와 무관히 동등함이 당연함으로, F = 0인 경우로 잠정적으로 취급하겠음

##### 대수식의 논리적 해석 흐름중 논리적 귀결관계의 도출

Step.1. 방정식을 만족하는 집합으로써의 모델집합이 해집합임을 보이자

먼저, 다음과 같은 다항식 함수 P를 정의하자.

> `P :≜ λA. λx. Πᵢ x - Aᵢ`

그리고 다음과 같은 방정식화 논리함수 Φ를 정의하자.

> `Φ :≜ λf. (f(x) = 0)`

그리고 마지막으로, 다항 방정식 ㅍ을 정의하겠다.

> `ㅍ :≜ φ • P`

그러면,

> `Mod(ㅍ(A)) = {x | x ⊨ (Πᵢ x - Aᵢ = 0)} = {x̄ | Πᵢ x̄ - Aᵢ = 0} = {Aᵢ | ∀i}`

임이 당연하다.

---

Step.2. 논리적 귀결관계의 도출

다항방정식 ㅍ(A), ㅍ(B)에 대해,

0. Mod(ㅍ(A)) ⊆ Mod(ㅍ(B))
1. {Aᵢ | ∀i} ⊆ {Bᵢ | ∀i}
2. ∀i Aᵢ = Bᵢ《주의 : 비약이다, 저건 배열을 정렬해야만 성립한다.》
3. ∃C P(B) = P(A)P(C)
4. P(A)|P(B)

으로,

> 
> 다항식 f, g에 대해 다항방정식 Φ(f) ⊨ Φ(g)
> 
> 이면이
> 
> f | g
>


##### 대수식의 논리적 해석 흐름중 진리값 배정되는 명제논리 결합자의 도출

¬x = T - x로 해석됨을 보이자. (경고 : 형식증명 아님)
A. proof of `x ≠ T ⊢ T ± x ≠ (1 ± 1)T`
0. `x ≠ T` (비 귀류법식 전제 문장)
1. `T ± x ≠ T ± T` (이항 by 함자 `(T ±)`)
2. `T ± x ≠ T ± T = (1 ± 1)T` (1번의 연장선에서 계산)
3. `T ± x ≠ (1 ± 1)T` (2번에서 식 요약) ⋯ ■

B. proof of `⊭ (1 + 1)T = 0 ∨ (1 + 1)T = T`
0. 먼저 part A by `⊭ (1 + 1)T = 0`와 part B bt `⊭ (1 + 1)T = T`로 나눠서 생각하자.
1.A. (1 + 1)T = 0 (귀류법식 전재 문장)
2.A. (1 + 1)T = 2T = 0 (1.A.번의 연장선에서 계산)
3.A. T = 0 ⊨ 2.A. ⊨ (1 + 1)T = 0 (연역)
4.A. ⊭ T = 0 ⊨ 2.A. ⊨ (1 + 1)T = 0 (연역)
5.A. ⊭ (1 + 1)T = 0 (연역) ⋯ ⊥
6.A. ∴ ⊭ (1 + 1)T = 0 (연역) ⋯ ■
1.B. (1 + 1)T = T (귀류법식 전재 문장)
2.B. (1 + 1)T = 2T = T (1.B.번의 연장선에서 계산)
3.B. T = 0 ⊨ 2.A. ⊨ (1 + 1)T = T (연역)
4.B. ⊭ T = 0 ⊨ 2.A. ⊨ (1 + 1)T = T (연역)
5.B. ⊭ (1 + 1)T = T (연역) ⋯ ⊥
6.B. ∴ ⊭ (1 + 1)T = T (연역) ⋯ ■

C.1. A, B ⊨ (x ≠ T ⊢ T - x ≠ (1 - 1)T) (A, B번에서 귀결)
C.2. A, B ⊨ (x ≠ T ⊢ T - x ≠ (1 - 1)T = 0T = 0) (C.1.번의 연장선에서 계산)
C.3. A, B ⊨ (x ≠ T ⊢ T - x ≠ 0)  (C.2.번에서 식 요약)
C.4. A, B ⊨ (T - x = 0 ⊨ x = T ⊨ x) (C.3.번에서 연역추론 : 대우) 《주의 : "x = T"의 의미를 "진리값 x가 참"관점으로 해석함.》
C.5. A, B ⊨ (T - x = 0 ⊨ x) (C.4.번에서 식 요약) 《주의 : 근거인 C.4.에서 "x = T"의 의미를 "진리값 x가 참"관점으로 해석함.》
C.6. C.5.번 내용 ⊢ ¬x = T - x (최종결론)《주의 : "x = T"의 의미를 "진리값 x가 참"관점으로 해석함.》
Q.E.D.

x ∧ y는 xy로 해석됨을 보이자.
T에대한 방정식 (T - x)(T - y) = 0의 해는
x = T ∨ y = T이다.
따라서, x = T ∨ y = T ⊨ T - (T - x)(T - y) = T고,
x ∨ y = T - (T - x)(T - y)로 해석된다.

이때 De Morgan's Law, ¬(¬x ∨ ¬y) = x ∧ y서

T - T + (T - T + x)(T - T + y)
 = xy이다.
 ⋯ Done.

##### 방정식의 의미 : 술어논리(함수논리)의 술어로써, 잠정적으로 특칭양화사를 사용해, 잠재적으로 전칭양화사를 사용함.

방정식 P(x) = 0이 불능이란것은

∄P(x) = 0란 뜻이며

∀P(x) ≠ 0이란 뜻이고 ⋯ ①



방정식 P(x) = 0가 불능이 아니라면

∃P(x) = 0이다. ⋯ ②



방정식 P(x) = 0이 부정이란것은,

부정방정식이므로,

∀P(x) = 0이다. ⋯ ③



①에서, 불능형 방정식 P(x) = 0에 대해,

P(x) ≠ 0은 부정형이고, ⋯ ④



부정형 방정식 P(x) = 0에 대해,

P(x) ≠ 0은 불능형이다 ⋯ ⑤


그렇다면 ③에 따라 다음을 정의하자,

> `Φ :≜ λf. (∃f(x) = 0)`
> 
> `P :≜ λf. (∃f(x) ≠ 0)

그러면 다음을 알수 있다.

④에 따라, Φ(f)가 거짓 이면이 P(f)는 부정형
⑤에 따라, Φ(f)가 부정형 이면이 P(f)는 거짓

Φ(f)가 참 이면이, f(x) = 0를 만족시키는 x존재
P(f)가 참 이면이, f(x) = 0을 불만족시키는 x존재

부정형 방정식을 만들고 싶다? 하면

¬Φ(f) = P(f), Φ(x) = ¬P(f)에서,

불능형 방정식 Φ(f)에 대해 부정하거나,
불능형 방정식 P(f)에 대해 부정하면된다.

술어 P에 대해
Mod(P) = ∅ 이면이 ∄P(x) 이면이 ⊭ P
이면이
Mod(¬P) = U 이면이 ∀¬P(x) 이면이 ⊨ ¬P

따라서, 방정식은 기본적으로 특칭 술어로써, 사용할수 있음
````

### [연역탐구의 과학적검증](https://faraway6834.github.io/unbeauty/privateNote/Alkali/연역탐구의_과학적검증)
```
# 연역 탐구의 과학적 검증

## 공리

인간의 생각는 기본적으로 연역적으로 타당한 생각 대신, 귀납적으로 타당한 생각을 기반으로 생각한다고 나는 본다. (단. 보편적인 경우)

따라서 나는 인간을 귀납적으로 사고하는 동물이라고 공리를 세우겠다.

## 연역적 탐구

그렇다면 인간의 연역적 탐구가 과연 페러다임 시프트를 일으킬수 있는 탐구인가?

연역적 탐구의 대중적인 예시로 수학이 있다.

피타고라스 학파에서 기하학으로, 대수 방정식에서 허수와 음수의 인정으로의 변화, 미적분학의 등장, 무한을 다루기 시작한 데데킨트와 칸토어, 러셀의 역설, 불완전성의 정리, 정지 문제등등 여러 페러다임 시프트가 존재했다.

이러한 페러다임 시프트의 원인은, 연역적 탐구의 실패에서 온다.

그렇다면, 인간은 왜 연역적 탐구에 실패했었는가?

왜냐하면 인간은 귀납적으로 사고하기에,

연역적 추론의 구성에 있어, 그 구성은 귀납적인 방법으로 이루어졌고, 또한 근거에 선택에 있어서도 귀납적이지 않기 어렵기 때문이다.

### 연역적 추론의 구셩

연역적 추론이 구성되었을때,

우리는 그 추론을 검증하기 위해, 연역적 방법을 사용해야한다.

그런데, 추론을 검증할 필요는, 연역적 추론의 구성에 있어, 아까전에 설명한 귀납적 불확실성이 보장하기에,

그 추론의 검증이라는것은, 귀납법에서 가설 H에 대해, 그것을 뒷받침하는 근거 Φ를 나열하는것과 같다.

즉, 연역적 추론을 구성하는 우리의 생각 과정 자체는,

귀납적인 생각 과정인 과학적 탐구에서의 가설이 되는것으로,

우리는 그러한 생각을 검증하여, 구성의 의도와 함께,

명확히 할 필요가 있다.

### 연역적 추론의 구성 과정의 과학적 검증

연역적 추론의 구성 과정의 과학적 검증은,

연역적 추론이 대한 검증보다는, 해당 연역적 추론을 떠올리게 된 계기에 대한 검증이다.

만약 "[x := y] 대입 가능함은 x = y임과 동등하므로, 수학에서 추론은 이러한 대입 원리로 설명할수 있는 경우가 있을것이므로, 이게 많은지 확인해야겠다"라는 생각이 들어, 탐구를 시작했다고 하면, 전건인 "[x := y] 대입 가능함은 x = y임과 동등하므로"는 거짓(진실은 "x = y 이면 [x := y]"일뿐)이고, 후건은 대입 원리로 설명되는 부분이 있으므로 참이다.

따라서 연역 추론의 구상은 항상 귀납적 불확실성을 동반하고,

탐구 배경의 타당성이, 그 귀납적 불확실성을 줄임이 너무 당연하다.

## 결론

다시 말하자면,

연역 추론의 구상이 항상 귀납적 불확실성을 동반하기에,
탐구 배경의 타당성이 그 귀납적 불확실성을 줄이며,
연역 추론에 구상에 대한 검증은 그 구상에 대한 타당성을 보이는 방법이며,
연역 추론의 구상에 대한 검증이 연역적 실수가능성은 이에 대하여 항상 필연적으로 존재하고
따라서, 보다 과학적인 방법으로 귀납적 한계에 의한 연역적 실수가능성은, 무조건 받아들이기 보다는, 과학적 검증을 하는것이 좋을것이다.
```

### [Alkali](https://faraway6834.github.io/unbeauty/privateNote/Alkali/형식주장)
```
# 형식주장

데이비드 흄이 말한 귀납법은, 주장할만하게 우리의 보편적인 인식에서 보편적으로 참이다. 따라서 언어를 구상하는 문화 차원에서 언어가 맞는말 속성으로 허용하니, 주장해도 좋다.

언어(=사유)적으로 H_1이 구상되어, 인지(발견 후 인식)의 유효성 `Φ_1, Φ_2, ..., Φ_n, H_1ㅑ Φ`이고, 그것에 대한 귀납적 추측 H2에 따라서 이론을 증명하는 모델은 과학적 탐구의 유효성 `Φ_1, Φ_2, ..., Φ_n, H_2ㅑ Model, Φ_1, Φ_2, ..., Φ_n, H_1ㅑ Φ, P ㅑ Theorem`로 구성되며 (P는 중간인자로 무시하자.), 이를 기록한것이 과학사고, 인지는 H_1, 과학적 탐구 "H_1에서 아마도 H2일것"인 두가지 추론의 근거는, 데이비드 흄의 과학 철학에 근거한다. 과학은 엄밀해야 하며, 따라서 H_1, H_2는 반증 가능하다 (과학의 반증 가능성), 따라서, H_1과 H_2로 과학 이론이 구성되며, 이 과정의 검증이자 증명 과정은 H_1과 H_2를 인자로 받는 수학 함수이다, 따라서 나는 이러한 과학적 탐구애 대한 유효성 형식증명 체계를 "형식주장"이라고 명명하겠다

과학사에 따른 이론의 정립을 일반화하여 도구화한것이 바로 "형식주장"이다

나는 형식주장이 과학의 핵심이라 생각한다.

## 형식주장-과학

형식주장-과학은 발견 Φ_k (k = 1 ~ n)과 인지(인식) H_1및 가설 H_2로 이루어져 있기에, Φ_k (k = 1 ~ n)과 인지(인식) H_1및 가설 H_2의 튜플 Input에 대해, 형식주장을 거쳐 나온 Model과 Theorem을 담은 순서쌍을 Output이라고 하고, Input과 Output의 튜플로 구성된다

### 한계

형식주장-과학은 과학이 형식논리로 서술된다는 가정 하에 성립하기에, 해당 가정이 깨지면, 페러다임 쉬프트로 인해 죽어버릴것이다.
이 점을 잊지 말아야 한다.

나는 과학이 수학에 의존하는 이유를 솔찍히 근본적으로 모르겠다.

### AFZFC(Alkalic) 형식주장-과학

AFZFC에서 형식주장-과학은 Input, Output튜플을 해석하는 객체로 구성된다. FOL에서는 뢰빈하임-스콜렘 정리에 따라, 어떤 조건을 만족하는 모델은 더 크거나 작을수 있다.

과학은 환원주의적 성격이 아닌 각각에 모델에 대한 범주론적 해석으로 이루어져야 넓은 시야라고 본다.

결국은 과학에서 이유를 따라가다 보면, 우리의 관찰이 어느세 형식적으로 정리되어있기 때문이다.

따라서, AFZFC 형식주장-과학 (이러한 객체들에 대해 탐구하는 과학사적 모델정립의 형식적인 분석이므로 관찰에 의존하기에, 경험적인 학문임이 당연하다) 은 이러한 모델의 다양성은, 단지 해석의 다양성이라 본다.
```

### 형식적 탐구 : [과학](https://faraway6834.github.io/unbeauty/privateNote/Alkali/과학)
```
# 과학

과학은 형식주장-과학으로 귀납적 사고의 대상인 과학과,

형식과학중 일부 연역적 사고의 대상인 학문으로 나뉜다.

그러나, 나는 그러한 연역적 학문이 과학이라고 본다.

왜냐하면, 연역적 탐구의 구상에 과학적 검증이 연역적 과학의 핵심 속성이라고 보기 때문이다.

## 연역적 형식과학

연역적 탐구의 구상에 과학적 검증이, 연역적 탐구의 과학적 속성인 귀납적 불확실성을 완화하기에,

연역적 탐구에는 나는 다음과 같은 두가지 쳅터를 추가하면 좋으니, 허용해줄 필요가 있다 본다.

1. Background : 생각 배경
2. Varification : 생각 배경에 대한 검증

그렇게 되면, 연역적 탐구에 대한 실수 가능성은, 지금같은 매우 높은 상황이 아니라, 과학적 학문으로써만큼 줄을수도 있겠다.

## 순수과학 (사회과학, 형식과학, 자연과학)

이 부분은 사실상 말 그대로, 형식주장-탐구로,

형식주장-탐구가 에초에 이 부분에서 일반화되었기 때문이다.

위의 연역적인 탐구에서는, 연역적인 실수를 일반화하려는 위험한 시도이나, 이 경우는 명확하다.

## 응용과학

응용과학의 핵심은, 과학을 응용하는 기술이다.

그러한 기술이라는 개념을 다루는것이 응용과학이다.

따라서, 순수과학과 다른점은, 인간의 귀납적 사고를 통해, 기술을 창조하고 검증하는것 뿐이다.

# 마치며

나는 이러한 것이 사실 과학보다는, 형식적 탐구라고 본다, 너무 광범위하다고 보기 때문이다.

## 탐구에서 필수적인 조건

### 형식탐구

그래서, 과학적 탐구가 먼저 나오는지 나중에 나오는지에 따라, 먼저 나오면 (= 배경검증) 연역 논문 = 대부분 수학, 나중에 나오면 (= 본론) 귀납 논증 = 대부분의 과학, 으로 논문 포멧이 설정되는것.

### 과학적 탐구

0. 무슨 배경인지 명확히 한다
1. 탐구 전에 데이터 콜랙팅을 철저히 한다
2. 가설 설정부터는 인과관계가 얽혀 이론의존성과 인과론적 시간때문에 구분해야한다. 실험은 재현가능한 사실이여야 하며, 관찰도 객관적인 데이터를 써야하지만, 둘 사이의 차이는 명확하며, 그래야만 한다.
3. 객관성을 위해 해석은 별도로해야함도 당연하다.
```

## 서술 체계

### 논문 형식 아이디어 : [idea](https://faraway6834.github.io/unbeauty/privateNote/Alkali/idea)
```
# 형식탐구할 때 개인 규칙을 정하자.

정의를 synurl로 때울수 있음은 장점이지만, synurl개발과 문서화가 쉽지 않다.

## Algebric Form of ZFC (AFZFC = Alkalic) 체계에 대란 증명을 할때, (실제론 이부분 안씀, 절대 안씀, 오직 AlkalicProofmood와 AFZFC에 대한 증명에서만 딱 한번 쓴다.)

### 1. 정의는 [synurl](https://pinanot.github.io)을 이용한다.
### 2. 증명은 [Proofmood](https://proofmood.mindconnect.cc/index.php)를 이용한다.
### 3. 계산은 [Geogebra](https://www.geogebra.org)나 [Wolfram|Alpha](https://www.wolframalpha.com)를 이용한다.

## AFZFC로 증명시(실사용, AFZFC를 증명하는것 이외는 AFZFC를 쓴다, 정확히는 AlkalicProofmood자체를 증명할때 이외에 사용, 여기 항목이 전부 기본)에

### 1. 정의는 [synurl](https://pinanot.github.io)을 이용한다.
### 2. 증명은 [AlkalicProofmood - PowerUpVersion]을 이용한다
### 3. 계산은 `Web Graphic Linear Unbeauty Calculater & Extension Toolkit`라는 곧 만들 정보에 대한 명세에 적힌 사이트로 한다. 아직 명세도 안만들었지만

잠시만 synurl이 pinanot이네...?

## 정리하여 쓸 떄


(Colab Capsule Markdown)라는 타입을 만들어서,

`<?Conclusion=**요약*>`하는 시스템 만들기 (`\<?Conclusion=**요약*>`로 이스케이프)

거기에

`<?Abstract=**요약*>`하는 시스템 만들기 (`\<?Abstract=**요약*>`로 이스케이프)

하는 시스템도 추가.

요약이 무슨 문서의 대부분이 되면 안되니까 미친짓이니까, 추가함.

예정 : 이걸 Quatro에서
```

### 논문 서술에 대해 비판받을수 있는 측면 : [비판](https://faraway6834.github.io/unbeauty/privateNote/Alkali/비판)
```
# 비판

일단 너무 당연한 내 주관을 명시하겠다.

예시를 드는것은 속뜻에 대한 해석이 개입하기에

예시를 잘 전달하지 않으면, 쓰지 않는것이 차라리 낫다.

예시는 말의 방식이니까, 그런건 여기선 말하지 않겠다.

## 응용가능성과 후속연구

### 응용 가능성의 스노비즘

예컨데, 응용가능성은, 개념 객체의 사고 방향성중 하나다.

개념 객체는, 사고 방향성과, 사고 흐름(이 흐름은 알고리즘을 말한다, 물론 알고리즘화 안되는 흐름도 순서대로 하는 생각은 다 말한다)을 따라서, 다른 객체로 도달하는것을 가능한 추론에서의 도식적 생각모델이다.

`Obj.방향성 ⊢ Obj`의 흐름을 가진다는 모델이다.

그러한 측면에서, 응용가능성은 감정적 개입이 되면 안된다.

그건 개인적으로 사이비라고 생각한다.

### 후속연구 문단

동일한 맥락에서, 우리 탐구가 완벽하지 않기에 있는 문단이지, 스노비즘 홍보따위가 되면 안된다.
```

### 어떻게 "과학(형식탐구) 할" 것인가?
```
# 어떻게 "과학(형식탐구) 할" 것인가?

형식탐구는 다음으로 수행해야한다.

## 형식탐구

그래서, 과학적 탐구가 먼저 나오는지 나중에 나오는지에 따라, 먼저 나오면 (= 배경검증) 연역 논문 = 대부분 수학, 나중에 나오면 (= 본론) 귀납 논증 = 대부분의 과학, 으로 논문 포멧이 설정되는것.

### 연역적 추론

1. 정의는 [synurl](https://pinanot.github.io)을 이용한다.
2. 증명은 [AlkalicProofmood - PowerUpVersion]을 이용한다
3. 계산은 `Web Graphic Linear Unbeauty Calculater & Extension Toolkit`라는 곧 만들 정보에 대한 명세에 적힌 사이트로 한다. 아직 명세도 안만들었지만

### 과학적 탐구

0. 무슨 배경인지 명확히 한다
1. 탐구 전에 데이터 콜랙팅을 철저히 한다
2. 가설 설정부터는 인과관계가 얽혀 이론의존성과 인과론적 시간때문에 구분해야한다. 실험은 재현가능한 사실이여야 하며, 관찰도 객관적인 데이터를 써야하지만, 둘 사이의 차이는 명확하며, 그래야만 한다.
3. 객관성을 위해 해석은 별도로해야함도 당연하다.

## 논문 형식에 대한 깔끔함(이유있음)의 정의

글은 해당 말을 사용할때의, 보편 타당한 객관의 기준이 충족되는것이, 해당 말의 보편 타당한 보통의 경우보다 훨씬 더 그 충족되지 않는 예외가 많기에,

읽는이와 쓰는이는 문제점을 고려하여, 재대로 쓰고 재대로 읽는, 언어의 궁극적 목적이자 실용성의 핵심인 정보 전달 체계로써, 기능하는것이 핵심이므로, 그것에 집중해야지, 논문을 문예로 보고 예술로써 파괴하는것은 권장하고싶지 않다.

### 글을 제대로 못할거면 글을 잘쓰기 위해 노력하거나 개판으로 쓰거나가 모든 선택지는 아니다.

(Colab Capsule Markdown)라는 타입을 만들어서,

`<?Conclusion=**요약*>`하는 시스템 만들기 (`\<?Conclusion=**요약*>`로 이스케이프)

거기에

`<?Abstract=**요약*>`하는 시스템 만들기 (`\<?Abstract=**요약*>`로 이스케이프)

하는 시스템도 추가.

요약이 무슨 문서의 대부분이 되면 안되니까 미친짓이니까, 추가함.

글 못쓰는 속뜻파악장에에게 추천함.

### Application과 후속연구 문단에 대한 원칙

응용가능성은, 개념 객체의 사고 방향성을 서술하는 문단이다

개념 객체는, 사고 방향성과, 사고 흐름(이 흐름은 알고리즘을 말한다, 물론 알고리즘화 안되는 흐름도 순서대로 하는 생각은 다 말한다)을 따라서, 다른 객체로 도달하는것을 가능한 추론에서의 도식적 생각모델이다.

`Obj.방향성 ⊢ Obj`의 흐름을 가진다는 모델이다.

그것을 작성하는것을 원칙으로 해야한다. 그것이 지성이라고 하는것이니까.

동일한 맥락에서, 후속연구는 우리 탐구가 완벽하지 않기에 있는 문단이지, 스노비즘 홍보따위가 되면 안된다.
```

### 형식 탐구론은 형식주의 근본주의적 극단주의 철학사조가 형식탐구임을 인정한다. 앎에 대한 밥벌이를 위한 극단적인 지식에 대한 갈망으로써 LCPC체계를 제안한다. (궁극적, 핵심내용, **이 글에서 가장 핵심**) 근데 영어 : [LCPC (la .le cukta poi ciksi.)](https://faraway6834.github.io/unbeauty/privateNote/Alkali/LCPC)
```
la .le cukta poi ciksi. : la .lojban. bangu zo'e la .formal research.
.i ma'a tadni la .formal research.

translation of la .lojban. defination

`la .le cukta poi ciksi.` is lojban lauguage formal research (형식 탐구) s.t. phylosophy s.t. `ma'a tadni la .formal research.` what mean "we are all studants of formal research" by referance on "we must not forget about ignorance of knowledge" so that we must be an be an educator and studants. idiot is trutly genious.
```

# 결론

LCPC (la .le cukta poi ciksi.)가 핵심이다. LCPC는 모든 일반인이 논문으로 즉각적으로 배울수 있어야 함을 강조한다.
지능의 우열을 가리지 않아야 한다 보는 극단적인 탐구 사조이자 연구 방법론 및 체계다.

오해의 소지가 있어 수정하는데, 일반인이 논문으로 배움과 지능의 우열을 가리지 않는것이 이상향이지, 거기에 대한 맹목적이고 급진적인 자세는 옹호하지 않는다.

우리는 사회운동이나 정치적 입장따위가 아닌 방법론이기 때문이다.

Q. 좌빨 극좌 아닌가?

틀렸다, 개다가 나는 우파다, 정치 성향에 무관하다. 개혁적 사조는 도덕률이라서 무시해도 되는 사조다. 누구나 알아듣을수 있게 쓰는것이 뜻이 명확하므로, 스노비즘을 막으려는것이다. 지성인은 수정 가능한 부분은 하라는거다. 에초에 내가 귀찮아하는게 많은 미성년자인데도 저렇게 쓴거면 말 다했다. LCPC가 극단적인 이유는, 기존 과학의 보편 타당한 가치가, 철학적으로 인간이 탐구하는 방법으로써 일반화해도 문제없다는 생각에 있다.

Q. 인본주의인가?

아니 누구나 훌륭한 지식을 낼 수 있으므로, 귀족적인 서술은 병신짓이라는 사조지 절대 인본부의가 아니다, 인본주의 입장에선 오히려 반인본주의(구조주의, 형식주의)다.

Q. 왜 만들었는가?

학자적 기저는 돈이나 제도에 무관해야 한다.
그러나, 지금 학계는 병적으로 변질된 학자적 기저와,
타락하고 (= 제도화된 비효율) 문란한 (= 돈냄새나는) 상태이기 때문이다.
보수적인 정상상태인 "재대로된 탐구"로 돌아가기 위해서,
개혁해야한다.

---

 - LCPC 원칙 : 1. 검증은 본래 목적인 사실여부에만 주목해야하지, 다른 모든 가치에 대해 배타적이여야한다. (다른 중요한 가치에 대해 안전장치가 필요하다. 그런건 근데 검증에 넣으면 안된다, 안전함을 인증받는것이 차라리 낫다) 2. LCPC Proceedings는 누구나 항상 publish가능해야 하며, 비판 가능해야 하고, 그 사람의 인격으로 존중받아야 한다 (학술 공동체는 열리고 도덕적인 사회여야 한다는 소리는 아니다, 물론 그렇다면 좋겠지만, 학술 공동체는 불필요한 공격을 하는 멍청한 체계가 아니여야 한다는것이다 (모든 공격은 불필요함을 일부 가지므로, 존중을 동반한 논박만 허용해야한다.)). 3. 효율적이고 이성적인 탐구를 위하여, 다음과 같은 자유는 허랃될 필요가 있다 : 모든 이의 LCPC proceedings에 대한 peer-review를 부탁할 권리는 자유권이기 때문에 자유권을 보장해야 하며, 또한 아무나 LCPC proceedings를 평가한 후에, peer-review가 아니더라도 mass-review (대중의 리뷰) 를 달 권리는 자유다. (주의 : 권위자가 잘아도 동료가 아니면 mass-review다. mass-review는 수락되지 않은 PR과 같다. peer-review는 협업과 같고) 【개인적 입장 : peer-review라는 검증 주체의 필요성에 비관적 감정이 든다. 어떻게하지?】
 - LCPC proceedings : 객관적 평가(peer-review)를 거치지 않은, default값
 - LCPC preprint : Archaive용으로 객관적 평가(peer-review)를 거친 LCPC Proceedings
 - LCPC book : 엄밀한 체계적 검증(LCPC book sertification protocal)을 거친 LCPC preprint
 - LCPC book sertification protocal : LCPC book sertificater의 LCPC book sertification을 진행하는 protocal로, 해당 LCPC book sertificater의 검사 방식을 말한다. LCPC book sertificater는 LCPC book이 될 LCPC preprint이 왔을때, 정해진 절차 (LCPC book sertification protocal)에 따라, 검증만 하고, 인증서 (LCPC book sertification)를 주어주는 기관.

아래 입장은, 실제 탐구가 비효율적이라고 봐서 썼다.
```
# 임시적 입장 : 실제로 지지하지 않는다. 문외한인 상태로 쓴거라 내가 곧 배우고 오겠다.

LCPC proceedings는 학술 서적과 논문의 역할을 동시에 하고, 효율적이고 빠른 속도를 가진다.

아래 두가지 비효율의 폐지 사례를 제시한다.

기존 학술 매체 대비 자유로운 측면
 - Hypothesis같은 역할을 이용해, 자료를 넣을수 있다. (LCPCAlkalic-Proofmood PowerUp Hypothata 기능) [활용 예 : 정형 데이터 제시 • 사례 연구]
 - 말투에 있어 표준 lojban어면, 자유롭게 서술 가능하다. [활용 예 : 학술 발표 자료 서적]

학술 학문 분야를 두가지 제시함
 - LCPC Reivew Philosophy : 리뷰는 과학철학적 탐구 방법이고, 메타적이다.
 - 학문 응용 실험학 : 학문을 응용하는 방법으로써, 백서나 매뉴얼을 쓸수 있다. 거의 모든 학문에는 응용실험학이 붙어있다 본다.
```