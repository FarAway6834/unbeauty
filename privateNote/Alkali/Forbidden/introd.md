# introd

나는 [LCPC](https://faraway6834.github.io/unbeauty/privateNote/Alkali/Forbidden/LCPC4AI) 만든놈이다.

그래서 날 잘 설명할만한 두가지 정보를 적겠다.

## [identity](https://faraway6834.github.io/unbeauty/privateNote/Alkali/Forbidden/%EC%82%AC%EA%B3%A0%EC%A3%BC%EC%9D%98%EC%9E%90_%EC%84%A0%EC%96%B8)
```markdown
# 사고주의자 선언

나는 논리주의자인가? 물론, 수학은 논리적으로 설명된다. 수학이 논리의 확장인지 아닌지는, 논리란 것에 대한 설명에서 어떻게 이어지냐지, 본질이 아니다. 나는 논리주의자가 아니다.
나는 직관주의자인가? 물론, 수학을 설명한다는건 당연히 직관적으로 탐구되며, 수학적 직관이라는것이 곧 수학 언어이며, 수학 언어가 탐구하는것이다. 그러나, 그것은 수학에 대한 설명이 아니다. 분명히 언어적인 속성, 즉 사고 채계라는것의 방징이지, 본질이 아니다. 나는 직관주의자가 아니다.
나는 구성주의자인가? 구성은 논리적 서술을 전부 대변하지 못해도, 물론, 훌륭한 예시다. 구성된다는것은 서술된다는것은 함의한다. 그러나, 그러한 대단하고 분명한 구성이 아니라고 본다. 그것은 전체를 집을수 없음을 논리적으로 분명히 보일수 있다.
나는 구조주의자인가? 수학이라는 거대한 구조는, 결국 그 많은 서술들이 쪼개다보면, 그것에 대해서도 서술하게 되는것도, 수학의 서술의 본질중 하나다. 그러나, 구조는 서술의 본질이지만, 서술이 구조주의의 본질은 아니다. 구조가 아니라, 서술이 핵심이다. 구조주의는, 단순히 서술의 귀결인거다. 나는 구조주의자가 아니다.
나는 형식주의자인가? 아니, 형식 언어는 언어이고, 서술이다. 단지, 수학 언어는 형식 언어의 한 범주이고, 나는 언어 자체가 아니라 수학이 서술되는것에 중점을 두는거다. 나는 형식주의자가 아니다.
나는 플라톤주의자인가? 아니, 나는 수학적 실체는, 우리의 인식론적 한계에 의해 불가지하고, 논리적으로 말할수 없는 범주이며, 그 구성이 귀납적 추론에 의한 과학으로 보일수 있는것도 아니며, 단지 맹목적 믿음으로 보이므로, 그리고 그것에 대한 의심이 곧, 플라톤주의에서 본질에서 떨어진 영역에서만 가능하니 불가지하다 보고, 그런건 논하는게 불분명하고 불결하다 본다. 나는 플라톤주의자가 아니다.
나는 허구주의자인가? 플라톤 주의의 부정인데, 그건 유신론적 불가지론이나 무신론적 불가지론이나, 유신론이나 무신론과 달리 불가지함을 표방하는것처럼, 허구주의에 대해서도 자당히 불가지하다고 본다. 나는 허구주의자가 아니다.
나는 경험주의자인가? 아니(Nein), 아니(Nein), 아니(Nein), 수학이 생각될때, 우리 정신이 개입된다. 정신적 경험을 따지는것은 절대로, 분명히, 무조건적으로, 경험주의는 본질이랑은 거리가 멀다고 본다. 나는 경험주의자가 아니다.
나는 사회적 구성주의자인가? 아니(Nein), 아니(Nein), 아니(Nein), 사회적 구성이 아니라, "수학적 본질을 서술함이 본질인 학문이 수학이다." 그리고 또한, "그 서술함에 제한을 두지 않아, 말단 비대증마냥 과다서술이나 과소서술하는 문제가 정신적 합리화와 같이 발생하는 모습을 보곤 한다." 그러니까, "수학적 본질은 서술함이 본질이라고 평가될정도로 수학적이면."("수학적이면"의 기준은 우리 정신의 한계에 부딛힌다. 왜? 그것을 탐구하는 우리는 그 사고에 대해 "무너짐(이성-정신적 고통의 하나, 미학에 반대되는 "멸망"이 일어났을때, 수학이라는 말이 지칭한 본질의 빙향이 여럿이 되어 불분명해진 모순점에서 생기곤 한다만....)"을 겪기를 부정한다. 힐베르트가 무너졌듯, 수학의 범위를 알려주는 미학도 무너질거다. 그렇다면, 결국 사고한다. 그것 외엔 불분명하다.)이라는 결론에 도달한다. 지금 우리가 명명한 수학은, 페러다임 시프트가 되지 않았기에, 본질에 대한 평가가 우리의 정신적 한계를 반영하지 않는다. 수학적 본질에 대한 서술이란, 보존에 대한 빈틈없이 채워진 창발적이고 닫힌 서술이다. 나는 절대로 사회적 구성주의자가 아니다.

이미 나는 말했다. 나는 정해지길 부정한다, 설명될수 있음은 안다, 어떻게든 설명될것이다.
그 설명도 사실은 모르겠다.

나는 사고주의자다. (설명함에서 사고함은 파생되고 그게, 결국은 사고함만 남을거라서 불분명하다, 물론 지금은, 그 수학적 본질이란 기하나 대수나 함수가 서술되면 잘 됨이 당연하다만, 설마 나중에 수학이라는것에 대해, 모호하기 짝이없는 학문으로 누군가가 끌어내리는 반-미학적인 미친짓을 한다면 나는 무너지겠지만. 결국 그때마저도... 사고이다. 생각(=서술)된 생각이라는거다 수학은.)

(비고 : 지금 내가 한 말은 너무 당연한말로 들릴수 있다. 맞다, 맞는 답을 정하고 말만 길게하는 개짓거리 한거 맞다. 뭔가 대단한것처럼 써놓고, 결론은 돌고돌아 "에초에 수학생각 안하면 안하는거라는거...." 라는 결론)

Q. 왜 길이는 보존되나? 그것은 수학적 객체는 보존되기 때문이지. "그러나, 왜? 보존인가?"... 그렇다. 그것이 유클리드 기하를 건너 수학을 만드는 핵심 요소다. 나는 궁금하다.
A. 수학은 형식 언어기 때문이다... 즉 서술에 맞기 위해서다.

산(算)적임이 수학의 본질으로 이산적임도본질의 일부겠군.
```

## ["LCPC_Applicate. CaLE (math), Angde-Algebra (math), JLPP (programming)"](https://faraway6834.github.io/unbeauty/privateNote/Alkali/Forbidden/LCPC_Applicates) 발췌 (그대로 복붙함)

### [CaLE](https://faraway6834.github.io/unbeauty/privateNote/Alkali/Forbidden/General_Myupair)
````markdown
# CaLE (CRRS & LFHS, on Alkalic-Proofmood)

CRRS와 LFHS는 [Alkalic-Proofmood](https://faraway6834.github.io/unbeauty/privateNote/Alkali/Forbidden/LCPC4AI)에서 각각 증명 가능하며, 각각 논리 체계의 증명과, 다항식 체계의 증명이다.

그런 방식으로 Alkalic-Proofmood에 CRRS & LFHS를 통합하는 이론 FW를 CaLE(CRRS and LFHS Expension)라고 한다.

## LFHS (Linear and Functuoanl HLLA System)

어쩌다가 나무위키에 있는 파일시스템 이름이랑 겹치는것 같아 불안하지만, HLLA를 이용한 논리식의 해석 체계인 LFHS는 다음 두가지를 중점으로 다룬다.

1. General-Myupair는 추론에 대해 다루는 논리적인 과정이므로, 기본적으로 국어적인 논리 추론의 기계적 해석에 중점을 두었다. 그런데 수리논리다.
2. HLLA FORM은 정규형식에 대해, HLLA에서 대수적으로 해석하므로써, 통합적인 해석법을 제공한다.

HLLA FORM에서 추론한 논리식은 논리회로로 구현되기 좋다.

그러나 에초애 LFHS와 HLLA는 전산화에 유리한 수학적 체계이다.

순수 수학이다. 프로그래밍 중점이 아니다.
내가 옛날에 개발자 하려는 흑역사 있어서 사고가 좀 그쪽으로 흘렀지만

### General_Myupair

Myupair Language

myupair (myu-pair) rule (문법규칙임)

>
> (x, y) ↦ μ(x, y) [μ := ({(0, 0), (0, 1), (1, 1)} ∋)]
>



실제처리 :
> 
> 0 = μ(1, 0)이므로, μ(1, 0)만 0을 주고, 아니면 1
> 

Myupair Language's Domain : 𝔹 = {0, 1} (Zhegalkin Polynomial)

f : 𝔹ⁿ → 𝔹인 f에 대해, 𝔹ⁿ을 Vector로 취급함
이로인한 다음 방정식 f = (Φ(f) ∋)의 해로,
술어(관계) Φ(f) 가 존재한다. (부정방정식이다.)
사실상 f의 모델집합인셈이다. 그래서 f는 정규형식번호를 가진다.

이를 일반화하여, General-Myupair언어가 존재하는데,

이는 ℝⁿ의 일반화인 Hillberatrum처럼, 𝔹ⁿ의 일반화로 무한차원으로 취급한다.
단지... 내림차순으로 변수를 나열하기에, 변수가 하나 늘어날때 영향을 안미치니까, p-adic마냥 반복되는 문자열처럼 나온다.

---

논리회로의 디오판소스 다항식화 - HLLA 시스템 (HLLA : High(Normal Algebric)+Low(IC) Level ANF(Zhegalkin Polynoial) System) : 
 - xor(x, y) = x ⊕ y = x + y - 2xy
 - nand(x, y) = ¬(x ∧ y) = 1 - xy
 - 제공함수 (Func) = 실제회로 (Low) = 수학취급 (High)

다음과 같은 octet 타입
```cpp octetTypePsudocode
typedef struct {
    private union { struct { bool ris0 : 1; bool ris1 : 1; bool ris2 : 1; bool ris3 : 1; bool ris4 : 1; bool ris5 : 1; bool ris5 : 1; bool ris6 : 1; bool ris7 : 1 }; char v; };
    inline octet(char x) {
        this.v = v;
    } final;
    inline bool operator()(char x) {
        swich (x) {
            case 0 : return this.ris0;
            case 1 : return this.ris0;
            case 2 : return this.ris0;
            case 3 : return this.ris0;
            case 4 : return this.ris0;
            case 5 : return this.ris0;
            case 6 : return this.ris0;
            case 7 : return this.ris0;
            default : throw Exception("what the hell? well I can not help. this is fucking simple mathmatical type! why code like that burh, it must be ℤ/8ℤ's element!");
         };
    } final throwible;
} octet;

template <typename T, T L>
struct OctetArray {
    /**
        * # `OctetArray<typename T, T L>` type
        *
        * `::constOctetArray` is `const octet[L]` type.
        * the constructer `OctetArray<T, L>(OctetArray<T, L>::constOctetArray x)` is generate OcterArray as value as x
        *
        * accessment is as `OctetArray<T, L> x;`, `x[n](m)` is acess "8n + m"th index of bool. that means, OctetArray type object x is works as x = OctetArray<T, L>(constOctetArray v) s.t. xₙ(m) = v_{8n + m}
        * 
        *
        */
    using constOctetArray = const octet[L];
    public constOctetArray v;
    inline OctetArray(constOctetArray x) {
        this.v = x;
    } final;
    inline const octet& operator[](T idx) {
        return &this.v[idx % L];
    } final;
};

template <typename T>
constexpr struct ZoaOcterArray {
    /**
       * # metaclassic typegenerator holder ZOA (ZoaOcterArray) type document
       * 
       * - ZOA<T> (a.k.a. ZoaOcterArray<T>) type variable or type is "T-type Length type OcterArray gen" holder
       * 
       * `::gen<L>` mean `OctetArray<T, L>`
       *
       * so... as ZOA<T> var or type x, x::gen<L> mean OctetArray<T, L>
       *
       */
    template <T L>
    using gen = OctetArray<T, L>;
};

using ZOA = ZoaOcterArray;
```
에 대해, 어떤 추상적인 C++전산타입 T애 대해, 수학적 metaclassic typegenerator holder 타입 ZOA<T>에 대한 ::gen<> 연산자로써 만들어지는 함수로써, 수열에 대해 특수한 접근을 주는 수학적 객체를 생성하는 ZOA시스템으로 바이너리는 저장될 수 있다.

근데 사실 저건 저장용이고, 메모리를 존나 희생해서 numpy를 이용해서 처리할거다.

에초에 행렬같은 벡터 v로 쓸건데 왜 Vector2Arr(v)로 저장해야하나? (단. [Vector2Arr := λv.{∂v/∂{eᵢ}}ᵢ])

사실 에초에 저거 만든것도, 저 배열은 Vector2Arr(v)로 만든거고, 그러므로 인해서, 반복되는 순환마디를 구현하려는 목적이다.

전산과 수학 사이의 연결고리의 수학적 명세화.

General-Myupair는 증명•반증의 증명•계산을 다 할수 있는 종합 언어로, 자연적인 연역적 논리에 대한 수학적 분석으로 보는거다.

오로지 불가능한 경우만 제외하기때문에 Myu의 뜻은 Mute bY myU다.

전건부정하는개 안되니, 불가능한경우에 전건부정은 카운트하지 않는다.

한마디로, General-Myupair라는 수학적•기계적•언어적으로 동시애 해석가능한 언어의 구성이 쟁점이다.

 + 제갈킨 다항식은 이니까... 따라서, LFHS는 최종적으로 해석에서 군론을 도구로 쓰는거다. Alkalic + Zhegalkin + 

### HLLA FORM

HLLA FORM은 정규형이나 논리식의 형식에 관련된 논리-다항식 형식임.

각 형태는 "그 단순 형태"라고 지칭되는 경우, 단순하게 매우 깔끔한 형식으로 구성된다.

나머지 식의 형태는 KMAP이나 알고리즘으로 구성한다.

이게 HLLA위의 함수들로 정의되어 Lib로 제공되는 시스템이다.

{논리합, 논리곱, 부정, 괄호} 사용)

이때, "그 단순 형태"를 정규형식 번호에 대해 당연하고 깔끔히 나오는것으로 정의하겠음

전개식에 가까움)
SOP : 다항식같은 해석에서 곱-항들의 합
DNF : 완전히 전개된 SOP
PDNF (그 단순 형태) : minterm의 합 (DNF임), 
minterm (그 단순 형태) : 모든 변수에 부정을 하거나 말거나 해서 곱해서 만든 곱-항. 정규형식 번호의 한 참인 비트. 해당 상황시, 진리값배정에서 0이 되는 변수는 부정해주고, 아닌건 그냥 놔둬서 곱한다.

인수분해식에 가까움)
POS : 다항식같은 해석에서 합-인수들의 곱
CNF : 완전히 인수분해된 POS
PCNF (그 단순 형태) : maxterm의 곱 (CNF임)
maxterm (그 단순 형태) : 모든 변수에 부정을 하거나 말거나 해서 합해서 만든 합-항. 정규형식 번호의 한 거짓인 비트. 해당 상황시, 진리값배정에서 1이되는 변수는 부정해주고, 아닌건 그냥 놔둬서 곱한다.

## OHFE와 CRRS(CompletenessRuleRegisterSystem)

아니 약한 체계 A와 강한 체계 B가 있고, B는 A의상위호환일때, B가 `apop, apush, bpop, bpush, cpop, cpush, dpop, dpush, ruleApush, ruleApop, ruleBpush, ruleBpop, swapASswapreginf, SwapRegInfDiffCount, SwapRegInfBaseCount, SelectedRegIdCount, CancelPanic, CanclePanicMode, NotCanclePainic, NorCanclePanicMode, LoadTheoremInHere, CancelLoadTheoremInHere, DumpTheoremInHere, CancleDumpTheoremInHere, CheckIsTheorem, ..."등으로 스택 10개 레지스터 8개 그 래지스터에 대한 선택 카운터로 동작시키며, Select된곳에 현제 증명된 명제를 불러오는거지. 튜링 기계도 쓰고

=> 가능하다네;; 이름을 CompletenessRuleRegisterSystem이라 하겠음, 그리고 곧 탐구한 OHFE를 논법용 함수로 내장하겠음.

```
명제에 대한 조건제시법(혹은 원소나열)으로 쓴 명제들의 유한•무한집합 Φ_1, Φ_2에 대해 `Φ_1 ⊨ Φ_2`는 증명을 적고, 그것을 검증하는 체계가 항상 존재하나여?
 => 아뇨. 표현이 유한하지 않아서 검증이 안되는 경우가 생겨요, 특히 원소나열로 구성했다면 음.... 안되죠.

1계논리의 귀결관계는 논리도해나 진리표로 참이나 거짓임을 보일수 있나요?
 => 아니죠 ㅋㅋ, 그건 명제논리에서요.

아뇨 제말은 명제논리에서 원소나열법으로 된 명제의 유한집합 Φ에 대해 그것에 대해 논리도해를 그려 구한 유한집합 Θ를 구하는 알고리즘의 존재, 즉 논리도해를 작성하는 알고리즘이 존재하는지요
 => 네. 존나 오래걸려요, 근데 증명이 자동으로 가능해요.

정주희 저 수리논리와 집합론 입문에 나왔던 논리도해는 {A and B, B or C} ⊨ Φ 에서 Φ를 도출하는 식으로 작동하는 수형도방식이자, 형식증명마냥 번호로도 나열이 됬으며, 항진인 논리식 변환규칙 몇개랑 논리합에 대한 (수형도로 하는) 분기처리는 가지치기라는 이름으로, 다른건 쌓아놓기라 했는데요 이런 논리도해 말입니다.
 => 아주 잘 만들수 있습니다.

제가 보니까 명제논리 추론규칙에서 "자동 논리도해 생성"이나 "검증할 논리도해 나열"이나 "검증시 각 과정에 대한 논리적 귀결관계 설명 진리표 생성 및 총 진리표 생성을 인간이 하고 기계가 검증", "검증시 각 과정에 대한 논리적 귀결관계 설명 진리표 생성 및 총 진리표 생성"이라는 네가지 규칙을 만들수 있네요. 물론 인자로 파일을 주면 일 안하고 파일 받아먹겠죠. "자동 논리도해 생성"은 파일을 제시해서 생성대신 파일로 때운다면 "검증할 논리도해 나열"을 하고, "검증할 논리도해 나열"을 파일을 제시해서 검증 절차를  "검증시 각 과정에 대한 논리적 귀결관계 설명 진리표 생성 및 총 진리표 생성"을 해서, 각 과정을 검증하고, "검증시 각 과정에 대한 논리적 귀결관계 설명 진리표 생성 및 총 진리표 생성"이 제시됬다면, 진리표 검증을 하며, 그 과정이 사실상 "검증시 각 과정에 대한 논리적 귀결관계 설명 진리표 생성 및 총 진리표 생성하고 기계가 검증"이고, 그 기계가 검증하는 파트는, 기계가 알아서 노가다. 파일제시가 소용이 없어짐 ㅋㅋ

아 논리도해가 Semantic Tableaux라네요
피치(Fitch)증명은 자연 연역 (Natural Deduction)이라고 하구요.

그러면 걍 이름을 
```

"자동 논리도해 생성" : "Gen Semantic Tableaux with allow cachefiles"
"검증할 논리도해 나열" : "Start or End Semantic Tableaux with allow cachefiles"
"검증시 각 과정에 대한 논리적 귀결관계 설명 진리표 생성 및 총 진리표 생성을 인간이 하고 기계가 검증" : "Start or End Logic Tableau with allow cachefiles"
"검증시 각 과정에 대한 논리적 귀결관계 설명 진리표 생성 및 총 진리표 생성" : "Gen Logic Tableau with allow cachefiles"
로 하고 검증법은 "논리도해 자체 검증 로그", "논리도해에 대한 진리표 해설 검증", "진리표 검증"이렇게 새가지 검증 형식으로 두면 되겠제. 그러면 첨부하는 cachefiles 중에서 바이너리 파일 외에 논리도해 포함해서 네가지.

음... 이거 그러면 이걸 Haskell로 구현하고 그 함수가 제 기능을 하는건 Fitch에서 검증하며, 이름은 "Haskell Function Expension Package"라고 하고, HFEP형식의 증명은, Fitch증명들을 담은 Markdown에 수록되어, 논리도해 (Semantic Tableaux) 및 진리표 (Logic Tableau)와 같이 제공되어 자연 연역 (Natural Deduction)용으로 완성할수 있겠네 ㅋㅋ 물론 논리도해랑 진리표는 그 입출력이 명제논리로 구성되지. 그리고 진리표로 검증항꺼면 유보하는 "pass"를 이용해서, 논리도해가 아닌 진리표를 다이렉트로 이용하는걸 쓸수도 있게.

아, 그리고 "Over HFEP Fitch Extension" OHFE라고 명명해서, 귀결을 다이렉트로 진리표로 구성하는 키워드는 "form"으로 하도록 하지.
````

### [Angde Algebra](https://faraway6834.github.io/unbeauty/privateNote/Alkali/Forbidden/AngdeAlgebra)
```markdown
# 앙대-대수 (Angde-Algebra)

앙대-대수에 대해 설명할께...

앙대-대수는 결국 칼래(CaLE)로 평가되는데... 뭐... [CaLE](https://faraway6834.github.io/unbeauty/privateNote/Alkali/Forbidden/General_Myupair)에 대해 읽어봤으니 페스할께.

절대게임, 상대게임, 앙대게임을 만들어왔어

절대게임은 설명서에 목차가 다섯가지 있어

1. 해석
2. 정의
3. 표기
4. 규칙
5. 평가

해석부터 알려줄께!

"대괄호를 먼저 평가한다."가 전부야.

그러면 정의를 알려줄께. 근데 정의가 다섯가지야. DEF1, DEF2, DEF3, DEF4, DEF5가 있어.

DEF1 : 절대게임은 빈칸의 연속이다.
DEF2 : `O`는 `논리적 수용가능함`이다.
DEF3 : `X`는 그 반대다.
DEF4 : `→`는 추론이다.
DEF5 : 빈칸은 채울수 있는 칸이다.

이렇게 돼.

그렇지, 이제 표기를 알려줄께.
A번째 빈칸은 🄰라고 적고, `0️⃣→1️⃣→2️⃣`는 `0️⃣→[1️⃣→2️⃣]`를 적은거야.

규칙은 A, B, C 새가지가 있어.

A. `1️⃣ → 1️⃣`에는 동그라미 (O)를 위에 그려.
B. `O → X`에는 엑스 (X)를 위에 그려.
C. `0️⃣→1️⃣→2️⃣`애서, `1️⃣→2️⃣`와 `0️⃣→1️⃣→2️⃣`에 동그라미 쳐저 있다면, 0️⃣에 동그라미 치면, 2️⃣에 동그라미쳐.

이건 다음 문단인 평가를 알아야해.

평가 : 절대게임위에 O나 X로 절대게임에 대해 평가한것이야.

그럼 앙대게임이랑 상대게임에 대해서도 알려줘볼까?

앙대게임은 최종적으로 람다로 내부적으로 평가되는 게임이야.

`<>`안에 절대게임을 담으면, 튜플 `()`안에 인자로써, 절대게임들을 넣을수 있어.

튜플의 각 인자는, 순서대로, 번호가 메겨진 빈칸에 딱딱 채워져.

상대게임은, `Δ`가 등호의 역할을 하는 게임이야.

상대게임은 사실은 괭장히 불분명한 게임이야.

상대게임의 등호는 절대게임에서 말하는 평가가 되지만, 이걸로 수학을 구성할수 있기에 괴델 제 1 불완전성에 걸려, 즉, 튜링 언어에서 형식 언어로 넘어온거지.

아...? 독립적인 게임이냐고?

아... 상대게임은 앙데게임을 내장 (임베딩) 하고, 앙데게임은 절대게임을 내장 (임베딩) 해!

이 게임은 논리학 용도보다는 수학 용도야

함의, 의미론적 등호, 람다대수가 개임의 유일한 준비물이야.

오 탐구나 증명이 있냐고? 탁월한 질문이야!

절대게임에서 썼던 `→`심볼 있잖아!, 그것으로 연결된 튜플이 바로 형식증명이 돼.

즉, 라인 (line)이라는 이름으로, 숫자 번호 (`1. 2. 3.`)를 적고, 식을 나열하면, 그것은 상대게임 수준에서 형식증명을 작성하는게 되는 셈이지.

말 다했다~~ 끝.
```

### [JLPP](https://faraway6834.github.io/unbeauty/privateNote/Alkali/Forbidden/JLPP)
````markdown
# JLPP 소개. (팁 : 내가 건 [링크](https://faraway6834.github.io/unbeauty/privateNote/Alkali/Forbidden/LCPC4AI) 보고 볼것.)

[들어가기 앞서, 주의할점은 먼저 LCPC에 대해 알아야 한다는점이다!](https://faraway6834.github.io/unbeauty/privateNote/Alkali/Forbidden/LCPC4AI)

[자!, Lai는 "내 기준에서" 훌륭한 AI다.](https://faraway6834.github.io/unbeauty/privateNote/Alkali/Forbidden/LCPC4AI)

JLPP는 LLM (대화형•생성형 AI) 쳇봇 API와 [Lai-cgi-api](https://faraway6834.github.io/unbeauty/privateNote/Alkali/Forbidden/LCPC4AI)를 통하여,

jlpp라는 pip whl 페키지가 클라이언트로써, 중계를 담당하는, 쳇봇 이용 프로토콜이다.

## JLPF(Json Lai Prompt Format)
```json
{
   "Lai-cgi-prompt-chat" : true | false,
   "prompt" : 【문자열】
}
```

## JLPP (Json Lai Prompt Protocal)

Lai-cgi-prompt-chat : 사용자(인간)이 아닌 Lai-cgi-prompt모듈(Lai에 엑세스하는 웹 API)과 소통하는가? 에 대한 불 갑이다
prompt : 쳇 (소통) 내용 (프롬프트) 이다.

## Example 예시 : Chat GPT API를 통한 JLPP 교신 상상도.

사용자가 "LCPC 근황에 대해 알려줘"라고 했을때
```json
{
   "Lai-cgi-prompt-chat" : false,
   "prompt" : "LCPC 근황에 대해 알려줘"
}
```

GPT는 다음과 같이 lai를 호출한다.
```json
{
   "Lai-cgi-prompt-chat" : true,
   "prompt" : "xu la'e la LCPC cu zvati le nu banli se renro gi'e banli se renvi"
}
```

그럼 lai가 대답한다
```json
{
   "Lai-cgi-prompt-chat" : true,
   "prompt" : "so'o cukta cu se finti .i ji'a ro da na'e drata gi'e sruri fi le banli cmima be le fadni jgari be le ka fatci sruri la LCPC"
}
```
("「LCPC에 대한 탁월한 일반화•구조화」만 출간되었다."라는 뜻)

GPT는 별거 없음을 확인하고 더이상 lai에게 묻지 않고 사용자에게 답한다.
```json
{
  "Lai-cgi-prompt-chat": false,
  "prompt": "LCPC에 대한 탁월한 일반화·구조화만 출간되었습니다."
}
```

그럼 사용자는 다음을 받는다. "LCPC에 대한 탁월한 일반화·구조화만 출간되었습니다."

Lai에게 질문하킄 체이닝 과정은 워크플로로 details안에 `<summary> Ⓛ Researched </summary>`라고 상단에 써서 접어서 박힌다.
````

### scraped info

```plain/text
엥 이상향은 아니지만 실현가능한 합리적 방법으로써 현실적인 VelvetLCPC의 구현엔 칼레(CaLE)가 안쓰여요. 왜냐하면, LCPC 위에서 **정의**된거지 **그걸 구성하진 않거든요** (즉, 별개의 탐구분야)

---

General-Myupair ((칼레(CaLE)의 General-Myupair는 원인과 결과를 튜플로 표기하니까 문과 esolang 프로그래머 입장에서 직관적이다.))는 추론 과정에 대한, 즉 논리에 대한 탐구에 대해 정형화된 분석을 Alkalic을 통해, 제공한다. (HLLA FORM은 다항식을 이용한 논리식이라는 대수 구조에 대한 해석장치이기에, Alkalic으로 증명하기 용이하다.) 따라서, HLLA는 Alkalic에서 사용하기 용이하다. ((HLLA FORM은 수리논리를 어려워하는 대수학도 학생에게 직관적이다.))
CRRS의 OHFE는 Fitch52로 구성되는데, 이것이 Alkalic에서 검증으로 구성되기에, CRRS에서 큰 체계가 디폴트가 Alkalic이다.

칼레(CaLE)의 OHFE의 논리도해(Semantic Tableaux), 진리표(Logic Tableau)는 자당한 (=너무 당연히 왜 참인지를 잘 보여주는) 체계다.
또한 OHFE의 Fitch52는 건전한 자연연역 시스템으로 신뢰할만한 뿐만 아니라 심지어 설명도 잘하는 (=인간 언어와 유사한), 시스템으로 인간 이성과 유사한 "이성적인(rational)"체계이다.
또한 칼레(CaLE)의 CRRS는 건전한 추론 규칙은 이론상 추가하는데 한계가 없어, 추론을 함에, 추론 규칙의 갯수에 얽매여 고생할 필요가 없다
즉, CRRS는 인간 "이성적(rational)"이며 "자당한"탐구와 논리를 쉽게 다룰수 있으며, 추론 규칙의 갯수에 얽매여 고생할 필요가 없이 한계를 맛보지 않아도 되어서, "부족함이-커버되는", "좋은"체계이다. ((칼레(CaLE)의 OHFE는 논리도해 (Semantic Tableaux)가 충분히 진리표 (Logic Tableau)로 항시 설명되고, 진리표가 직관적이고, Fitch52가 인간 기준 이성적이고 합리적이므로, Fitch52가 상대적으로 어렵지만, OHFE는 전반적으로 거의 누구나 이해할수 있을 만하게 쉽다.))

Alkalic위에서 정의된다.

분명히 의심의 여지 없는 검증으로써 HLLE 계산((General-Myupair외에는 차가운 대수로 설명되는데, General-Myupair는 거기서 살짝 비튼거라))과 OHFE 논설((논리에 대한 따뜻한 설명으로 OHFE는 제가 어릴때 (3년전)부터 구상했던 인간-이성적인 추론-체계여서 논법용으로 추가했다.)) 그리고 탐구 규칙에 얽메이자 않지만 분명한 탐구도 분명히 내 지향점이었지. 왜냐하면, 규칙이 인간을 얽메는건 기계어나 하는 짓거리라 봤다.. 추론 규칙은 권위적으로 받느는 대상이 아니라 본거다.

곧 기하학을 통해 Alkalic을 서술하고 Alkalic에서 기하를 서술하는 시스템을 구성해서 무한히 중첩 가능한 체계로, 대수도 인간 지성으로 환원할것이다. 수학의 본질은 "본질적으로 결국근 보존개념을 다루는 함수"이다.
```

## [Language and Math](https://faraway6834.github.io/unbeauty/privateNote/MAD/Language_And_Math)

````markdown
# Language And Math

(총 692 line 14312 자)

목차:
 - 수학과 언어
 - 수란 무엇인가
 - 의외성 정리

## 수학과 언어

수, 수사 등은 크기 개념이다. 이러한 크기 개념은 곧 설명할 일개 사고방식에 불과하며, 이러한 수에대한 설명의 형식적 방언이 수학이다.
그러나 언어는 근본적인것들이 아니다.

시작해보자.

언어에 대한 해부를.

# 수란 무엇인가

(총 534 line 11828 자)

이야기 하기 앞서, 말하고자 한다.

나는 이 주제에 대하여, 수는 수학적으로 정의되는 추상적 대상이며, 형이상학적인 허상 취급을 했었다

아래는 그 글이다

```
# 주장

(총 422 line)

## 목차

 - 전제
 - 전제에 따른 함의
 - 1. 픽토그램(pictgram)에서 보존 개념(conservation)이 불필요한 이유
 - 2. 수라는 수학에서 추상적 보존 개념 (conservation)의 핵심적인 부분이 왜 형식적 논리인 수학으로 작성되어야 하는가
 - 결론

## 전제

우리는 외부새상을 감각으로밖에 인지할수밖에 없기에, 내부 새상(본인의 생각의 언어 L을 가정하고 L이 작동하는 본인)은 와부새상에 대해 귀납적인 추론밖에 할 수 없다.

## 전제에 따른 함의
그런 외부 새상에서 일관됨을 연역적으로 보일 방법은 존재하지 않으며, 따라서, 외부 새상이 형식적인 논리로 서술되는지도 연역적으로 합리화할 방법이 없다.

## 1. 픽토크램(pictgram)에서 보존 개념(conservation)이 불필요한 이유

---

---

### 첫번째 글 : 보존개념

목차
1. Defination of Unary
2. PlasticArrow
3. 시각 감각 언어 `L`을 가정하자.

#### Unary and PlasticArrow

##### Defination of Unary

표기 Unary ≡ [UnarySystem := λF. [Char := λx. "x is charactor"][
String := λx. x ∈ {c | Char(c)}ᵗ [t := |x|]
][
F := λn:ℕ₀.λx:Char. ∀y (단. y ∈ {S}ⁿ)
][x ← y := z (단. z → y = x)
][x↓ᵏ y := z (단. z ↑ᵏ y = x)
][ℙ₁ := ︷
∀String(x), "x is string"
Fₙ ≡ F(n)
x▪︎y ≡ \stackrel{x}{y}
「x」≡▪︎x
『x』₁ ≡ x
『x』₍ₙ₊₁₎ ≡ x『x』ₙ
▴「Fₙ(x)」 ≡ F(n⁺)(x)
▾「Fₙ(x))」≡ F(n⁻)(x)
Fₘ(x)『「▴」』₁「Fₙ(x)」 ≡ F₍ₙ₊ₘ₎(x)
Fₘ(x)『「▾」』₁「Fₙ(x)」 ≡ F₍ₙ₋ₘ₎(x)
Fₘ(x)『「▴」』₂「Fₙ(x)」 ≡ F₍ₙₘ₎(x)
Fₘ(x)『「▾」』₂「Fₙ(x)」 ≡ F(n÷m)(x)
Fₘ(x)『「▴」』₃「Fₙ(x)」 ≡ F(nᵐ)(x)
Fₘ(x)『「▾」』₃「Fₙ(x)」 ≡ F(ᵐ√n)(x)
Fₘ(x)『「▴」』₄「Fₙ(x)」 ≡ F(ᵐn)(x)
Fₘ(x)『「▾」』₄「Fₙ(x)」 ≡ F(super-rootₘ(n))(x)
Fₘ(x)『「▴」』₍₂₊ₖ₎「Fₙ(x)」 ≡ F(n ↑ᵏ m)(x)
Fₘ(x)『「▾」』₍₂₊ₖ₎「Fₙ(x)」 ≡ F(n ↓ᵏ m)(x)
x ▲ y ≡ y『「▴」』₁「x」
x ▼ y ≡ y『「▾」』₁「x」
x ▶ y ≡ y『「▴」』₂「x」
x ◀ y ≡ y『「▾」』₂「x」
Fₘ(x) ↑ᵏ Fₙ(x) ≡ Fₘ(x)『「▴」』₍₂₊ₖ₎「Fₙ(x)」
Fₘ(x) ↓ᵏ Fₙ(x) ≡ Fₘ(x)『「▾」』₍₂₊ₖ₎「Fₙ(x)」
Fₘ(x) → Fₙ(x) ≡ F(n → m)(x)
Fₘ(x) ← Fₙ(x) ≡ F(n ← m)(x)
︸]]

---

사용법 : 

> `(∃UnarySystem(F) s.t. ⊢ ℙ₁)( ⊢ T)`

ℙ₁은 "†문자열은 문자의 튜플이고, ‡아래 구문론적 등호가 성립한다"는 뜻이기에, ℙ₁이 참일때, †문자열을 문자의 튜플로 정의하고, ‡제시한 구문론적 등호를 받아들이며,  ℙ₁이 거짓일때, †문자열을 문자의 튜플로 정의하지 않고, ‡제시한 구문론적 등호를 받아들이지 않는것이다.

즉 문자열의 정의와 표기법을 허용하면 참, 그러지 아니하면 거짓이지. 따라서, `s.t. ⊢ ℙ₁`이라고 하면, F에 대해, ℙ₁이 참이라고 강제하는 뜻인것이다.

###### 상수 "PlasticArrow" 정의

ℝ²나 ℝ³범위에서 다음을 정의한다

> 
> **Plastic Arrow**
> 
>  - `⮕`는 벡터공간 `𝕍 = ℕ₀¹`에서의 "기저벡터"
> 
> 참고로 Unary에서 표현하는 수는 `⮕`가 선형생성하늨 벡터공간의 스칼라이다.
> 
> **Padic Plastic Arrow**
> 
>  - `⇨`는 초실수체 벡터공간 `𝕍 = ℚ¹`에서의 "기저벡터"
> 
> **Standard Plastic Arrow**
>
>  - `➡️`는 벡터공간 `𝕍 = ℝ¹`에서의 "기저벡터"
> 

이는 유클리드 기하학에서 직선 l과 그 위의 점 O, X, P에 대해,
O를 원점으로 잡고, 반직선인, 시초선 OX, 동경 OP의 X, P를 좌표 혹은 벡터로 보는 방식으로도 유클리드 기하학에서 재서술할수 있다.

---

번외 : 실현?

> 
> 물론 현실에 저런것들을 만들려면 「플라스틱-화살표 교구」에 "단면"이 존재해야하는게 함정이다.
> 
> 그러나 "플라스틱 화살표 교구의 단면"은 "폐곡선의 방정식" `F(x, y) = 0`으로 표현하면 된다. (따라서, "플라스틱 화살표 교구의 단면의 폐곡선의 방정식 음함수 표현 F"가 존재한다.)
> 
> ---
> 
> "실현" ㅋㅋㅋㅋ... 개연성도 없거니나와, 웃긴다. ㅋㅋ
> 

####### 시각 감각 언어 `L`을 가정하자.

######## 정의

L은 pictogram 언어이다.
단순히 pictogram을 나열한다.

######### 센다는 것(算)은 pictogram을 새는것으로 정의된다.

수를 세는 함자 "산자 System"를 정의하겠다.

> `算子システム ≡ [算 := λx. RF(x)⁻¹ [R := λf.λx.λy.fyx]] (단. (∃UnarySystem(F) s.t. ⊢ ℙ₁)( ⊢ T))`

그러면,

`算(□) (算子システム)`는 **변항 □에 들어갈 pictogram을 새는 함자이다.**

> ex) `算("⮕")("⮕⮕⮕⮕⮕") = 5 (算子システム)`

이때 저 pictogram문장은, 수학언어에서 접근한것이기에, 그냥 문자열 해석이다.

문법 번역식 교수법마냥, 픽토그램을 픽토그램이 아닌 문자열로 해석했기 때문에,

이는 쐐기문으로 쓰여있는 고대 메소포타미아 문명의 언어 글자를, 숫자로 취급하는것과 같은셈이다.

따라서, pictogram과는 무관하게, 수학이 이것에 의미를 부여한 것이다.

사실 pictogram외에도 걍 문자열이면 다 셈 함수의 정의역이므로, 셈은 우리로 하여금 새상이 수로 해석될수 있다고 귀납적 추론에만 근거한 주장을 펼치게 한다.

---

---

보존 개념 (conservation)은 귀납적으로 증명되었지만, 연역적으로는 그 자체를 가정할때, 형식적 논리인 수학을 요구하기에, "증명되지 못한 (말할수 없는)것" 이며, 전조작기가 지나고, 구체적 조작기에 들어서 후천적으로 얻는, 보편적인 개념이다.

conservation을 놓고 생각해보자. 

> `🍑🍍🍍🍊🍓`라는 pictgram이 있다.

해당 픽토그램이

> `🍑🍍🍊🍓`

로 바꿔도 무방하다.

따라서, pictgram은 conservation을 요구하지 않는다.

따라서, pictogram새상에서도 conservation을 합리화할 방법은 존재하지 않는다.

따라서, 외부 새상이 pictogram으로 인식되어도, conservation을 합리화할 방법은 존재하지 않는다.

### 수라는 보편적 개념이 얼마나 보편적인 지성적인 개념일까

수에 대한 이해(「"수학적 관점에서, 외부 새상의 대상의 양이 셈으로 해석된다"는 결과를, "셈이 근본이다"라는 확대해석 • 합리화」한것이 수이다)를 보면, 수는 언어적으로 만들어진 요소이므로, 이해하지 못할수도 있다.

이러한 측면에서, 난산증은 엄청나게 보편적인 언어적 가정인 수를 이해하지 못하는 장애라고 볼수 있겠다.

Charactor/Text(String)은 Language의 Symbolization(심볼화)이며,
Symbol(기호)은 특정한 의미를 가지도록 약속된 도형(圖形)이다

그리고 이것은 정말로 엄청나게 보편적인 개념인데,

이러한 측면에서, 난독증은 엄청나게 보편적인 인간이 창조한 개념인 문자를 이해하지 못하는 장애라고 볼수 있겠다.

마지막으로, 자폐증의 경우 템플 그랜딘이 말했듯, 자폐증 내부의 언어는 그림일수도 있다.

작성자 본인도 자폐증이긴 하다 (나는 내가 자폐증이여서 자폐를 싫어하긴 하니 자폐를 변호하는게 아니지만) 자폐증의 경우, 언어를 본인 맘대로 해석하는 경항을 띄는 사람이 있다 (예시 : 본인)

언어는 그 본질이 기존의 뜻으로 결정되지 않고, 필연적으로 의외성을 수반해여만 한다.

즉 일상 언어의 본질은 인간 사고 기저에 있는 의외성과 통념(정확히는 개념에 가깝다. 예를들어, 눈을 찡그린 사람은 화난것)에 있다.

이러한 의외성은,

> 
> 인간이 보편적으로 가지는 태생적인 지능에 따른, 언어의 지능적 의외성과
> 인간이 기본적으로 가지는 통념(개념; 예를 들어 "뿌린대로 거둔다"는 하는데로 돌아온다는 뜻이라는거, 그 의외성의 핵심 개념)에 따른 언어의 통념적 의외성이 있을것이다.
> 

따라서, 인간이 사고의 근본인 언어에 있어서, 본질적인 부분에 대한 엄청난 이해 결함을 가진 장애인으로, 일부 자폐성 장애인 (예시 : 초등학생때 본인)이 있을것이다.

이러한 관점에서, 난산증에게 결핍된 능력은, 보편적인 수에 대한 개념이라고 볼 수 있다.

이러한 수 개념은 수에 대한 어느정도의 이해를 필요로 하므로,

수에 대한 보편적인 지능과 이해능력은, 난산증을 제외한 인간이 매우 발달한것일 뿐, 본질적인것이 아니라고 볼수 있다.

정상인은 에초애 많은 부분에서 선천적인 지능이 있다.

그걸 없는걸 장애라고 하고, 솔찍히 그런 당연한거를 모르니까 약간 역겨운 감도 있다.

### 과학을 가져오는것에 대한 반론

과학(자연과학, 사화과학, 형식과학 등)과 같이 귀납적으로 증명된 대상들은 지금 이 연역적인 논의에서, 귀납적이지만 연역적이지 않다고 반박하니, 과학을 예시로 반박하면 안될것이다.

그렇게 되면 새상이 과학적으로 이루어졌다는 가정으로 수학을 증명하고 다시 과학을 증명하는 순환 논증에 빠질것이고, 이러한 방식으로, 새상이 과학으로 이루어졌다는 전제로, 과학의 탐구 방식이나 수학을 합리화 하는 즉시, 그것은 수학에서 금한 자기참조를 범하는것이다 (따라서, bootstraping같은 과정은, 자기참조를 범하는 합리화이므로, 연역논증이랑은 거리가 멀다 (inference to the best explanation라고 하는것도 이해가 안된다))

또한 과학은 수학을 수반하지 않아야 될 수도 있다.

만약 과학에서 수학을 쓸수 없다는게 증명됐다고 가정하자,

그러면 과학은 수학을 사용해야 한다는 가정이 깨지므로,

페러다임 시프트가 일어날 것이다.

과학이 수학을 사용해야한다는 가정은, 과학이 형식논리를 이용해야한다는 가정과 동등한 뜻이다.

그런데 과학이 형식논리를 이용해야한다는 가정은, 해당 과학이 일관된 형식적 논리로 서술될수 있다는 가정이므로, 해당 가정이 성립하기 위해서는, 논리를 사용하기 위한 규칙 (공리계, 언어, 표기 등)과 과학이 일관된 대상을 탐구해야한다는 가정을 가지게 되므로, 공리계를 사용할수 있다는 근거와 탐구하는 대상이 과학적이라는 근거가 있어야만, 연역적으로 뒷받침될수 있다.

## 2. 수라는 수학에서 추상적 보존 개념 (conservation)의 핵심적인 부분이 왜 형식적 논리인 수학으로 작성되어야 하는가

---

---

### 두번째 글 : 논리적으로 다룬다 전재할때, 대수식은 논리적으로 그 뜻이 해석 • 계산된다.

그렇지 아니하면, 논리적 해석 흐름에서 논리기호가 도출될수가 없다.

식의 계산은 그 값의 배정인 (x̄, f(x̄))와 같이 이루어지는데, 이 방식을 거부하는것은, 논리를 쓰지 않겠다는 말과 같다. (장자 왈 갓나서 죽은 아기보다 오래 산 사람은 없으니 팽조(760살이 넘게 살았다는 전설 상의 신선)도 일찍 요절한 사람)

#### 다음 과정을 위해 이항을 먼저 증명하겠음

함수는 (다가함수 고려하지 않음)

> 정의역의 x에 대해, `∀x ∃!f(x)`이다

먼저, y랑 z을 정의하자.
 - y = f(x)
 - z = f(k)

[*작성중*]

#### 대수식의 논리적 해석 흐름에서 논리기호를 도출하자

먼저, 다음을 보이겠다

> 함자 `f :≜ (-F)` 를 정의해서, 여기에 대해,

`x = y 이면이 f(x) = f(y)`

이말은, 진리값 T, F를 다루는 식에서, F = 0으로 가정하고 푸는거나, F ≠ 0이 아닐때 푸는거나, 전부 x = y인 등식을 쓸때 f(x) = f(y)가 F와 무관히 동등함이 당연함으로, F = 0인 경우로 잠정적으로 취급하겠음

##### 대수식의 논리적 해석 흐름중 논리적 귀결관계의 도출

Step.1. 방정식을 만족하는 집합으로써의 모델집합이 해집합임을 보이자

먼저, 다음과 같은 다항식 함수 P를 정의하자.

> `P :≜ λA. λx. Πᵢ x - Aᵢ`

그리고 다음과 같은 방정식화 논리함수 Φ를 정의하자.

> `Φ :≜ λf. (f(x) = 0)`

그리고 마지막으로, 다항 방정식 ㅍ을 정의하겠다.

> `ㅍ :≜ φ • P`

그러면,

> `Mod(ㅍ(A)) = {x | x ⊨ (Πᵢ x - Aᵢ = 0)} = {x̄ | Πᵢ x̄ - Aᵢ = 0} = {Aᵢ | ∀i}`

임이 당연하다.

---

Step.2. 논리적 귀결관계의 도출

다항방정식 ㅍ(A), ㅍ(B)에 대해,

0. Mod(ㅍ(A)) ⊆ Mod(ㅍ(B))
1. {Aᵢ | ∀i} ⊆ {Bᵢ | ∀i}
2. ∀i Aᵢ = Bᵢ《주의 : 비약이다, 저건 배열을 정렬해야만 성립한다.》
3. ∃C P(B) = P(A)P(C)
4. P(A)|P(B)

으로,

> 
> 다항식 f, g에 대해 다항방정식 Φ(f) ⊨ Φ(g)
> 
> 이면이
> 
> f | g
>


##### 대수식의 논리적 해석 흐름중 진리값 배정되는 명제논리 결합자의 도출

¬x = T - x로 해석됨을 보이자. (경고 : 형식증명 아님)
A. proof of `x ≠ T ⊢ T ± x ≠ (1 ± 1)T`
0. `x ≠ T` (비 귀류법식 전제 문장)
1. `T ± x ≠ T ± T` (이항 by 함자 `(T ±)`)
2. `T ± x ≠ T ± T = (1 ± 1)T` (1번의 연장선에서 계산)
3. `T ± x ≠ (1 ± 1)T` (2번에서 식 요약) ⋯ ■

B. proof of `⊭ (1 + 1)T = 0 ∨ (1 + 1)T = T`
0. 먼저 part A by `⊭ (1 + 1)T = 0`와 part B bt `⊭ (1 + 1)T = T`로 나눠서 생각하자.
1.A. (1 + 1)T = 0 (귀류법식 전재 문장)
2.A. (1 + 1)T = 2T = 0 (1.A.번의 연장선에서 계산)
3.A. T = 0 ⊨ 2.A. ⊨ (1 + 1)T = 0 (연역)
4.A. ⊭ T = 0 ⊨ 2.A. ⊨ (1 + 1)T = 0 (연역)
5.A. ⊭ (1 + 1)T = 0 (연역) ⋯ ⊥
6.A. ∴ ⊭ (1 + 1)T = 0 (연역) ⋯ ■
1.B. (1 + 1)T = T (귀류법식 전재 문장)
2.B. (1 + 1)T = 2T = T (1.B.번의 연장선에서 계산)
3.B. T = 0 ⊨ 2.A. ⊨ (1 + 1)T = T (연역)
4.B. ⊭ T = 0 ⊨ 2.A. ⊨ (1 + 1)T = T (연역)
5.B. ⊭ (1 + 1)T = T (연역) ⋯ ⊥
6.B. ∴ ⊭ (1 + 1)T = T (연역) ⋯ ■

C.1. A, B ⊨ (x ≠ T ⊢ T - x ≠ (1 - 1)T) (A, B번에서 귀결)
C.2. A, B ⊨ (x ≠ T ⊢ T - x ≠ (1 - 1)T = 0T = 0) (C.1.번의 연장선에서 계산)
C.3. A, B ⊨ (x ≠ T ⊢ T - x ≠ 0)  (C.2.번에서 식 요약)
C.4. A, B ⊨ (T - x = 0 ⊨ x = T ⊨ x) (C.3.번에서 연역추론 : 대우) 《주의 : "x = T"의 의미를 "진리값 x가 참"관점으로 해석함.》
C.5. A, B ⊨ (T - x = 0 ⊨ x) (C.4.번에서 식 요약) 《주의 : 근거인 C.4.에서 "x = T"의 의미를 "진리값 x가 참"관점으로 해석함.》
C.6. C.5.번 내용 ⊢ ¬x = T - x (최종결론)《주의 : "x = T"의 의미를 "진리값 x가 참"관점으로 해석함.》
Q.E.D.

x ∧ y는 xy로 해석됨을 보이자.
T에대한 방정식 (T - x)(T - y) = 0의 해는
x = T ∨ y = T이다.
따라서, x = T ∨ y = T ⊨ T - (T - x)(T - y) = T고,
x ∨ y = T - (T - x)(T - y)로 해석된다.

이때 De Morgan's Law, ¬(¬x ∨ ¬y) = x ∧ y서

T - T + (T - T + x)(T - T + y)
 = xy이다.
 ⋯ Done.

##### 방정식의 의미 : 술어논리(함수논리)의 술어로써, 잠정적으로 특칭양화사를 사용해, 잠재적으로 전칭양화사를 사용함.

방정식 P(x) = 0이 불능이란것은

∄P(x) = 0란 뜻이며

∀P(x) ≠ 0이란 뜻이고 ⋯ ①



방정식 P(x) = 0가 불능이 아니라면

∃P(x) = 0이다. ⋯ ②



방정식 P(x) = 0이 부정이란것은,

부정방정식이므로,

∀P(x) = 0이다. ⋯ ③



①에서, 불능형 방정식 P(x) = 0에 대해,

P(x) ≠ 0은 부정형이고, ⋯ ④



부정형 방정식 P(x) = 0에 대해,

P(x) ≠ 0은 불능형이다 ⋯ ⑤


그렇다면 ③에 따라 다음을 정의하자,

> `Φ :≜ λf. (∃f(x) = 0)`
> 
> `P :≜ λf. (∃f(x) ≠ 0)

그러면 다음을 알수 있다.

④에 따라, Φ(f)가 거짓 이면이 P(f)는 부정형
⑤에 따라, Φ(f)가 부정형 이면이 P(f)는 거짓

Φ(f)가 참 이면이, f(x) = 0를 만족시키는 x존재
P(f)가 참 이면이, f(x) = 0을 불만족시키는 x존재

부정형 방정식을 만들고 싶다? 하면

¬Φ(f) = P(f), Φ(x) = ¬P(f)에서,

불능형 방정식 Φ(f)에 대해 부정하거나,
불능형 방정식 P(f)에 대해 부정하면된다.

술어 P에 대해
Mod(P) = ∅ 이면이 ∄P(x) 이면이 ⊭ P
이면이
Mod(¬P) = U 이면이 ∀¬P(x) 이면이 ⊨ ¬P

따라서, 방정식은 기본적으로 특칭 술어로써, 사용할수 있음

---

---

따라서, 수학에서 말하는 "추상적 보존 개념 (conservation)의 핵심으로써의 수"는 수학 없이 독자적으로 성립할수 없다. (단. 언어에서 수사같은 거나 숫자같은거는 수학적으로 해석하는것이 아니기에 본인은 수로 취급하지 않았다. 언어에서는 수에 의외성을 가지고 해석할수 있기에, **실제로 일관되지 않는다**; 시에서 갑자기 하나가 두개가 될수 있다.)

## 결론

따라서, 픽토그램으로 우리가 새상을 받아들인다 쳐도, 픽토그램 새상에서도 수, 수학, 보존개념은 요구되지 않으며, 해당 개념들은 언어를 통한 부가적인 개념일 뿐이지, 비물질적 실체가 아니다.
```
이 글은 틀렸다.

해당 픽토그램을 해석함에 있어서, 우리는 기저에 깔린 지식을 이용하여 그 갯수를 알수 있다.

선험적이거나 경험적이거나 언어적이거나 본능적인것 아니냐는 질문에 틀렸다고 반박했다고 볼수 없는 글이다.

## Step 1. 생각의 선행

생각은 내용을 가진다, 여기서 생각은 그냥 직설적인 생각이며, 내용은 상자안의 내용물 같지만 추상적이라 설명할수 없다. 나는 그 내용이 글이라고 한적이 없다. 내용은 내용이며 그 내용이 무엇인지 우리는 말할수 없다.

생각의 다음 생각에 대해서도 단정하면 안된다. 생각의 다음 생각이 어떻게 되는건지 우린 모른다.

그러나 우리는 생각하려한다, 스스로 정신적인 방법으로 식물인간이 되고자 하지 않는다, 물론 의식적으로 "나는 정신적인 방법으로 식물인간이 될거야"라고 생각한다면 생각이다.

인간이 고등하다는 말에 속뜻, 그 생각을 버리자.

말의 속뜻중 의심되는건 일단 다 버리고 들어보라.

생각 다음 생각을 정해보는것, 생각을 전파하는것, 생각을 당연한 생각 다음 생각 방식으로, 나의 기본적인 능력으로 이해하는것, 그리고 외부에서 기인한 일로 생각이 추가되는것. 이러한 것을, "개척"/"전파"/"이용"/"추가"라고 하며, 우리 생각이 이러한 특성을 가진다는것이 공리이다.

여기에서 추가는 유일하게 능동적으로 하는게 불가능하다. (요청하는것도 수동적으로 받아들이게 해달라는거니)

그리고 전파는 생각을 공유하는거다. 전파를 받는거는 모른다.

그러나 이용하는것은, 당연한 생각 다음 생각을 이용한다. 이러한 당연한 생각 다음 생각으로 능력을 말위하는걸 잠재 능력이라 하여, 재능이라 한다.

우리는 대부분, 언어에 대한 재능으로 언어를 습득할 능력을 가지고 있고, 크기를 습득할 능력을 가지고 있다.

이것들은 재능인 경우가 대부분이지만 특수한 경우를 보자면 아니다.

언어와 크기는 습득하니까, 생각이다.

언어와 크기가 전파되었으니 말이다.




사실 크기같은 경우에는 전파해준 사람 없이도 사물에서 기인하여 나오기도 한다.

어떻게 된지는 몰라도 이미 존재한거고, 우리는 그것우로 생각하며 우리는 그것에 대한 관점화된 틀을 벗을수 없는 부분이 있다.




이러한 벗을수 없는 "단단한 틀"이 있다. (예시 : 윤석열 하면 계엄이 떠오른다... 농담ㅋㅋ 이런건 예시로 적절치 않군 ㅋㅋ)




이러한 개념들이 이용을 통해서 추가되는경우가 매우 많다.

특히 살아남기 위해 필요하면 더더욱.
우리는 생각하려는 의지를 가지며, 언어와 크기는 그것의 대표격이다.

그러한 능력이 선천적인 필수 루트가 아닌 이유는, 그렇지 않은 예외경우가 존재하기 때문이다.


내가 본 대부분은 언어습득능력이나 크기습득능력을 생습적 재능으로 가진다.

그러나, 이러한것은 생각흐름을 탁! 바꿀수 있거나 그 생각흐름을 주는 경우들이 많으며,

이러한 "기저에 깔린" 생각들은 생각이지 인간의 필수 능력이 아니다.

생각이 선행한다.

## Step 2. 크기 개념

크기 개념을 생각하는것은 대부분 된다.
생각하지 못했다 해서 난산증을 차별할 근거가 되지 않는다는것도 당연하다.



정량화된 크기 개념이 수(數)이며, 수학 언어는 수를 다루는 언어이다.

그런데, 수학 언어는 형식 언어로 설명된다.

따라서, 크기 개념이나 수학을 다룸에 있어서, 크기나 수학에 기초한 서술을 접근할수 없는 사람이 있음은 매우 당연하다.



언어 혹은 수(數)나 수학적 서술이나 크기 개념은 우리가 생각할수 있도록 익혀진 상태일때야 사용 가능한 것이지, 재능이 아닌 이상 생습적이지 않다.



한 문장으로 정리하겠다.



다른 관점 말고, 생각하는 관점에 있어서,
언어나 수, 수학적 서술과 크기는, 우리가 생각하는 것에 있어서 생각이며, 재능으로 타고나지 않으면 본능이 아니다.



이걸 얼마나 더 쉽게 설명해야 할지 모르겠다.



재능이라거나 이런말보다는 생존을 위한 (사자들에게도 크기 개념은 있음) 생각, 사념체일 뿐.

이상.

# 의외성 정리

## 용어 정의

 - True Mean (참뜻) : 의외성(속뜻)
 - Shell Mean (껍대기 뜻; 쉘 민) : 겉뜻
 - 속뜻 없음 (Exceptless) : Shell Mean = True Mean
 - 초완전성 (Hyper-Completeness) : "This sentence is False"를 허용하는것.
 - Black and White Proposol : ⊢ (¬Hyper-Completeness)
 - Simply Mean Proposol : ⊢ Exceptless
 - 단순언어 : Simply Mean Proposol이 항진인 언어

### 흑백논리와 형식언어의 정체에 대한 고찰

Black and White Proposol를 공리로 하는 논리를 흑백논리라고 부를수 있음이 당연하다

또한 흑백논리중 단순언어인것이 형식언어인것이라도 보면 된다.

#### 정리 문단에 따른 보조설명

우리 언어는 보이는대로 해석해야하는것과 아닌것이 있어,

보이는대로 해석해야하는것을 단순언어 (이 경우 언어 해석에 예외가 없이 보이는대로 닥치고 그뜻이다)

그리고 단순 언어가 아닌 언어 (이 경우, 언어 해석에 여러 의외성이 끼어들기에, 단순히 보이는 뜻을 뜻으로 단정할수 없다)가 있다

또한 논리는 장자철학처럼 "갓나서 죽은 아기보다 오래 산 사람은 없으니 팽조(760살이 넘게 살았다는 전설 상의 신선)도 일찍 요절한 사람이다"가 맞을수 도 있지만,

흑백논리에서는, Black and White Proposol을 참으로 하여, x이면서 동시에 x가 아닌것은 불가능하다. (Fun Fact : 흑백논리이면 단순언어임이 논리적 귀결이다)

## 공리

1. 말의 뜻은 True Mean과 Shell Mean이 있다

## 정리

### TrueMean Theroem

Hyper-Completeness 일때도 "말의 뜻 ≠ True Mean"마저 True Mean으로 True Mean(결국 전제로 한 참인 문장에서 연역(이때는 초완전땜에 가능)으로 "말의 뜻 = True Mean")이고 (Hyper-TrueMean Lemma)

Hyper-Completeness 가 아닐때도, "말의 뜻 = True Mean"이므로, 말의 뜻 = True Mean으로 (Formal-TrueMean Lemma)

말의 뜻은 True Mean을 말한다. (TrueMean Theroem)

A. Formal-TrueMean Lemma
 - ¬Hyper-Completeness, ⊭ 말의 뜻 ≠ True Mean ⊢ 말의 뜻 = True Mean

B. Hyper-TrueMean Lemma
 - Hyper-Completeness, 말의 뜻 ≠ True Mean ⊢ 말의 뜻 = True Mean

C. TrueMean Theroem
 - 말의 뜻 = True Mean

Proof)

1. 말의 뜻 ≠ True Mean [Hyp]
2. Hyper-Completeness [Hyp]
3. "말의 뜻 ≠ True Mean"라는 점도 True Mean임
[Paradoxic Lemma]
3. "말의 뜻 ≠ True Mean"라는 점도 True Mean이고 참이기에, 말의 뜻 = True Mean임
4. 말의 뜻 = True Mean

이하에서,

말의 뜻 ≠ True Mean, Hyper-Completeness ⊢ 말의 뜻 = True Mean ⋯ (1)

1. 말의 뜻 ≠ True Mean [Hyp]
2. ¬Hyper-Completeness [Hyp]
3. "말의 뜻 ≠ True Mean"라는 점도 True Mean임 [Paradoxic Lemma]
4. 모순

이하에서, ⊭ 말의 뜻 ≠ True Mean ⊢ 말의 뜻 = True Mean

(1), (2) ⊢ 말의 뜻 = True Mean

Q.E.D.

#### 해설

항상 True Mean만 말의 뜻임을 증명하자,

True Mean이 뜻이 아닌 말이 있다고 가정하자,
그렇다면 그 말은 True Mean이 뜻이 아니라는 뜻이 True Mean이 된다

이것이 Paradoxic Lemma다

이하에서 Hyper-Completeness에 따라 참인 경우와 거짓인 경우로 나누어 논증하자.



상황 1. Paradoxic Lemma에서, Hyper-Completeness인 상황

Paradoxic Lemma가 참이될수 있으므로, Hyper-TrueMean Lemma가 참이다

상황 1 종료



상황 2. Paradoxic Lemma에서, 비 Hyper-Completeness인 상황

Paradoxic Lemma이 모순이므로, 전재인 "말의 뜻 ≠ True Mean"이 거짓이다.

따라서, Formal-TrueMean Lemma가 참이다

상황 2 종료



이하에서,

상황 1, 상황2에 따라, 연역,
항상 True Mean이 말의 뜻이 된다.

따라서, TrueMean Theroem이 참이다

Q.E.D.

### Exceptless Thorem

Exceptless ⊢ 말의 뜻 = Shell Mean

Proof)

1. Exceptless [Hyp]
2. 말의 뜻 = True Mean [TrueMean Theroem]
3. Shell Mean = True Mean
4. 말의 뜻 = Shell Mean [결론]

이하에서, `Exceptless ⊢ 말의 뜻 = Shell Mean`임이 당연하다.

#### 해설

앞서 증명한 TrueMean Theroem에 따라,

말의 뜻 = True Mean

Shell Mean = True Mean 이면, 그리고 이때만 Shell Mean = True Mean이다

(쉽게말해 A = B = C니 A = C)
````

## [앙데_대수_해명](https://faraway6834.github.io/unbeauty/privateNote/Alkali/Forbidden/%EC%95%99%EB%8D%B0_%EB%8C%80%EC%88%98_%ED%95%B4%EB%AA%85)
```text/plain
앙대-대수의 절대 게임은, 곧이어 말할 수리논리학-언어 L의 모델의 구성에 쓰일수 있다.

왜 그런가? 의미론적으로 연산자를 구성함이, 본질이 아닌 응용 (인터페이스의 구현) 으로 구성될수 있는 언어적-특징을 가지기 때문이다.

의외성 정리를 참고하면 언어 L은 "단순언어"이고 그 본질은 자유에 있다는 칸토어의 말에 따라서, 튜링 머신인 "자바 가상머신"에서 인터페이스를 구현하는 코딩을 하듯, 그 같음의 연속을, 모델을 이용한 구성에 쓰는, 즉 본질애서 빙빙돌아, 겉가지로 구성하는것이 충분히 가능하단거디. 예컨데, "There should be one-- and preferably only one --obvious way to do it."라는 말은 맞다고 본다. 본질적으로 서술할방법이 대개는 있다. TMTOWTDI(There's more than one way to do it.)도 명백히 참인 경우가 많다, 그래서 겉가지로 구성하는것이 충분히 가능하단거다, 단지, 본질로써 구성함에는 적절하지 않을지 몰라도 말이다.

함의는 증명이랑도 어느 위계에서 같아질 수 있다.

따라서 meta-language보다는 그 자체로 메타적 구조처럼 평가할수 있게 평가되는 구조인 hyper-language형태가 나을것임이 분명하다.

따라서, 앙데-대수의 절대-개임은 이러한 함의의 특성으로 전건긍정•후건부정•삼단논법을 가지고, 충분히 논리학을 구성할수 있는 언어임을 보인다.

따라서 우리의 증명에 몰입해 그 언어로 쓰는사유의 여럿 기능적측면-속성이나 특징적 부분 등등이 그 근본을 따라 정리됨이 논리를 이루기에, 가장 기계적이고 단순하고, 수학자나 전산학자마냥 효율에 미친것같은 구성이지만, 순수히 생각의 연속으로 구성되는점과, 위에서 보아 한계를 넘으려는 점은, 우리 정신에 맞으므로, 그러한 방법으로 접근해좋으면 감사하겠다.

우리 정신의 연속만으로 논리를 구성한다는건, 인간의 본질적 사고와는 동떨어졌지만, 수학적으로는 최소한의 도구만 유클리드처럼 써서 사고(언어)-게임을 하는거니,

내 수학을 좋아하는 점이 참 미안하다. 나는 이 방식을 쓰겠다.

자, 이제 바로 본론으로 들어가, L = {¬, ∧, ∨, ↔, ⊕, →} 로 언어를 잡자.

먼저 정의를 하자.
DEF 1. p ↔ q = (p → q) ∧ (q → p)
DEF 2. p ⊕ q = (p ∨ q) ∧ ¬(p ∧ q)
DEF 3. p ∨ q = ¬(¬p ∧ ¬q)

테클 걸지 말자는 의도에서 하는말인데,
O와 X만이 유일한 평가이므로, DEF 3이 성립하는거지 아니면 그렇지 않다는건 미뤄둬라. (참고 : LAFTF 1.1 및 Alkalic의 대수식 내의 논리적 흐름)

DEF 2는 p와 q가 동시에 만족되는 경우 (즉, 진리집합을 Venn-Diagram으로 그릴때, p ∧ q의 영역)는 제외한다. 선택지같은 역할의 "또는"의 기능을 한다. 이것은 단순히 해당 구문의 기능적 측면에서의 속뜻 (차집합으로 구성되어 동작) 이며, 본질에 무관히 타당한 해석이다. 고로, 항상 딸려 참이되는 해석으로 필연적이므로, 속뜻 해석이 자유로운 (=속뜻이 안정해진) 언어 (예 : 수학의 본질은 자유에 있다) 본질이 기능을 함의한다.

DEF 1의 양방향 함의는 논리적 동등성이기도 하다. p → p는 이 수학 언어 게임에서, 절대적으로, 공리로 인한 무조건, 동등성이 함의하는 진리다. 잠시 환기해보자, 논리식을 흡사 계산하듯 다룬다는것은, 흡사 수리논리 언어의 명제의 (의미적으로) 자당히 (팁 : 추론에 떠르는 연결된 속성이므로 자당하다) 동등한 (즉 같은), 다양한 구문-형태의 존재이다. 수리논리 언어의 다양한 뜻의 존재는 그 진리치의 따짐이 항성 같은 겉뜻(속뜻과 겉뜻이 일치하니...)을 의미한다. 따라서 p와 q가 같은 속-겉(속뜻이자 겉뜻)뜻으로 보여, 예컨데 그 보임은 p와 q가 어떤 진리연산이 쓰일 명제 k일테니까, 아무튼, p → q이며 q → p일것임도 당연한 "논리적 귀결"이다. 그렇지만, p → q만 놓고 보자하니, 전건부정을 하였을따 오류가 나지 않아보인다, 왜냐하면 q → p라는 변인이 특수한 경우(특수한 진리값 배정)에서 후건부정으로 동작하기 때문이다. 고로, 전건 부정에 대하여서, 두가지를 AND(논리곱)-로 나열하여 p → q이며 q → p임을 따지는것이 즉, p = q에서 k = p = q임이 p → q이며 q → p임을 만족하는데, 이가 당연히 모든 함의에 대한 성질로써 함의하니 귀결이며, 이때 p → q이며 q → p이라는것은 p → q ∧ q → p = (¬ p ∨ q) ∧ (¬ q ∨ p) =(잔계산 생략)= p ↔ q 이니, 당연히, 그 뜻을 p → q ∧ q → p로 놓고 보아도 됨이 진실로 타당하다. 그 뜻이 같으니 해석도 결국 같음은, 우리가 이런식으로 조금만 (그러나 큼지막한 달에 닿은 발걸음만큼일수도 있는) 나아가면, 수학 언엇-말이 진실로 타당하게 같은 것임을 보이지 않는가?

우리가 조금만 추론을 하면 기존 규칙인 전건긍정 • 후건부정도, 이 수리논리라는 언어가 만족되기 위한 성질 명세(본질)에 따라, 유도되어야만 하는거다.

따라서, 그것들도 우리가 선택한, 생각들의 연결로써, 티탄같은 골격을 그린것이다.

그렇다면 이제, (함의의 내부 의미를 이용하여 귀결로 그 뜻이 응용됨을 이용하여) 모델을 구성하는 측면에서 다음은 타당함으로, 이용해도 좋다.

p → X 가 후건 부정이니 전건인 p를 부정하여 참이되는 추론이니, 저 명제는 참이므로, 즉, 저 술어가 만족됨은, p를 부정한다는것, 즉, 이는 부정연산이 된다.

*초심 잃어서 나중에 다시 쓸 문단이다*

함의문은 전건긍정과 후건부전이라는 규칙을 가진다. 그렇다면, 앞인자를 긍정할때와, 뒷인자를 부정할때 말고, 앞인자 긍정, 뒷인자 긍정의 경우에, 특별한 성질을 가진다. 즉, p → ¬q인 논리식에서, p가 긍정되면 q는 부정되야하며, q가 긍정되면 p는 부정되야한다, 달리말해, 그 두가지가 다 긍정이 되는것은 규칙에 어긋난다. 이때 다시, 앞인자를 부정하는 경우와, 뒷인자를 부정하는 경우의 논리식을 만들어보면, ¬p → q인데, 이는 p를 부정하면 q가 긍정해야하고, q를 부정하먼 p가 긍정되야 한다. 마찬가지로, p와 q가 동시에 부정될 수 어없다. 이때, p → ¬q와 ¬p → q에서 각각, p와 q에 대해 각각 부정-부정, 긍정-긍정의 경우가 같다, 즉, 달리말해, 이런경우, ¬(p → ¬q) = ¬p → q인것이다. 의미상 이는 각각 부정논리곱문, 논리합문이 되는데, 이는 전건을 부정함이 후건을 부정함으로 이어지는지가 타당하자 아니하여, 전건을 부정함이 후건을 긍정할때, 타당하지 아니하다 말할수 없으니, 전건부정, 후건긍정이 서로 배타적이지 않다는것이다, 틀린 전제로 옳은 증명을 이끌수 있음은, 충분히 보일수 있으니 연습하여 이해하는것이 중요하다. 음... p → ¬q일때 p와 q의 긍정이 베타적인데, 부정은 베타적이지 아니하며, 이는 p → ¬q가 부정논리곱으로 구성되어도 함의문의 만족을 이룰수 있음을 의미하게 될것이다. 즉 타당한 모델이며, 사실은 동일 맥락에서 ¬p → q가 논리합문으로 구성될수 있음인데, 이는 전제의 진리값을 부정하여 판단하므로, 긍정 부정 규칙의 이름이 정 반대여야 할것이며, 서로를 배타하고 교환된다. 이는 논리합문으로의 구성과 완전히 같은 뜻을 가지기에 필연적으로 귀결되지만, 현제 표현력이 딸려 포기하고, 나중에 재작성한다.

마지막으로, 함의문의 이산적 성질만을 분석해보자.

지금부터는, 논리식을 늘어놓을때, 당연히 그 전제가 참이라 가정하는, 즉, 메타수준의 함의와 동등한 증명•귀결(혹은 만족)기호를 이용하기에, 논리곱 대신에 콤마가 쓰인다. (에초에 형식증명의 경우, 각 라인 (튜플 인덱스)의 명제가 참이여야 하고 (건전과 유관하긴 함), 귀결(혹은 만족의 경우 모델을 배정하는 명제로 족하다.)기호같은 경우, (완전하며 건전할때 특히) 집합안의, 즉 순서없이 명제들이 나열될때는, 즉 해당 집합이 의미하는 바는, 내부 명제가 다 만족되는것을 의미하는데 (Venn-Diagram으로 그려보라.) 이는 전제가 나열되었기에, 의미상 나열된 임의의 원소에 대하여도 함의가 성립하여야 하기에, 당연하다. 즉, 나는 이 문단부터는 초심을 잃어서, 수학적으로 접근했다.

x → y서 전건긍정 O -> p ⊢ p = O, 후건부정 p -> X ⊢ p = X 은 다음을 함의한다. (p -> X ⊢ p = X), (O -> p ⊢ p = O) ⊢ (O → X = X)
즉, 전건이 긍정되었는데 후건을 부정하면 전건긍정의 부정이기에 타당한 추론규칙의 명제형의 부정은 거짓이므로,인 거짓이고, 후건이 부정되었는데, 전건을 긍정하면 후건부정의 부정이기에, 타당한 추론규칙의 명제형의 부정으로 거짓이다.

전건부정은 오류다, 하지만 타당한 추론 규칙이란 말의 뜻은 항진이여야 함을 가정하고 있으므로, 전건부정이 거짓이 되는 경우로 엄밀히 가정함을 미리 선언한다, 함의문으로 생각해보면 O → X가 있을수 없는 경우니, 확실히 불가능한 경우중 한 분기로, X → p와 p = X를 다음과 같이 평가하고 계산할수 있다. (X → p ⊢ p = X) = X ⊢ ((X → p) = O, (p = X) = X) (= X → p, p = O) 따라서, 함의문은 O → X만 불가능하다.
```
