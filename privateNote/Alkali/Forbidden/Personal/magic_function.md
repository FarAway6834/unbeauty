# 실수를 만든다는게 뇌절인 이유

물론 내가 실수를 만드는 방법이 뇌절인거다.

## 1. 유리수체 위에서 사칙연산과 지수연산만으로 f(x, y, 0) = x + y이고, f(x, y, 1) = x - y이며, f(x, y, 2) = x × y이면서 f(x, y, 3) = x ÷ y인 함수 f : ℚ² × {0, 1, 2, 3} → ℚ가 존재함을 증명하기.

g : {0, 1} × ℚ² → ℚ인 g(p, x, y) = p(x - y) + y에서,
g(1, x, y) = x이고, g(0, x, y) = y

h : ℤ → {0, 1}인 h(n) = ½(1 - (-1)ⁿ)에서,

h(0) = h(2) = 1이고, h(1) = h(3) = 0

H(x) = 1 - h(x) 에서,

H(0) = H(2) = 0이고, H(1) = H(3) = 1

또한, H(x) = 1 - ½(1 - (-1)ˣ)

G(x) = ½(x - H(x))에서,

G(2n) = ½(2n - 0) = n이고, G(2n + 1) = ½(2n + 1 - 1) = n임.

또한, G(x) = ½(x - (1 - ½(1 - (-1)ˣ)))

F : {0, 1, 2, 3} × ℚ → ℚ애서, F(x, y) = g(g(G(x), h(x), 1), 1, y)에서,

F(0, y) = g(g(G(0), h(0), 1), 1, y) = g(g(0, h(0), 1), 1, y) = F(1, y) = g(g(G(1), h(1), 1), 1, y) = g(g(0, h(1), 1), 1, y) = F(2, y) = g(g(G(2), h(2), 1), 1, y) = g(g(1, 1, 1), 1, y) = g(1, 1, y) = 1, F(3) = g(g(G(3), h(3), 1)), 1, y) = g(g(1, 0, 1), 1, y) = g(0, 1, y) = y임.

또한, F(x, y) = g(g(G(x), h(x), 1), 1, y) = (G(x)(h(x) - 1) + 1)(1 - y) + y = (G(x)(h(x) - 1) + 1)(1 - y) + y = ((½(x - (1 - ½(1 - (-1)ˣ))))(½(1 - (-1)ˣ) - 1)(1 - y) + y

f : ℚ² × {0, 1, 2, 3} → ℚ인 f(x, y, z) = g(G(z), g(H(z), x + y, x - y), g(H(z), x × y, x ÷ F(z, y)))
에서,

f(x, y, 2p + q) = g(G(2p + q), g(H(2p + q), x + y, x - y), g(H(2p + q), x × y, x ÷ F(2p + q, y))) = g(1 - p, g(1 - q, x + y, x - y), g(1 - q, x × y, x ÷ F(2p + q, y)))이므로, f(x, y, 0) = g(1, g(1, x + y, x - y), g(1, x × y, x ÷ 1))) = x + y이고, f(x, y, 1) = g(1, g(0, x + y, x - y), g(0, x × y, x ÷ 1))) = x - y이며, f(x, y, 2) = g(0, g(1, x + y, x - y), g(1, x × y, x ÷ 1))) = x × y이면서 f(x, y, 3) = g(0, g(0, x + y, x - y), g(0, x × y, x ÷ y)) = x ÷ y이다.

즉,

f(x, y, z) = g(G(z), g(H(z), x + y, x - y), g(H(z), x × y, x ÷ F(z, y))) = g(G(z), g(H(z), x + y, x - y), g(H(z), x × y, x ÷ F(z, y)))

이때,

H(z) = 1 - ½(1 - (-1)ᶻ)
G(z) = ½(z - (1 - ½(1 - (-1)ᶻ)))
F(z, y) = ((½(z - (1 - ½(1 - (-1)ᶻ))))(½(1 - (-1)ᶻ) - 1)(1 - y) + y

이고,

g(G(z), g(H(z), x + y, x - y), g(H(z), x × y, x ÷ F(z, y))) = g(G(z), g(H(z), x + y, x - y), g(H(z), x × y, x ÷ F(z, y))) = g(G(z), g(H(z), x + y, x - y), g(H(z), x × y, x ÷ F(z, y))) = G(z)(g(H(z), x + y, x - y) - g(H(z), x × y, x ÷ F(z, y))) + g(H(z), x × y, x ÷ F(z, y)) = G(z)(H(z)((x + y) - (x - y)) - (H(z)(x × y - x ÷ F(z, y) + x ÷ F(z, y))) + (H(z)(x × y - x ÷ F(z, y) + x ÷ F(z, y)) 이므로,

f(x, y, z) = ½(z - (1 - ½(1 - (-1)ᶻ)))((1 - ½(1 - (-1)ᶻ))((x + y) - (x - y)) - ((1 - ½(1 - (-1)ᶻ))(x × y - x ÷ (((½(z - (1 - ½(1 - (-1)ᶻ))))(½(1 - (-1)ᶻ) - 1)(1 - y) + y) + x ÷ (((½(z - (1 - ½(1 - (-1)ᶻ))))(½(1 - (-1)ᶻ) - 1)(1 - y) + y))) + ((1 - ½(1 - (-1)ᶻ))(x × y - x ÷ (((½(z - (1 - ½(1 - (-1)ᶻ))))(½(1 - (-1)ᶻ) - 1)(1 - y) + y) + x ÷ (((½(z - (1 - ½(1 - (-1)ᶻ))))(½(1 - (-1)ᶻ) - 1)(1 - y) + y))

이다. 아마도 욕나오는 오탈자가 발샹하지 안았다면 말이다. 저걸 검수하는건 사람이 할 짓이 아니다.

f(x, y, z) = ½(z - (1 - ½(1 - (-1)ᶻ)))((1 - ½(1 - (-1)ᶻ))((x + y) - (x - y)) - ((1 - ½(1 - (-1)ᶻ))(x × y - x ÷ (((½(z - (1 - ½(1 - (-1)ᶻ))))(½(1 - (-1)ᶻ) - 1)(1 - y) + y) + x ÷ (((½(z - (1 - ½(1 - (-1)ᶻ))))(½(1 - (-1)ᶻ) - 1)(1 - y) + y))) + ((1 - ½(1 - (-1)ᶻ))(x × y - x ÷ (((½(z - (1 - ½(1 - (-1)ᶻ))))(½(1 - (-1)ᶻ) - 1)(1 - y) + y) + x ÷ (((½(z - (1 - ½(1 - (-1)ᶻ))))(½(1 - (-1)ᶻ) - 1)(1 - y) + y))

는

f(x, y, 0) = x + y이고, f(x, y, 1) = x - y이며, f(x, y, 2) = x × y이면서 f(x, y, 3) = x ÷ y이다.

고로, 유리수체 위에서 사칙연산과 지수연산만으로 f(x, y, 0) = x + y이고, f(x, y, 1) = x - y이며, f(x, y, 2) = x × y이면서 f(x, y, 3) = x ÷ y인 함수 f : ℚ² × {0, 1, 2, 3} → ℚ가 존재함을 f(x, y, z) = ½(z - (1 - ½(1 - (-1)ᶻ)))((1 - ½(1 - (-1)ᶻ))((x + y) - (x - y)) - ((1 - ½(1 - (-1)ᶻ))(x × y - x ÷ (((½(z - (1 - ½(1 - (-1)ᶻ))))(½(1 - (-1)ᶻ) - 1)(1 - y) + y) + x ÷ (((½(z - (1 - ½(1 - (-1)ᶻ))))(½(1 - (-1)ᶻ) - 1)(1 - y) + y))) + ((1 - ½(1 - (-1)ᶻ))(x × y - x ÷ (((½(z - (1 - ½(1 - (-1)ᶻ))))(½(1 - (-1)ᶻ) - 1)(1 - y) + y) + x ÷ (((½(z - (1 - ½(1 - (-1)ᶻ))))(½(1 - (-1)ᶻ) - 1)(1 - y) + y))을 제시함으로써, 구성론적으로 증명할 수 있다.

나는 존재함을 보인다고 했지, "깨끗하고 인간적으로"보인다고 한적은 없다.

저런건 수식 프로그래머한테 포멧팅 맞겨라. 지금 아주 욕나오게 스파게티코드다.

아시× 내가 뭔 흉물을 만든거야 자괴감 들어, 조만간 함수식 수정해야겠다.

Q.E.D.

## 2. 더 흉물 만들기

제한된 수식 언어 공간 L₀ = {'f', '(', ',', ')', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'}과 변수 이름 공간 L₁에 대해,

Gform₀ : `/g\((L₀ ∪ L₁)*\) = ((L₀ ∪ L₁)*g\((L₀ ∪ L₁)*\))*(L₀ ∪ L₁)*/`인 형식

으로 잡고, 내부적으로 g의 인자 처리 -> g -> 리턴값 포함해서 후처리 방식으로 동작하니, 에초에 g를 그렇게 쓰지 말고, 여러번에 걸쳐서 다른 g를 쓰도록 호출하면 그만이니,

Gform₁ : `/g\((L₀ ∪ L₁)*\) = (L₀ ∪ L₁)*g\((L₀ ∪ L₁)*\)(L₀ ∪ L₁)*/`인 형식

으로 바꿔주면 된다. 근데 사실 그러면, `(L₀ ∪ L₁)*`인 인자 처리 부분과 나머지 부분을 함수로 선언해주면 ㅋㅋㅋ 되는 상황이 되므로,

Hform : `/ ; (L₀ ∪ L₁)* ; (L₀ ∪ L₁)* ; (L₀ ∪ L₁)* ; (L₀ ∪ L₁)* ; (L₀ ∪ L₁)* ; /h\(ioBool, valueOfG, $3\) = $4 (단. h : {0, 1} × ℚⁿ) \n g($0) = h(0, g(h(1, 0, $1)), $2)`

이런식으로 하면, h함수의 ioBool = 0분기시 g의 인자 처리를, ioBool = 1분기시에 리턴값 포함해서 후처리하면 되므로, 함수 제대로 작동하고 싶은 사람이라면 알아서 잘 설정할것이므로,

Hform을 통해서, 언어 L = L₀ ∪ L₁ ∪ {';'}에서 충분히 유리수체 위에서 만들수 있는 함수식을 죄다 표현할 수 있다.

그러면 ㅋㅋ 유리수체 ℚ위의 함수 f를 초유리수체 ℚ*위의 함수로 보내버리는 trellaotrealla(f) = f*을 통해 초유리수체 함수 f*를 만들수 있다면, 실수는 realgenf(f) = st ◦ trellaotrealla(f)인 realgenf의 치역 겸 정의역과 동형인것이, realgenf(f)(ω)의 치역이 바로 실수이기 때문이다.

펙트 : 초실수를 이용하여 무한대를 만든 순간부터 이미 돌이킬수 없을 정도로 뇌절이다. 울트라곱 대수 들먹일것도 없이, 걍 "무한"이 "대수학"에 나와서, "무한정 큰 수"가 필요한 "직관"에 "쓰인 순간 이미 뇌절인거"다.