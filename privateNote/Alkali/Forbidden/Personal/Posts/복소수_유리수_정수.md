# 복소수, 유리수, 정수, 그리고 실수

먼저 서술하기에 앞서, MagmaCurring과 MCNyoky가 무엇이고 어떻게 작동하는지
핵심 idea를 간략히 짚고 넘어가자.
마그마 <S, *>에 대하여, 함자(functor) (a *), (* a)는 각각 오른쪽 작용 (a *) ∈ 𝔉(S, S)과 왼쪽 작용 (* a) ∈ 𝔉(S, S)은 커링(currying, curry) λx. λy. x * y하여, 표현할수 있다.
그리고, 이는 (λf.λx.λz.f(x, y)) ∈ 𝔉(𝔉(S², S), 𝔉(S, 𝔉(S, S)))이다.
참고로, 람다 역시 함자인데, 저경우는 정의역을 제한하면 함수와 동형이므로, 같게 취급한다. 또한 MCNyoky는 λf. λx. λy. fyx의 역할을 하는 연산이다.
i.e.
1. MagmaCurring(S) ≜ (𝔉(S², S), 𝔉(S, 𝔉(S, S)), {(f, (S, 𝔉(S, S), {(x, (S, S, {(y, f(x, y)) | y ∈ S})) | x ∈ S})) | f ∈ 𝔉(S², S)})
2. MCNyoky(S) ≜ (𝔉(S, 𝔉(S, S)), 𝔉(S, 𝔉(S, S)), {(f, (S, S, {(x, y) | (y, x) ∈ graph f})) | f ∈ 𝔉(S, 𝔉(S, S))})

MCNyoky는 NCSystemicArgumentSwap이라 쓰기 번거로워서, 내가 이전에 맡아본 배역 이름을 붙였다.
MagmaCurring으로 커링을 하고, MCNyoky로 인자를 원하는대로 고를수 있다.
ut, 이 도구들로 좌•우 작용의 함자 표현을 대신할수 있다.
e.g.
1. MagmaCurring(S)(*)(a) = (a *)
2. MCNyoky(MagmaCurring(S)(*))(a) = (* a)

이제 연산자들을 함수형으로 쓸 목적에서 따로 함수임을 강조하기 위해, Polandian Notion용 함수로 쓰겠다. 참고로, 아래 함수와 이항연산은 같은 정의역에 같은 공역에, 같은 그래프를 가지므로, 동일하다.

add(x, y) ≜ x + y
sub(x, y) ≜ x - y
mot(x, y) ≜ x × y
div(x, y) ≜ x ÷ y
pow(a, n) ≜ aⁿ
LOG(a, x) ≜ logₐ(x)

이름이 안겹치려고 LOG로 명명한건 봐줘라.

먼저 역산의 관계를 밝히고 가겠다.
 * logₐ ≜ MagmaCurring(pow)(a)⁻¹
 * MCNyoky(MagmaCurring(div))(a) ≜ MCNyoky(MagmaCurring(mot))(a)⁻¹
 * MCNyoky(MagmaCurring(sub))(a) ≜ MCNyoky(MagmaCurring(add))(a)⁻¹

그리고, 지수와 로그의 정의를 밝히고 가겠다.
 * exp = MagmaCurring(pow)(e(
 * ln ≜ logₑ ≜ exp⁻¹
 * pow(a, x) ≜ exp(x ln(a))
 * logₐ(x) ≜ ln(x)/ln(a)
 * exp ≜ 1 s.t. 1 ∈ span(MCNyoky(MagmaCurring(pow))[ℕ₀]) (단. 1은 일벡터. i.e. 1 = Σ MCNyoky(MagmaCurring(pow))[ℕ₀] i.e. 집힙 S에 대해, sum(S) 인거다.)

테일러 급수가 들어간 건과, 이것이 복소로그라는 점에 대해서는 좀 걸리지만, 애써 무시해보자.

이제 동형성을 이용해서, 곱셈과 나눗셈을 재정의하자.
 * x × y ≜ exp(ln(x) + ln(y))
 * x ÷ y ≜ exp(ln(x) - ln(y))

이를 ln에 대입해보면, ln(x × y) = ln(x) + ln(y)으로, 자기동형사상 ln에 대해 덧셈과 동형인 연산으로 곱셈은 정의되며, ln(x ÷ y) = ln(x) - ln(y)으로, 자기동형사상 ln에 대해 뺄셈과 동형인 연산으로 나눗셈은 정의된다.

N.B. 단, 이는 어디까지나 x ≠ 0 ≠ y인 경우만 가정한것이다. 그 경우만이다.

이제 덧셈과 뺄셈을 준동형사상의 일종인, 1×2 실행렬 꼴의 선형사상으로 브라-켓 표기법을 이용하여, 재정의해보자.

add ≜ <x̂ + ŷ| (단. x̂ + ŷ는 <1, 1>의 이름 (name). i.e. [x̂ + ŷ := <1, 1>])
sub ≜ <x̂ - ŷ| (단. x̂ + ŷ는 <1, -1>의 이름 (name). i.e. [x̂ + ŷ := <1, 1>])

졍의가 중복되었는지 걱정하지 마라, 저건 그냥 이름일 뿐이다. 원래 브라-켓에선 그렇다.

마지막으로 항등함수를 정의하겠다.

I(x) ≜ x

이는 벡터장을 이용한 함수의 표기에 매우 유용하게 사용될것이다.

이상으로 add, sub, mot, div, pow, LOG, I의 정의를 마친다.

본론으로 들어간다.

CPCNVF ≜ CPCNVectorField ≜ <I, i I>
CCVF ≜ CCVectorField ≜ <I, -I>

CPCN ≜ CardesianPlain2ComplexNum ≜ add ◦CPCNVF

CC ≜ ComplexConjugate s.t. ComplexConjugate(z) ≜ z̄

Transpose(M) ≜ Mᵀ

Lemma) Transpose(a, b)(x, y) = Transpose(1, 1)(ax, by) = Transpose(ax, by)(1, 1)
pf.

1. Transpose(a, b)(x, y) = Transpose(1, 1)(ax, by) → Transpose(ax, by)(1, 1) = Transpose(1, 1)(ax, by)
2. Transpose(a, b)(x, y) = ax + by = add(ax, by) = Transpose(1, 1)(ax, by)
3. Transpose(a, b)(x, y) = Transpose(1, 1)(ax, by) = Transpose(ax, by)(1, 1)

Q.E.D.

Lemma) sub = add ◦ CCVF
pf.

add ◦ CCVF
 = |x̂ + ŷ> ◦ CCVF
 = (Transpose◦CC)(<1, 1>) ◦ CCVF
 = Transpose(CC(<1, 1>)) ◦ CCVF
 = Transpose(<1, 1>) ◦ CCVF
 = Transpose(1, 1) ◦ CCVF

sub
 = |x̂ - ŷ>
 = (Transpose◦CC)(<1, -1>)
 = Transpose(CC(<1, -1>))
 = Transpose(<1, -1>)
 = Transpose(1, -1)
 = Transpose(1, 1) ◦ CCVF (∵ Transpose(a, b)(x, y) = Transpose(1, 1)(ax, by) = Transpose(ax, by)(1, 1))

Tip : Transpose를 쓰기 이전까지 쭉 SIMD연산, 즉, 벡터 원소간 계산이었다.

Q.E.D.

Lemma) CC ◦ CPCN = sub ◦ CPCNVF = CPCN ◦ CCVF
pf.

1.1. sub = add ◦ CCVF
1.2.1. <I, -I> ◦ <I, i I> = <I, -i I>
1.2.2. <I, i I> ◦ <I, -I> = <I, -i I>
1.2.3. CCVF ◦ CPCNVF = CPCNVF ◦ CCVF
1.3. add ◦ CCVF ◦ CPCNVF = add ◦ CPCNVF ◦ CCVF
1.4. sub ◦ CPCNVF = CPCN ◦ CCVF
2.1. CC ◦ CPCN = CC ◦ add ◦ CPCNVF
2.2.1. (CC ◦ CPCN)(x, y) = CC(x + yi) = x - yi = sub(x, yi) = (sub ◦ CPCNVG)(x, y)
2.2.2. CC ◦ CPCN = sub ◦ CPCNVF
3. CC ◦ CPCN = sub ◦ CPCNVF = CPCN ◦ CCVF

Q.E.D.

CC ◦ CPCN = sub ◦ CPCNVF = CPCN ◦ CCVF

참고로, CCVF² = <I, I> 즉, ℝ²에서 CCVF는 대합이다.
마찬가지로, CPCN(CCVF(v)) = CC(CPCN(v))이기에, CC² = I, 즉, ℂ에서, CCVF는 대합이다.

CPCN은 동형사상이다. 왜냐?

CPCN ∈ 𝔉(ℝ², Span({1, i})) 이고,
CPCN(kv + w) = kCPCN(v) + CPCN(w)
pf. CPCN(k<a, b> + <x, y>) = CPCN(<ka + x, kb + y>) = kCPCN(<a, b>) + CPCN(<x, y>) = k(a + bi) + (x + yi) = (ka + x) + (kb + y)i
으로, CPCN(x̂) = 1, CPCN(ŷ) = i인데, CPCN[ℝ²] = Span[{CPCN(x̂), CPCN(ŷ)}]으로,
선형생성시키는 원소를 비교하는 수법을 쓰면,

CPCN(x) = CPCN(Σᵢ xᵢeᵢ) ≠ CPCN(Σⱼ yⱼeⱼ) = CPCN(y) → x ≠ y

즉, 전단사다.
얼마나 구조적인 행운인가? 참고로, 그냥 Span({1, i})선에서 증명할수 있지만, 동형성이 구체적으로 어떻게 대응되는지 설명하므로써, 난 이 구조를 강조하고 싶었다.

벡터공간의 합•상수배•차에 대해서 그대로 복소수의 합•실수배•차가 동형으로 재정의된다.

실수부, 허수부를 구하는 연산은,

ℜ(z) ≜ ½(CC(z) + z)
ℭ(z) ≜ ½i(CC(z) - z)

인데,

v₁ ≜ v • x̂ ≜ ∂v/∂x̂
v₂ ≜ v • ŷ ≜ ∂v/∂ŷ

으로,

CPCN(v₁) = CPCN(v • x̂) = CPCN(∂v/∂x̂) = ℜ(CPCN(v))
CPCN(v₂) = CPCN(v • ŷ) = CPCN(∂v/∂ŷ) = ℭ(CPCN(v))

이다.

i.e. 

쉽게,

ℜ(a + bi) = a, ℭ(a + bi) = b이기에,

CPCN(v₁) = CPCN(v • x̂) = CPCN(∂v/∂x̂) = ℜ(CPCN(v))
CPCN(v₂) = CPCN(v • ŷ) = CPCN(∂v/∂ŷ) = ℭ(CPCN(v))

이것도 이것대로 ∂/∂x̂및 ∂/∂ŷ가 CPCR을 통해 ℜ및 ℭ로 바뀐것이다.

그러면, 내적(스칼라곱)은?

CPCR<v | w> ≜ ℜ(CC(CPCR(v))CPCR(w))

참고로, (a - bi)(c + di) = ac + bd + (ad - bc)i이기에, a:b = c:d라면 ℭ(CC(CPCR(v))CPCR(w)) = 0이다.

이제 진짜 재미있는게 나온다.

그렇다면 cabs(z) = √(zCC(z))와 norm ||•||은?

t = CPCR(||z||) = CPCR(√(<z | z)) > 0에 대해,
t = √CPCR(<z | z>) = cabs(CPCR(z))

그렇다. 에초부터, 복소평면에서 거리의 척도는 복소 절댓값이다.

ln(reⁱᶿ) = ln(r) + iθ이니까,

ℜ(ln(z)) = ln(cabs(z))이고, ℭ(ln(z)) = θ이다.

즉, 복소수는 거리와 방향을 가진다는 점에서 벡터이다.

심지어, 완비 내적 거리 공간이므로, 복소평면은 힐베르트 공간의 부분공간일 공리를 만족한다.

가우스 정수, 혹은 유리수체에 대해서 복소화한 복소평면을 생각하면, 내적공간의 공리를 만족한다.

즉, 복소평면은 데카르트 공간과 동형으로 HoTT입장에선 같다고 봐야할것이며, 본질적으로 그 형식언어적 형식문법의 작동이 lange로 하여금 시사하는 바가, 대수구조를 논하는 수준에서 다르지 않다. (집합론같은 기초론으로 환원하면, 객체 구성이 다르다.)

복소수 모델을 만족시키는 구성 중, 행렬표현이 존재할수 있음도 시사한다.

<ℂ, 0, 1, i, +, -, ×, ÷> 에 대하여,

0 ≜ 1 - 1
-1 ≜ 0 - 1
i ≜ √(-1)

이고,

곱셈에 대하여,

복소수 CPCR(k, 0)는 실수 k에 대하여, kCPCR(1, 0)이니, CPCR(1, 0)는 단위원(항등원)이다.

이를 행렬표현할때, 곱셈이 행렬곱이라면, 1 = I = [[1, 0], [0, 1]]이다.

이제 오일러 공식으로 한번 생각해보자.

idea)

CPolarForm(r, θ) ≜ reⁱᶿ 에 대해서,

MCNyoky(MagmaCurring(CPolarForm))(θ)는 벡터장에서의 Curr과 같다.

본질은 무엇인걸까?

...작성중...