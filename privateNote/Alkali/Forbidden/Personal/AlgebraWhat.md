# Alkalic + Lava

Alkalic은 일부로 모델론을 입력 가능하게 구상되었다.
왜일까?

... 바로 수학기초론이기 때문이며, **Lava System**을 이식하기 위함이다

#### 이건 필연이다 ; Alkalic + Lava

## Alkalic

````markdown
# Alalic Preview

이걸 아주 아주 잘 발전시킬거임, 깃헙 커밋으로 ㄱㄱ

거의 됬네 기분좋다.

## DEFINIRION : Alkalic : Alkalic Linear-algebra + Königsberg Axiom + Lambda Incoding Calculate (구문론적 문제로 lambda형식만 유지하고, 폐지, 람다 지분은 없음)

### Alkalic Algbra

∀x (각각 유일)∃!n(x) s.t. n = ObjectID(x) ∈ Scala

 - AlkalicVectorSpace = Scalaᵗ [t := |Scala|]
 - AlkalicMetrixSpace = AlkalicVectorSpaceᵗ [t := |Scala|]
 - SetTheorem ∈ AlkalicMetrixSpace
 - Notation Definition m ∈ n ≡ SetTheoremₒᵢ₍ₘ₎ₒᵢ₍ₙ₎ [oi := ObjectID]

Alkalraum은 여기서, Scala가 객체의 집합으로 확장되어서, |Scala| = κ가 된다.

### Lambda Including Calculate (구문론적 문제로 lambda형식만 유지하고, 폐지, 람다 지분은 없음)

Alkalic Algbra서 AlkalicVectorSpace나 oidfield = Σᵢ ObjectID eᵢ에 대해, 입력받는 Tensor입력으로 ~~람다~~, 대수함수, Alkalic Algbra서 다가함수를 포함한 함수 구현.

---

폐지되었기 때문에

람다를 아예 삭제해서, 람다가 아닌 걍 연산 과정인 Subrootine으로 바꿨다.

Alkalic Algbra서 AlkalicVectorSpace나 oidfield = Σᵢ ObjectID eᵢ에 대해, 입력받는 Tensor입력으로 대수함수, Alkalic Algbra서 다가함수를 포함한 함수 구현.

하는 체계로 바뀜.

연산 괴정이다.

모든 미지수는 이 람다 체계에서 함수 내부변항으로 고정되어서, 두 함수의 합성에서 초기화되어 창출되거나, 아니면 인자로 된다. 따라서, 어떤 수학 이론은 인자를 가지며, 모델이나 진리값배정은 그 값을 넣는다. (어떻게든 대입됨)

변항은 이론에 인자로 설명 가능

### Königsberg Axiom, VectorAxiom, InaccessibleCardinalExistanceAxiom

⊢ KönigsbergAxiom(x, y, Φ) := (x = y → (Φ ↔ (Φ [x := y])))

이때 [x := y]는 단순히 의미론적 대입 연산자.

⊢ VectorAxiom : "모든 벡터 공간은 기저를 가진다"

다음 글을 읽어 보라.
```
먼저 중위표기결합자 * 에 대해, 다음과 같은 표기법을 도입한다, (*x)(y) ≡ y * x
f(x) ≡ (∈x)라고 공역이 치역으로 정의된 f와 g(x) ≡ (=x)라고 공역이 치역으로 정의된 g를 정의하겠다, 이떄, f와 g의 전사함수임이 당연하며, `≡`는 구문론적 등호다, 참고로 정의역은 집합임으로, 해당 집합이 존재해야 들어갈 수 있다, 또한 f와 g는 표기법이기 때문에, 실제 대수적 객체가 아니며, x ∈ f⁻¹(Φ)가 Φ(x)임은 당연하다, 참고로 공역을 치역으로 정의했다는 뜻은, 저 표기법이 표기하는 수학적 객체의 집합은 저 표기법이 표기하는 수학적 객체의 집합이지, 표기법에서 따로 정의하지 않기에, 최소한의 응용이 아닌 공역이 치역이 되지 않는 큰 응용을 하는것을 형식 언어 형식 문법 수준에서 금지한다고 하는것이다. (당연하다고 말한 내용들은 정의가 아니다, 태클을 걸수 있다.), 마지막으로 h̅는 h의 진리값배정이다. 진리값배정을 뜻하는 표기법이다.
외연 공리(Axiom of Extensionality)와 같은뜻인 명제를 보자, `(∀A∀B)(((x∈A) = (x∈B)) → (A = B))` ≡ `(∀A∀B)((f(A) = f(B)) → (A = B))`이기에, 외연공리는 f가 (전)단사함수임과 동치로, 외연 공리에 따라, 외연공리꼴의 다른 표현인 `f가 (전)단사함수이다`는건 외연 공리가 참일떄 참이다.
외연 공리가 의미하는 바는, 외연 공리가 만족되는 조건은, f가 일대일대응으로 동작하도록 정의된것과 같다,
따라서, 지금부터 f는 외연공리를 만족하는 f인 F로 재정의된다, F⁻¹도 외연 공리를 만족하는 f⁻¹과 같음이, f에 대한 F의 정의상 당연하다

짝 공리(Axiom of Pairing)와 같은뜻인 명제를 보자, ∃{A, B} = ∃{x | (x=A)∨(x=B)}인데 (x=A)∨(x=B) ≡ g(A)(x)∨g(B)(x) = (g(A)∨g(B))(x)로, ∃{A, B} = ∃{x | (x=A)∨(x=B)} = ∃{x | (g(A)∨g(B))(x)}이고, ∃{A, B} f({A, B})(x) = f({x | (g(A)∨g(B))(x)})(x) = (g(A)∨g(B))(x)으로, ∃{A, B}  f({A, B}) = g(A)∨g(B)이기에, {A, B} = f⁻¹(g(A)∨g(B))에서, ∃f⁻¹(g(A)∨g(B))가 짝 공리와 동치로, 짝 공리에 따라, 짝 공리의 다른 표현 `∃f⁻¹(g(A)∨g(B))`은 짝  보장될때, 항진이다.
합집합 공리(Axiom of Union)와 같은뜻인 명제를 보자, ∃{x | (x∈A)∨(x∈B)} ≡ ∃{x | f(A)(x)∨f(B)(x)} = ∃{x | (f(A)∨f(B))(x)}에서, ∃{x | (x∈A)∨(x∈B)} f({x | (x∈A)∨(x∈B)})(x) = f({x | (f(A)∨f(B))(x)}) = (f(A)∨f(B))(x)이므로, ∃{x | (x∈A)∨(x∈B)} f({x | (x∈A)∨(x∈B)}) = (f(A)∨f(B))서, ∃f⁻¹(f(A)∨f(B))임이 합집합 공리와 같은 뜻이고, 합집합 공리에 따라, 합집합 공리의 다른 표현 `∃f⁻¹(f(A)∨f(B))`은 합집합 공리가 보장될때, 항진이다.
이때, 합집합 공리과 짝 공리가 다 참이라는 "합집합 공리와 짝 공리가 보장됨 공리"라는 공리를 세우겠다, 이 공리는 합집합 공리는 합집합 공리의 논리식 표현 p와 짝 공리의 논리식 표현 q에 대해 p와 q가 항진이라는 뜻으로 정의된다. 합집합 공리와 짝 공리가 보장됨 공리와 같은 명제를 보자, "합집합 공리와 짝 공리가 보장됨 공리" = "`∃f⁻¹(g(A)∨g(B))`와, `∃f⁻¹(f(A)∨f(B))`임이 보장됨 공리" = "`∃f⁻¹(g(A)∨g(B)), ∃f⁻¹(f(A)∨f(B))`"으로, , 이는, h̅ = (f, g) ⊨ (∃f⁻¹(h(A)∧h(B)))과 같으므로, 우리가 가정한 "합집합 공리와 짝 공리가 보장됨 공리"에 대해 "합집합 공리와 짝 공리가 보장됨 공리"에 따라, "합집합 공리와 짝 공리가 보장됨 공리"의 다른 표현인 `h̅ = (f, g) ⊨ (∃f⁻¹(h(A)∨h(B)))`는 "합집합 공리와 짝 공리가 보장됨 공리"가 참일때 참이다.
멱집합 공리(Axiom of Power Set)는 멱집합의 존재성을 보장한다.

사실 이는 f가 아닌 F에서도 동일하기에, "합집합 공리와 짝 공리가 보장됨 공리"는 외연공리가 성립하는 F에 대해서 다룰수 있다면, "`h̅ = (F, g) ⊨ (∃F⁻¹(h(A)∨h(B)))`"이다.

치환 공리꼴(Axiom Schema of Replacement)의 다른 표현을 보자, 치환 공리꼴이란 무엇일까? 한마디로 치환 공리꼴은 함수 h에 대해, {h(x) | x ∈ A}의 존재성은 A가 존재해야 보장돼야한다는것이다. 한마디로, ∃A ⇒ ∃{h(x) | x ∈ A}이다. 이때, f({h(x) | x ∈ A})(x) = (∃v ∈ A)((h(v) =)(x)) = ((∃v ∈ A)(h(v) =))(x) 이므로, {h(x) | x ∈ A} = f⁻¹(((∃v ∈ A)(h(v) =)))에서, ∃A ⇒ ∃f⁻¹(((∃v ∈ A)(h(v) =)))임이 치환 공리꼴과 동치이다, 따라서, 치환 공리꼴에 따라 치환 공리꼴의 다른 표현 `∃A ⇒ ∃f⁻¹(((∃v ∈ A)(h(v) =)))`은 치환 공리꼴이 보장될때 항진이다.

치환 공리꼴도 f가 아닌 F에서도 동일하기에, 외연공리가 성립하는 F에 대해서 다룰수 있다면 "∃A ⇒ ∃F⁻¹(((∃v ∈ A)(h(v) =)))"이다.

분류 공리꼴(Axiom Schema of Separation/Specification)은 성질 Φ를 만족하는 부분집합이 존재한다는거다, 성질 Φ를 만족하는 부분집합이 존재한다는뜻은 ∀S ∃{x |(Φ(x)) ∧ (x∈S)}이며, ∀S ∃{x |(Φ(x)) ∧ (x∈S)} ≡ ∀S ∃{x |(Φ(x)) ∧ f(S)(x)}이고, ∀S ∃{x |(Φ(x)) ∧ f(S)(x)}라는건 ∀S ∃f(P) = Φ∧f(S)임과 동치이기에, 분류공리꼴에 따라 분류공리꼴의 다른 표현 `f(P) = Φ∧f(S)`은 분류 공리꼴이 보장될때 항진이다, 이후에 분류 공리꼴을 이용하여 집합론에 대해 논하겠다.

ZF안에 ZF를 만든다고 가정하면, 범주론적으로(함자에 대한 서술로) 접근할때, "∃A ⇒ ∃F⁻¹(((∃v ∈ A)(h(v) =)))"안에서 "h̅ = (f, g) ⊨ (∃f⁻¹(h(A)∨h(B)))", "∃A ⇒ ∃F⁻¹(((∃v ∈ A)(h(v) =)))"가 성립한다, 그러나 이것은 ZF내의 ZF에서만 성립한다. `"메타언어가 서술하는 "내부언어에 관한" 구문"`꼴이기 때문이다.

따라서,
ℙ1 : "∃A ⇒ ∃F⁻¹(((∃v ∈ A)(h(v) =)))"
ℙ2 : "h̅ = (f, g) ⊨ (∃f⁻¹(h(A)∨h(B)))"
를 따로 정의하겠다.

공집합 공리(Axiom of Empty Set)와 같은뜻인 명제를 보자, `(∃S ∀x)(￢(x∈S))` ≡ `(∃S ∀x)(￢f(S)(x))` 이고 `(∃S ∀x)(￢f(S)(x))`와 같은뜻인 명제 `(∃S ∀x)(f(S)(x) = F)`는 `x⊥y = x⊥ = ⊥y = ⊥ = F`인 `⊥`정의에따라서, `(∃S)(f(S) = ⊥)`임과 동치이다, 즉, `∃f⁻¹(⊥)`은 공집합공리와 동치이기에, 공집합 공리에 따라, 공집합 공리의 다른 표현 `∃f⁻¹(⊥)`은 공집합 공리가 보장될때, 항진이다.
무한 공리 (Axiom of Infinity)는 자연수 집합의 존재성을 보장하는 공리이다. "모든 자연수 x에 대해, (∃ℕ)(f(ℕ)(x))"는 무한공리와 같다,

정칙 공리 (Axiom of Regularity / Foundation)는 랭크 함수 Rank의 존재성을 보장한다.

이때, 무한 유향 비순환 가중 그래프 preZFSetThoeremModel에 대한 중복도 W를 정의하고, W(x, y) := int(x ∈ y)로 정의하면, (또한, 동시에, 멱집합의 존재도 보장하여 구성하면,)

멤버십 관계 ∈는 분류 공리꼴을 이용하여, 다음과 같이 재정의된다 ((x ∈ y) s.t. (x ∈ y) when (h(x) = Φ(x))) := F(y)(x) s.t. (∀P ∈ 2ᴬ)(F(P) = h(P)∧F(A)) (단. F는 가능한 한 전단사인 표기법이며, 현제의 정의에서 (∃h(P), F(A) ⇒ ∃(x ∈ y)라고 치역이 정의된다)
이는 분류 공리꼴을 만족시키는 정의이다.

preZFSetThoeremModel들 중에서, ℙ1, ℙ2를 만족시키는 preZFSetThoeremModel를 ZFSetThoeremModel라 할수 있는데, 이들 중 공집합과 자연수를 이론 내부에서 논하는 집합으로 가지는 ZFSetThoeremModel는 메타 언어로 동작할 수 있고, ℙ1를 만족시키는 preZFSetThoeremModel들 중에서 공집합과 자연수를 가지는 preZFSetThoeremModel는 ZFSetThoeremModel와 위계 이외엔 동등하다.

더 나아가서, 상수로써 자연수와 공집합을 가지고, 멱집합 연산과 ℙ1, ℙ2를 구성하는 연산이 정의되는 튜링 언어를 이용하는 형식문법 G 문법의 형식언어 L의 모델은 preZFSetThoeremModel이다. 따라서 FOL에서 HOL로 확장가능한 대수공리계에서 모델론과 구문론과 집합론과 논리까지 싹다 서술 가능하다면, preZFSetThoeremModel도 서술 가능하므로, 그런 대수공리계는 ZF와 동등하다. (이러한 모델의 존재성이 참이 된다는 전제하에)
```

저러한 대수 공리계는 존재한다, 예컨데 alkalic이 그렇다.

Königsberg Axiom은 alkalic을 구성하여, 저 조건을 만족한다. 따라서 ZF공리계와 Königsberg Axiom체제 (25.07.16 커밋 이전)는 ZFC랑 그 능력이 동등하다. (상호 서술)

VectorAxiom은 AC와 동치이다, 따라서 Königsberg Axiom + VectorAxiom은 ZFC와 동등하다. (상호 서술)

이때 다음 공리를 도입하자, 아래 공리계는 Alkalic-LinearAlgebra의 ZFC로 구성되었다
⊢ InaccessibleCardinalExistanceAxiom : ∃κ cf(κ) = κ ∧ κ > ℵ₀ ∀λ<κ, 2^λ < κ [cf(x) := least δ ∈ Ord s.t. ∃f : δ → x, (∀i < δ)(f(i) < x) ∧ (∀α < x)(∃i < δ)(α < f(i))]

이때 κ가 Alkalraum의 구성에 쓰인다.

Alkalraum은 κ로 그 크기가 확장된 Alkalic-LinearAlgebra의 객체를 Scala에 포함하는 Hilbertraum같은 (((Scala^κ)^κ)^....)^κ식으로 구성된 κ Rank Covector공간이며, 복소수나 분발복소수/이원수나 2ⁿ원수 등의 행렬표현에서 그 원래 집합의 원소 역할을 하는 객체로의 대응된것 등이 있을수 있는 실수 및 함수 및 객체들로 된 선형대수 텐서공간인데, κ크기를 보장하기에, Grothendieck 우주가 존재하는 ZFC를 표현할수 있어, 여기서 SetTheorem은 자동으로 Grothendieck 우주가 존재하는 ZFC로, 범주론이 서술된다.

## About

이전에 나온 CSFBAlgebra에서 모델론이 안먹히나 했는데 먹힘, 그래서 아이 새로 CSFBAlgebra를 정리(바꿈), 그게 Alkalic.

M = (ℕ, 0 = ∅, s(x) = x ∪ {x}) 대신

수열의 곱을 다가함수로 써서,

M = Π<ℕ, [0 := ∅], [s := λx. x ∪ {x}]>

같은 서수의 정의가 가능하다는 점에서,

이제 Structure와 변수 대입까지 함수 안에서 됬음.

이제 구조체도 non-structial 논리적 귀결에서 씀으로 쓸수있음

에초에 CSFBAlgebra를 대체할 목적으로 만든거니

나머지는 이하 생략.

### Alkalic-Proofmood

KönigsbergAxiom 에 따라서, 

 > 
 > 규칙 `using x = y → (Φ ↔ (Φ [x := y])))`
 > 
 > 원리 : `x = y → (Φ ↔ (Φ [x := y])))`서 `x = y`가 결론 (5번 라인)과 같음을 보임
 > 
 > ```Alkalic-Proofmood
 > □.1. using x = y → (Φ ↔ (Φ [x := y])))
 > □.2. x = y
 > □.3. Φ
 > □.4. Φ [x := y]
 > □.5. Φ ↔ (Φ [x := y])
 > ```

모든 추론은 규칙 `using x = y → (Φ ↔ (Φ [x := y])))`에서 시작되며, 규칙 `using x = y → (Φ ↔ (Φ [x := y])))`는 기본적으로 modus ponens 추론 규칙을 따르기에 타당 (valid)하다. (심지어 Königsberg Axiom이 항진인데, Königsberg Axiom을 제외하고는 대수 연산밖에 활용하지 않기에, alkalic은 건전하다)

(전건부정의 오류 하나 있어서 삭제함)

내부적으로 결론(5번 라인)이 참일때만 계속 동작함, 또한 결론은 리스트에 쌓이면서, 마지막 줄인 Theorem에 도달할때까지 Lemma가 리스트업되서, 문장이 참인지는 Lemma로 보임.

 > 
 > 규칙 : `Starting Listup Hyperthesis`
 > 
 > 미리 Hyperthesis나열을 시작함
 > 
 > 규칙 : `Quit Listup Hyperthesis`
 > 
 > 더이상 Hyperthesis를 받지 아니함
 > 
 > 규칙 : `Starting Another Subproof`
 > 
 > 새 스택프레임을 만들어, 새로운 부분증명을 시작함
 > 
 > 규칙 : `Quit Another Subproof`
 > 
 > 부분증명을 끝내, Lemma List에 추가하고, 스택프레임을 pop함
 > 
 > 규칙 : `APAristotel-y` (nonHyperVersion 형식증명 only)
 > 
 > HAPA Theorem이라는 외부정리를 이용하여서, y = x이고 y = z이면 x = z임을 보임
 >
 > 규칙 : `APAristotel-z` (nonHyperVersion 형식증명 only)
 > HAPA Theorem이라는 외부정리를 이용하여서, x = z이고 y = z이면 y = x임을 보임
 > 

### HAPA Theorem (Hyper Alkalic-Proofmood Theorem)

Alkalic-Proofmood nonHyperVersion 형식증명의 근거.

동시에 유일한 Alkalic-Proofmood HyperVersion에서의 형식증명

`y = x`, `y = z`가 가설일때,

규칙 `using x = y → (Φ ↔ (Φ [x := y])))`를 통하여, `y = z ↔ x = z`를 보인다, 즉,

문법상, `y = z → (y = z ↔ (y = z [y := x]))` = `y = z ↔ (y = z ↔ x = z)`이므로, 

y = z ↔ (y = z ↔ x = z)를 표현하기 위한 잉여적인 체계다.

(그치만 이전에 있었던 전건부정 오류때문에 또 고쳐야함 ㅠㅠ)

## Alkalic-Proofmood (Power Up - Version)

증명에 앞부분에 붙여야 할 한정사가 추가되었다, 부분증명을 만들어서 중첩 가능하기에, 각 기능을 동시에 붙일수 없다.

 - AristotelProof(비 명시시 기본) : 기존 증명 방식으로 증명
 - DavidHumeProof : Φₜ에 대해, t번 라인마다 매거적 귀납법을 쓰고, 옆 열에는 Φₜ가 귀납법 증명에 쓰이는 경우, 쓰는 칸이 된다. 맨 마지막줄에, 번호 없이, 귀납법 증명의 종류를 기재할때, `∴ Φₜ, Φₜ₊₁, ..., Φₖ ⊨ Φₖ₊₁` (강함), `∴ Φₖ ⊨ Φₖ₊₁` (약함), `∴ Mod(Φ) = ℕ` (일반적인 수학적 귀납법) 으로 기제한다.
 - EuclidianProof : 귀류법 (HegelianProof랑 다르다, 귀류법이다) ; 반증 마지막에, `∴ ⊥ ∴ ⊭ ¬
Φ ∴ Φ`를 놓는다. (`¬Φ`는 결론을 뜻한다.)
 - HegelianProof : 반증 (결론이 부정이 나오므로, "결론이 아니다"를 증명할때 쓰임; 왜냐하면, 기존 버전에서는 논리적 오류가 나오면 오류위치를 지적하고 프로그램이 종료됬기 때문에, 오류를 만들어 반증한 후, 종료하지 않는 AristotelProof가 필요했음)



또한 검증 프로그램 정지를 피하기 위해,

 - PreviewVersion : 이 부분•전체 증명에 대해서, 프로그램 정지 후 오류 지적을 제외하고, Preview리스트에 추가한다, 근거 없는 부분이라, 이걸 단 증명을 참고해서 에러나면, "Referance on Preview"에러 로그를 따로 뱉은 후 평상시 에러처럼 에러난다
 - DebugVersion : 오류가 나는대로, 디버그를 해주며, 훓고 지나간다, **프로그램 전체에 적용된다.**
 - ConjureVersion : 추측으로써, 정지를 피할곳에, `�`를 삽입한다, 이 부분•전체 증명은 가설(Hyperthesis)로 취급된다.
 - NormalVersion (비 명시시 기본) : 기존 방식



마지막으로, 다항식의 계산을 원활하게 하기 위해,

`Polynomial Simplify`라는 부분증명 폼을 넣고 다음을 인수분해하거나, `P(x) = 0`꼴을 풀면 (후자는 미리 `using P(x) = 0 Algorithm`이라고 명시) 오류 없이 증명을 받아들여준다.

A. `LinearSimplify`명령을 통해, LinearSimplify Theorem에 근거하여, 미지수가 여러개인 일차식을 정리한다

B. `Substracting [y := xⁿ]`명령을 통해, xⁿ을 y로 치환한 문장 `Φ`에 대해, `Substracting Variable`필드에 넣은 참인 문장 `y = xⁿ`에 따라서, Φ [y := xⁿ]가 나올때까지, 미리 일차식마냥 치환한 상태로 작업하게 해준다. (치환 변수 필드 논법; `Substracting Variable Field Proofs`)

C. `Solution (a, b, c, d, e)`명령을 통해, 2차 ~ 4차식을 인수분해(근의공식) / 전개(비에트의 정리)한다.

D. `TschirnhausTheoremSubsituate (n, a, b, x)`명령을 통해, `[x := t + b/na]`를 적용한다, 마찬가지로 증명의 원활함을 위해 Substracting명령에 근거한다 (사실 그럴 필요도 없이 구문론적으로 연산자를 정의해도 되는 간단한 문장(`[x := t + b/na]`)이지만)

E. 부분증명 문법에서 `synthetic division` 한정사로, 조립제법 이용 (생략표기가, 매거적 귀납에서 고정된 열의 다수의 행에대해 쓰이므로, 여기서는 쓸때, 행을 다항식으로, 계산 과정순이 열로 되므로, 돌려봐야하는 단점이 있다.)

F. `Alright synthetic division`한정사로, 일반적인 조립제법을 쓰고, 전처리 단계에서 synthetic division로 컴파일

G. 분배법칙을 위해서, `distribute[ 대상 ]` 안에 전부 넣어가지고, 이 증명 시스템용으로 있는 `분배법칙의 일반화 정리`에 따라, 분배함

H. `AlgebraicFormula` : 미리 증명한 곱셈공식을 이용해서, 계산되었음을 명시한다.

I. Gaussian Eimination or ERO & Subsituate : 가우스 소거 혹은 가감/대입

J. System of Quadratic Equations by Quadratic Form : 이차형식으로 연립이차방 풀이

K. System of Quadratic Equations by Cubic Form : 삼차형식으로 연립삼차방 풀이

L. Règle de Cramer : 크래머의 공식으로 풀이

M. `Extraneous Root is (□)` : 무연근 명시

N. `PolynomialFractionize` : 다항함수 분수화

O. `SolvePolynomialFraction` : 해당값 풀이

P. `Fractions Solution is (□)` : 해 명시

### 형식증명의 오토마타용 문법

`□.` 라인이 부분증명이라면, `□.line.`식으로 라인을 표기한다.
그리도, 라인과 라인 사이에 오직 whitespace및 `-`,`–`,`—`만 있을경우 해당 라인을 가독성 용도로 보고 주석처리한다.

또한, line표기에 앞선 점찍은 부분 앞에서 `|`부분이 문자열의 특정 열마다 이어지고, 끝나는 말단이 앞서 설명한 `-`꼴의 주석에 연결되어있다면, 해당 부분도 따로 오류처리하지 않는다.
그외에는, 열 구분자이기에 주석으로 보지 않는다

마지막으로, `[NOTE : ]`형식을 주석으로 본다.

마크다운 문서 내부에 위치했다면, HAlkalic-Proofmood(Hyper Version), Alkalic-Proofmood(일반 버전), PowerAP(Power Up버전)으로 코드 이름인 부분만 읽는다. 또한, 마크다운 부분에 부분증명 코드부분은, 부분증명으로 렌더링한다.

마지막으로 그렇게 html화되어 정리된 렌더링 뷰는, LaTeX 표기 기능을 추가해야만 할것이다.

(그럼에도 해당 html뷰는 아직 형식증명 검토가 안돌아갔으므로, 컴파일 상태인거지, 실행 상태가 아니다. 실행은 실행기에 돌려야, 문서 내부를 파싱해서, 부가적으로 제공된, [labare](https://faraway6834.github.io/unbeauty/privateNote/Proof/labare)•[unbare](https://faraway6834.github.io/unbeauty/privateNote/Proof/unbare) 코드와 함깨 해석하여(labare•unbare는 인터프리터 언어가 아니고, 정형 대이터 겸 사용자 편의 대이터 겸 Low Level 컴파일 언어다.), 검토된다; 이제보니 실행기보다는, 형식증명 검토기라는 명칭이 더 적합하다, 프로그래밍 언어는 하나도 실행하지 않고, 추론규칙을 재대로 활용했는지만 검사하여 검토작업(오류나 로그나 상태 표시)만 하기 때문이다.)

---

### 두번째 글 : `논리적으로 다룬다 전재할때, 대수식은 논리적으로 그 뜻이 해석 • 계산된다.`의 발췌

그렇지 아니하면, 논리적 해석 흐름에서 논리기호가 도출될수가 없다.

식의 계산은 그 값의 배정인 (x̄, f(x̄))와 같이 이루어지는데, 이 방식을 거부하는것은, 논리를 쓰지 않겠다는 말과 같다. (장자 왈 갓나서 죽은 아기보다 오래 산 사람은 없으니 팽조(760살이 넘게 살았다는 전설 상의 신선)도 일찍 요절한 사람)

#### 대수식의 논리적 해석 흐름에서 논리기호를 도출하자

먼저, 다음을 보이겠다

> 함자 `f :≜ (-F)` 를 정의해서, 여기에 대해,

`x = y 이면이 f(x) = f(y)`

이말은, 진리값 T, F를 다루는 식에서, F = 0으로 가정하고 푸는거나, F ≠ 0이 아닐때 푸는거나, 전부 x = y인 등식을 쓸때 f(x) = f(y)가 F와 무관히 동등함이 당연함으로, F = 0인 경우로 잠정적으로 취급하겠음

##### 대수식의 논리적 해석 흐름중 논리적 귀결관계의 도출

Step.1. 방정식을 만족하는 집합으로써의 모델집합이 해집합임을 보이자

먼저, 다음과 같은 다항식 함수 P를 정의하자.

> `P :≜ λA. λx. Πᵢ x - Aᵢ`

그리고 다음과 같은 방정식화 논리함수 Φ를 정의하자.

> `Φ :≜ λf. (f(x) = 0)`

그리고 마지막으로, 다항 방정식 ㅍ을 정의하겠다.

> `ㅍ :≜ φ • P`

그러면,

> `Mod(ㅍ(A)) = {x | x ⊨ (Πᵢ x - Aᵢ = 0)} = {x̄ | Πᵢ x̄ - Aᵢ = 0} = {Aᵢ | ∀i}`

임이 당연하다.

---

Step.2. 논리적 귀결관계의 도출

다항방정식 ㅍ(A), ㅍ(B)에 대해,

0. Mod(ㅍ(A)) ⊆ Mod(ㅍ(B))
1. {Aᵢ | ∀i} ⊆ {Bᵢ | ∀i}
2. ∀i Aᵢ = Bᵢ《주의 : 비약이다, 저건 배열을 정렬해야만 성립한다.》
3. ∃C P(B) = P(A)P(C)
4. P(A)|P(B)

으로,

> 
> 다항식 f, g에 대해 다항방정식 Φ(f) ⊨ Φ(g)
> 
> 이면이
> 
> f | g
>


##### 대수식의 논리적 해석 흐름중 진리값 배정되는 명제논리 결합자의 도출

¬x = T - x로 해석됨을 보이자. (경고 : 형식증명 아님)
A. proof of `x ≠ T ⊢ T ± x ≠ (1 ± 1)T`
0. `x ≠ T` (비 귀류법식 전제 문장)
1. `T ± x ≠ T ± T` (이항 by 함자 `(T ±)`)
2. `T ± x ≠ T ± T = (1 ± 1)T` (1번의 연장선에서 계산)
3. `T ± x ≠ (1 ± 1)T` (2번에서 식 요약) ⋯ ■

B. proof of `⊭ (1 + 1)T = 0 ∨ (1 + 1)T = T`
0. 먼저 part A by `⊭ (1 + 1)T = 0`와 part B bt `⊭ (1 + 1)T = T`로 나눠서 생각하자.
1.A. (1 + 1)T = 0 (귀류법식 전재 문장)
2.A. (1 + 1)T = 2T = 0 (1.A.번의 연장선에서 계산)
3.A. T = 0 ⊨ 2.A. ⊨ (1 + 1)T = 0 (연역)
4.A. ⊭ T = 0 ⊨ 2.A. ⊨ (1 + 1)T = 0 (연역)
5.A. ⊭ (1 + 1)T = 0 (연역) ⋯ ⊥
6.A. ∴ ⊭ (1 + 1)T = 0 (연역) ⋯ ■
1.B. (1 + 1)T = T (귀류법식 전재 문장)
2.B. (1 + 1)T = 2T = T (1.B.번의 연장선에서 계산)
3.B. T = 0 ⊨ 2.A. ⊨ (1 + 1)T = T (연역)
4.B. ⊭ T = 0 ⊨ 2.A. ⊨ (1 + 1)T = T (연역)
5.B. ⊭ (1 + 1)T = T (연역) ⋯ ⊥
6.B. ∴ ⊭ (1 + 1)T = T (연역) ⋯ ■

C.1. A, B ⊨ (x ≠ T ⊢ T - x ≠ (1 - 1)T) (A, B번에서 귀결)
C.2. A, B ⊨ (x ≠ T ⊢ T - x ≠ (1 - 1)T = 0T = 0) (C.1.번의 연장선에서 계산)
C.3. A, B ⊨ (x ≠ T ⊢ T - x ≠ 0)  (C.2.번에서 식 요약)
C.4. A, B ⊨ (T - x = 0 ⊨ x = T ⊨ x) (C.3.번에서 연역추론 : 대우) 《주의 : "x = T"의 의미를 "진리값 x가 참"관점으로 해석함.》
C.5. A, B ⊨ (T - x = 0 ⊨ x) (C.4.번에서 식 요약) 《주의 : 근거인 C.4.에서 "x = T"의 의미를 "진리값 x가 참"관점으로 해석함.》
C.6. C.5.번 내용 ⊢ ¬x = T - x (최종결론)《주의 : "x = T"의 의미를 "진리값 x가 참"관점으로 해석함.》
Q.E.D.

x ∧ y는 xy로 해석됨을 보이자.
T에대한 방정식 (T - x)(T - y) = 0의 해는
x = T ∨ y = T이다.
따라서, x = T ∨ y = T ⊨ T - (T - x)(T - y) = T고,
x ∨ y = T - (T - x)(T - y)로 해석된다.

이때 De Morgan's Law, ¬(¬x ∨ ¬y) = x ∧ y서

T - T + (T - T + x)(T - T + y)
 = xy이다.
 ⋯ Done.

##### 방정식의 의미 : 술어논리(함수논리)의 술어로써, 잠정적으로 특칭양화사를 사용해, 잠재적으로 전칭양화사를 사용함.

방정식 P(x) = 0이 불능이란것은

∄P(x) = 0란 뜻이며

∀P(x) ≠ 0이란 뜻이고 ⋯ ①



방정식 P(x) = 0가 불능이 아니라면

∃P(x) = 0이다. ⋯ ②



방정식 P(x) = 0이 부정이란것은,

부정방정식이므로,

∀P(x) = 0이다. ⋯ ③



①에서, 불능형 방정식 P(x) = 0에 대해,

P(x) ≠ 0은 부정형이고, ⋯ ④



부정형 방정식 P(x) = 0에 대해,

P(x) ≠ 0은 불능형이다 ⋯ ⑤


그렇다면 ③에 따라 다음을 정의하자,

> `Φ :≜ λf. (∃f(x) = 0)`
> 
> `P :≜ λf. (∃f(x) ≠ 0)

그러면 다음을 알수 있다.

④에 따라, Φ(f)가 거짓 이면이 P(f)는 부정형
⑤에 따라, Φ(f)가 부정형 이면이 P(f)는 거짓

Φ(f)가 참 이면이, f(x) = 0를 만족시키는 x존재
P(f)가 참 이면이, f(x) = 0을 불만족시키는 x존재

부정형 방정식을 만들고 싶다? 하면

¬Φ(f) = P(f), Φ(x) = ¬P(f)에서,

불능형 방정식 Φ(f)에 대해 부정하거나,
불능형 방정식 P(f)에 대해 부정하면된다.

술어 P에 대해
Mod(P) = ∅ 이면이 ∄P(x) 이면이 ⊭ P
이면이
Mod(¬P) = U 이면이 ∀¬P(x) 이면이 ⊨ ¬P

따라서, 방정식은 기본적으로 특칭 술어로써, 사용할수 있음
````

## Lava

````markdown
# Lava System

N.B. ATTENTION, WARNING, NOTE(IMPORTANT), WATCHOUT, TIP, DECLARE, READIT : 만족•귀결기호 `⊨`가 존나 흥건히 나오지만, 그건 만족•귀결의 의미로 의미론적으로 같아 해석하여 이해하면 "변인에 대한 값의 할당"을 「만족」과 「명제의 귀결」로 구체적으로 이해해보자 • 그리고 하게 할 것의 목적이며, 정의 기호와의 혼용은 전혀, 전혀, 전혀 없이, 잘 쓰여있다. 간혹 정의같이 나온다면, 정의의 의미를 가진 귀결로, 귀결에는 오류가 없다 단언한다. 미지막으로, `≜`가 나올것같은데에 `⊨`를 쓴거는 바로 당신이 문맥으로 읽다가 뒤통수맞은거다... 수학을 할때는 문맥을 버려라. 문맥이 아닌 형식주의적인 조작이기 때문에, 진짜로 `⊨`를 써서 설명했기 때문이다. 정의가 아니라 만족 혹은 귀결을 썼다면 문자 그대로 이해해야한다. 그것이 참이기 때문이다. (글 읽을땨마다 이곳을 참고헐것)

(내가 추상대수학 배우려고 만든 체계)

닫힌형태의 대수구조를 폐구조라고 명명하고, Lava라고 부르겠음.

관계가 주어지지 않은 n개의 함수와 m개의 심볼을 가진 Structure

M = <D, Sym₁, ..., Symₘ, fun₁, ..., funₙ>를 (m, n)-Lava라고 하겠음

(m, 0)-Lava는 (심볼을 정의한, 즉 정의용) 집합인 기본적인 대수구조이다.

참고로, (m, 1)-Lava이상은, 각 연산이 전부 D와 마그마를 이룬다.

Volcanoₘ,ₙ(D, Sym₁, ..., Symₘ, fun₁, ..., funₙ) ≜ <D, Sym₁, ..., Symₘ, fun₁, ..., funₙ>

라 하겠다.

Volcano는 (m, n)-Lava를 생성하는 무한 차원의 (= 행과 열의 총 길이가 자연수 기수 길이인) 함수행렬이다.

그래서 (=행렬이기 때문에) Volcanoₘ,ₙ식으로 표현한거다.

Volcanoₘ,ₙ은 (m, n)-Lava를 구성하는 함수이다.

이하에서 대부분 저런 행렬 형식은 인자가 무제한으로 (= 자연수 기수 크기까지인 무한정 = ℵ₀가 최대길이인것임)

예컨데, Volcano₂,₀(𝔹, F, T)는 부울-도메인으로 유명하다.

내가 스스로 정의한
Lava에서 확장한걸로 구조꼴 (structure form)이라는게 있는데, 아래와 같다.

StructureFormₗ,ₘ,ₙ(D, Sym₁, ..., Symₗ, fun₁, ..., funₘ, Pre₁, ..., Preₙ) ≜ <D, Sym₁, ..., Symₗ, fun₁, ..., funₘ, Pre₁, ..., Preₙ>

Pre₁, ..., Preₙ는 술어이고, 이게 뭐하나 미스되지 않고, Lava랑은 달리 있을거 다있게 정의된 구조의 최소 단위이므로, 이를 "구조꼴"이라고 하고, 삼차원 행렬 (= 이제 텐서 ㅋㅋㅋㅋ) StructureForm를 통해 만들 수 있다.

텐서라고 웃은 맥락은, 행렬은 이차원 텐서라고들 해서, 삼차원 행렬이 텐서라고 말한거긴 하다.

(근데 나 멀미나와서 오늘은 여기까지 작성하겠고, 추상대수학은 여기까지 배우겠음.)

StructureForm이 삼차원 행렬이기에, StructureFormₗ,ₘ,ₙ식으로 쓸 수 있었던것이다.

(l, m, n)-구조꼴을 생성하는 함수는 StructureFormₗ,ₘ,ₙ이다.

## 대수 구조 공부

### 참고 함수

참고사항일 뿐이다...

뭐...

#### limer 함수 lime

limer [발음 : limmiter [리미터], limer [리머], 약칭 : lime] 함수 lime (limer는 너무 이름이 길어서 라임(lime)이 됨)

+ `lime ≜ ((st◦)◦lime*◦(st⁻¹◦))`
+ `lime* ≜ (◦(+ε))`

> 참고 : `lime(f) = ((st◦)◦lime*◦(st⁻¹◦))(f) = (st◦)(lime*((st⁻¹◦)(f))) = st◦lime*(st⁻¹◦f) = st◦lime*(f*) 이고, lime*(f*) = (◦(+ε))(f*) = f*◦(+ε)이며, (f*◦(+ε))(x) = f*((+ε)(x)) = f*(x + ε)이므로, lime(f) = st◦lime*(f*)이고, lime*(f*)(x) = f*(x + ε)이며 (st◦lime*(f*))(x) = st(lime*(f*)(x)) = st(lime*(f*(x))) = st(f*(x + ε)) = lim f(t) (t → x)에서, 당연히 lime(f)(x) = st◦lime*(f*) = lim f(t) (t → x)인, 즉 극한을 취해주는 함수임 (주의 함수st⁻¹(f) = f*는 그저 transfer원리를 통해 초실수로 확장하는 f*과정을 은유적으로 표현한것. 사실상 "g(f) = f*"인 g로 고쳐야함.)`

특징 : `점 불연속을 복원함, 초실수체에서 lime* f는 "불연속 이면이 도약 불연속"임. 진동의 경우에는 유한 초실수의 종류에 따라 구간에서의 선택이 달라지기에, 사실 "불연속 이면이 진동 혹은 도약 불연속"임. (극한이 논리적으로 aproximate하게되어 진행중인것처럼 취급되는지, 아니면 그 논법을 숫자로 압축시켰는지 차이로, 실수에서는 수가 무한까지 크게 잡아져있지 않고, 초실수는 무한이 있어서, 실수에서 무한으로 발산해서 끊어지는게 초실수에서는 안 끊어지는, 연속적 • 위상적 관점에 특징 때문에, 제거 가능한 불연속인 점 불연속 이외의 도약 불연속만이 유일한 후보가 되는 원리, 그리고 도약 불연속에서 좌극한과 우극한은 다름. 그러나 실수에서는 끊어져 버리기에 연속이 아님.), FOL에서는 d/dx f* = ((lime* f*) - f*)/ε 인 성질에 따라서, FOL에서, 미분에 활용 가능 (또 여기서 알수있는 특징이, f가 연속 이면이 ((lime* f*) - f*)/ε가 연속. (주의 : f는 실함수로, 가 점 불연속과 도약 불연속과 발산 불연속과 진동이 아닐때 연속이고, f*이 연속이어도, f가 연속이 아니면 이계도함수를 만들수 없을수 있음) 초실수 범위에서 발산불연속이 상쇠되기에 연속이면 미분가능.) (또한, (((lime* f*) - f*)/ε)(x) = ((lime* f*)(x) - f*(x))/ε = (f*(x + ε) - f*(x))/ε 으로써, x = 0에서 f*(0) = Ω = undefined이거나, x = ε일때 진동하여, ε의 종류마다 달라지거나, f*가 점 불연속일때도 제거해주지 않으면, 그 점에서 미분 불가능하므로, (lime* f*)의 도함수에서, 실함수 f의 모든 불연속점을 정의 불가능으로 새로 규정해줘야 f*의 도함수임)`

### 성질 목록

아래 술어들은, Lava M 혹은 특별한 대상 M에 대해, 

M ⊨ Φ : "M이 성질 Φ를 만족한다"

라고 하는 술어 Φ들이고, 성질이라고 부른다.

사실 술어랍시고 써놨는데

1. 죄다 자유변항만있고, 종속변항은 없는것은 "참성질"이라고 부르고, 걍 사실상 문장명명이다.
2. 자유변항이 존재하고, 종속변항도 존재하는것을, "가성질"이라거 부르고 걍 사실상 술어다.

참성질과 가성질의 `참-`, `가-`는 참다랑어와 가다랑어에서 따왔다.

참성질을 법칙성질, 가성질을 성질부분이라고도 한다. (이것도 근데 방금 만든 조어다)

~배고프니까 천장에서 다랑어가 쏳아졌으면 좋겠다~

참고로 특별한 대상 M에 대해 다루는 경우는 `특-`을 붙여서 "특성질"라고 한다. 왜냐하면 이 특별한 대상은 "대수구조가 아니라 집합이나 순서쌍 혹은 함수다"

#### 결합법칙 (associative property)

결합법칙 Associative는 다음과 같은 법칙성질(참성질)이다.

Associative : "(a * b) * c = a * (b * c)"

#### 중가환 법칙 (medial property)

중가환 법칙 Medial은 다음과 같은 법칙성질(참성질)이다.

Medial : "(m * n) * (p * q) = (m * p) * (n * q)"

#### 교환법칙 (commutative property), 혹은 가환(commutative)

교환법칙 Commutative는 다음과 같은 법칙성질(참성질)이다.

Commutative : "a * b = b * a"

#### 좌역원임-가술어 (tunal is-leftinvers-of Predicate)

좌역원임-가술어 tunalIsLeftinversOf는 내가 방금전에 명명한 가성질이다.

가술어를 tunal 서술어를 붙이는 이유는 tunna-al (다랑어-적)이라는 뜻으로 가술어임을 말하기 위해서다. 이유는 가성질 • 참성칠 명명 유래 참고.

tunalIsLeftinversOf(e, b, a) : "b * a = e"

e = eₗ으로 대입해서 생각한다면, 좌항등원이 항등원인 좌역원임-가술어라고 하며, e = eᵣ이면 우항등원이 항등원인 좌항등원-가술어라고 한다.

해당사항은 하단의 우역원임-가술어에서도 통용된다.

(좌항등원과 우항등원의 정의는 항등원을 정의한 색션을 참고하라, 물론 상식이므로 참고하지 않는게 정상이다.) (심볼정의 문단의 항등원 참고)

#### 우역원임-가술어 (tunal is-rightinvers-of Predicate)

우역원임-가술어 tunalIsRightinversOf는 내가 방금전에 명명한 가성질이다.

tunalIsRightinversOf(e, b, a) : "a * b = e"

#### 좌역원임-술어 (is-leftinverse-of Predicate)

좌역원임-술어 isLeftinverseOf는 내가 방금전에 명명한 가성질이다.

b isLeftinverseOf a : isLeftinverseOf(a, b) : 항등원이존재함(eₗ, eᵣ), tunalIsLeftinverseOf(e, a, b)

로, 좌항등원과 우항등원이 같은 경우의 좌역원임-가술어이다.

(좌항등원과 우항등원의 정의는 항등원을 정의한 색션을 참고하라, 물론 상식이므로 참고하지 않는게 정상이다.) (심볼정의 문단의 항등원 참고)

#### 우역원임-술어 (is-rightinverse-of Predicate)

우역원임-술어 isRightinverseOf는 내가 방금전에 명명한 기성질이다.

b isRightinverseOf a : isRightinverseOf(a, b) : 항등원이존재함(eₗ, eᵣ), tunalIsRightinverseOf(e, a, b)

로, 좌항등원과 우항등원이 같은 경우의 우역원임-가술어이다.

(좌항등원과 우항등원의 정의는 항등원을 정의한 색션을 참고하라, 물론 상식이므로 참고하지 않는게 정상이다.) (심볼정의 문단의 항등원 참고)

#### 역원임-가술어 (tunal is-inverse-of Predicate)

역원임-가술어 tunalIsInverseOf는 내가 방금전에 명명한 가성질이다.

tunalIsInverseOf(e, a, b) : tunalIsLeftinversOf(e, a, b), tunalIsRightinversOf(e, a, b)

로, 좌역원임-가술어와 우역원임-가술어를 모두 만족시키는, 즉, 역원인 경우로써,

이경우도 e에 따라, 항등원이 좌/우 항등원인 역원임-가술어로 말할 수 있다.

### 역원임-술어(is-inverse-of Predicate)

역원임-술어 isInverseOf는 내가 방금전에 명명한 가성질이다.

b isInverseOf a : isInverseOf(a, b) : 항등원이존재함(eₗ, eᵣ), tunalIsInverseOf(e, a, b)

로, 좌항등원과 우항등원이 같은 경우의 역원임-가술어이다.

(좌항등원과 우항등원의 정의는 항등원을 정의한 색션을 참고하라, 물론 상식이므로 참고하지 않는게 정상이다.) (심볼정의 문단의 항등원 참고)

#### 가역원임-가술어 (tunal checking-does-it invertible-element Predicate)

가역원임 가술어 isInvertibleAs는 방금전에 내가 만든 가성질로,

역원 판별논리식 Φ에 대해,

x isInvertibleAs Φ : isInvertibleAs(x, Φ) : ∃y s.t. Φ(x, y)

인 isInvertibleAs로, FOL에서는 술어가 아닌 성질꼴로, 여러가지 성질의 접두사로 동작하며, 그 경우 Φ과 isInvertibleAs를 붙여쓴다.

그러나 권장사항은 SOL에서의 사용이다.

왜냐하면, 내가 FOL로 만들기 디껍고 귀찮기 때문이다.

다만 한가지 주의하기 위해 참고할 점은, ∃y라는 y는 해당 구조의 도메인 위에 있어야 하므로, 닫혀있는 원소인 조건이라는것이고, 따라서, 구조위에서의 의미해석을 해야함에 주의하자.

#### 가역원임-술어 (checking-does-it invertible-element Predicate)

가역원임 술어 isInvertible는 방금전에 내가 만든 가성질로,

x isInvertible : isInvertible(x)

이며,

isInvertible : isInvertibleAs isInverseOf

로써,

x = y, y = z, x = z에서

x isInvertible : isInvertible(x) : x isInvertibleAs isInverseOf : isInvertibleAs(x, isInverseOf)

인 isInvertible로, isInverseOf조건의 isInvertibleAs로 볼수 있으며,

가역원인지 확인하는 술어이다.

#### 전가역성 (Entire-Invertiblity)

전가역성 EntireInvertiblity는 내가 방금전에 만든 참성질 개념으로, "모든 원소가 가역원"을 말하기 귀찮아, 귀차니즘히 심히 많이 도져 귀찮고 괴로워서, 만든 개념이다.

EntireInvertiblity : "x isInvertible"

로써, 모든 x에 대해서 isInvertible인 일반명제임을 술어 Commutative과 같은 경우로 표기했다는 사실로써 능히 알 수 있다.

#### 전사성 특성질 (Surject, 전사성)

전사성 Surject는 치역과 공역이 같은 성질을 말하며,

Surject(f) : codom f = f[dom f]

로써, 모든 정의역 dom f에 대한 상 f,

즉, 치역 Y가 Y = 공역인 경우다.

#### 단사성 특성질 (Inject, 단사성)

단사성 Inject는 정의역과 치역이 일대일로 대응되는 성질을 말하며,

Inject(f) : ∀x, y ∈ dom f, f(x) = f(y) → x = y

로써,

함수 f는 항상 ∀x, y ∈ dom f, x = y → f(x) = f(y)이기에,

Inject(f) ↔ (∀x, y ∈ dom f, x = y ↔ f(x) = f(y))이다.

즉, graph f에서, y값에 대해 x값이 유일하다.

단사성을 만족시키는 함수를 일대일함수라고 한다.

#### 전단사성 특성질 (Biject, 전단사성)

전단사성 Biject는 정의역에 대해 공역이 하나도 빠짐없이 일대일로 대응되는 성질을 말하며, 

모든 공역에 대해 정의역이 하나도 빠짐없이 대응되고,

Biject : Surject, Inject

이다.

즉, 전사이며 단사인것이 전단사다.

전단사성을 만족시키는 함수를 일대일대응이라고 한다.

#### 왼쪽 함자 전단사성 (BijectiveLeftFunctor)

왼쪽 힘자 전단사상이란, 다음과 같은 법칙성질이다.

BijectiveLeftFunctor : "Biject((x *))"

말 그대로 왼쪽 함자가 전단사임을 말하는거다.
참고로, 저기서는 모든 x이 대한 왼쪽 함자이다.
쌍따옴표가 있으니, sentence로써 작동하는것이다.

#### 오른쪽 함자 전단사성 (BijectiveRightFunctor)

오른쪽 힘자 전단사상이란, 다음과 같은 법칙성질이다.

BijectiveRightFunctor : "Biject((* x))"

말 그대로 오른쪽 함자가 전단사임을 말하는거다.
참고로, 저기서는 모든 x에 대한 오른쪽 함자이다.
쌍따옴표가 있으니, sentence로써 작동하는것이다.

#₩# 연속 (continuous)

연속 (continuous)이란, 함숫값과 극한값이 같음을 말한다

continuous(f, Φ) : (∀Φ(x))((lime f)(x) = f(x))

함숫값과 극한값이 정의되어야, 등호의 동등관계가 작동한다.

### 연산 목록

#### 왼쪽 역연산 (LeftInverse)

왼쪽 역연산 LeftInverse은

x LeftInverseOf(`*`) y ≜ (x `*`)⁻¹(y)

으로, 왼쪽 연산에 대한 역연산으로,

역함수가 존재할 조건인 일대일대응일것임을 만족하기위해

왼쪽 함자 전단사성을 만족시켜야 한다.

#### 오른쪽 역연산 (RightInverse)

오른쪽 역연산 RightInverse은

x RightInverseOf(`*`) y ≜ (`*` y)⁻¹(x)

으로, 오른쪽 연산에 대한 역연산으로,

역함수가 존재할 조건인 일대일대응일것임을 만족하기위해

오른쪽 함자 전단사성을 만족시켜야 한다.

### 관계 목록

n항 관계 Φ는 집합 D에 대해, Φ ⊆ Dⁿ이다.

술어 Φ는 집합 D에 대해, Φ ⊆ D이다.

즉, 술어는 단항관계이다.

술어 Φ가 집합 S에 대해, Φ ⊆ S일때,

S = Dⁿ이면 Φ는 n항관계이다.

그렇다. 나는 관계와 술어에 구분을 두지 않을것이고,

따라서, 관계는 나에게 그저 튜플이 만족시키는 술어일 뿐이라는거다.

아래 관계들은, FunctionalRelationship을 이용하여, 이루어지는 관계들에 대해 다룬다.

FunctionalRelationship이란

FunctionalRelationship(f, P, Q) : f[P] = Q

인 술어로, P에 대한 f의 상이 Q인 관계이다.

즉, (∃f, FunctionalRelationship(f, P, Q)) ⊨ R을 만족시키는 R들이다.

(참고 : 앞으로, "학부 수준의 통상적 대수구조에서의~"가 붙을 말은, 에초에 학부 수준을 넘어서 범주론까지 설명하는건 뇌절이라고 보고, 대화 맥락과 주제가 "학부 수준의 통상적 대수구조에서의~"를 전제로 하는 경우를 대부분으로 하여 서술하고싶기에, "다루고자 하는~"이라고 하겠다.

#### 등수관계 (equinumous)

등수관계 equinumous란,

P equinumous Q : (∃FunctionalRelationship(f, P, Q))(Biject(f))

인 관계로, P에서 Q로가는 일대일대응이 존재하는 관계이다.

P equinumous Q ↔ card P = card Q이다.

#### 준동형 (Homomorphism)

준동형 Homomorphism이란, 대게의 경우에는 다음을 만족한다.

Volcanoᵢ,₁(P, Sym₁, ..., Symᵢ, `*`) Homomorphism Volcanoⱼ,₁(Q, Sym₁, ..., Symⱼ, `◦`) : (∃FunctionalRelationship(f, P, Q))(homomorphism(f, Volcanoᵢ,₁(P, Sym₁, ..., Symᵢ, `*`), Volcanoⱼ,₁(Q, Sym₁, ..., Symⱼ, `◦`)) [i := card P][j := card Q]

저건 P와 Q사이의 준동형사상 f가 존재하는 관계이다.

<br>

준동형사상 homomorphism은

homomorphism(f, Volcanoᵢ,₁(P, Sym₁, ..., Symᵢ, `*`), Volcanoⱼ,₁(Q, Sym₁, ..., Symⱼ, `◦`)) : dom f = P, codom f = Q, (∀x, y ∈ dom f, f(x `*` y) = f(x) `◦` f(y)) [i := card P][j := card Q]

이다.

<br>

마그마 이상을 이루는 P, Q에 대해, P에서 Q로 가는 사상 f가 (에초에 처음부터 함수인지 뭔지 제안하거나 명시하지 않았었음) 각각의 연산 `*`, `◦`에 대해, f(x `*` y) = f(x) `◦` f(y)를 만족시키므로, 준동형사상은 대수구조의 성질을 보존한다, 즉, 대수구조의 성질은 준동형사상에 양변을 대입하여, 다른 대수구조로 옮길수 있다.

참고로 모델은 튜플이므로, first(x, y) = x와 last(x, y) = y에 대해,

P와 Q는 first로 구해지며, sym을 넘어서 `*`와 `◦`는 last를 각각 i + 1번, j + 1번 하여 얻어지며, i, j는 P, Q의 카디널리티로 얻어지므로, 정의에서 Volcanoₖ,₁사용부분에 결정성에 문제가 생기는지는 걱정하지 않아도 좋다.

범주론에서 대수적 구조 = 아벨 범주이다.
준동형사상은 아벨 범주 위의 사상으로, 범주론을 다루지 않고자 한 지금의 설명에서는 엄밀한 준동형사상의 정의를 다루기 위해 아벨 범주를 다루고싶지 않기에, 다루지 않겠다.

#### 자기 사상을 낀 관계 (Endomorphism)

솔찍히 이게 등호랑 뭐가 다른지 원.....

Volcanoᵢ,₁(P, Sym₁, ..., Symᵢ, `*`) Endomorphism Volcanoⱼ,₁(Q, Sym₁, ..., Symⱼ, `◦`) : (∃FunctionalRelationship(f, P, Q))(endomorphism(f, Volcanoᵢ,₁(P, Sym₁, ..., Symᵢ, `*`), Volcanoⱼ,₁(Q, Sym₁, ..., Symⱼ, `◦`))) [i := card P][j := card Q]

인 관계로, P와 Q사이에 자기 사상이 존재하는 관계이다.

자기 사상 endomorphism이란,

endomorphism(f, Volcanoᵢ,₁(P, Sym₁, ..., Symᵢ, `*`), Volcanoⱼ,₁(Q, Sym₁, ..., Symⱼ, `◦`)) : homomorphism(f, Volcanoᵢ,₁(P, Sym₁, ..., Symᵢ, `*`), Volcanoⱼ,₁(Q, Sym₁, ..., Symⱼ, `◦`)), dom f = codom f [i := card P][j := card Q]

이다. 즉, Volcanoᵢ,₁(P, Sym₁, ..., Symᵢ, `*`) = Volcanoⱼ,₁(Q, Sym₁, ..., Symⱼ, `◦`))이다.

#### 다루고자 하는 단사 사상을 낀 관계 (Monomorphism)

다루고자 하는 단사 사상을 낀 관계 (Monomorphism) (이)란,

Volcanoᵢ,₁(P, Sym₁, ..., Symᵢ, `*`) Monomorphism Volcanoⱼ,₁(Q, Sym₁, ..., Symⱼ, `◦`) : (∃FunctionalRelationship(f, P, Q))(monomorphism(f, Volcanoᵢ,₁(P, Sym₁, ..., Symᵢ, `*`), Volcanoⱼ,₁(Q, Sym₁, ..., Symⱼ, `◦`))) [i := card P][j := card Q]

인 관계로, P와 Q사이의 다루고자 하는 단사 사상이 존재하는 관계이다.

다루고자 하는 단사 사상 monomorphism은,

monomorphism(f, Volcanoᵢ,₁(P, Sym₁, ..., Symᵢ, `*`), Volcanoⱼ,₁(Q, Sym₁, ..., Symⱼ, `◦`)) : homomorphism(f, Volcanoᵢ,₁(P, Sym₁, ..., Symᵢ, `*`), Volcanoⱼ,₁(Q, Sym₁, ..., Symⱼ, `◦`)), Surject(f) [i := card P][j := card Q]

으로, 단사성을 가지는 준동형사상을 말한다.

#### 다루고자 하는 전사 사상을 낀 관계 (Epimorphism)

다루고자 하는 전사 사상을 낀 관계 (Epimorphism) (이)란,

Volcanoᵢ,₁(P, Sym₁, ..., Symᵢ, `*`) Epimorphism Volcanoⱼ,₁(Q, Sym₁, ..., Symⱼ, `◦`) : (∃FunctionalRelationship(f, P, Q))(epimorphism(f, Volcanoᵢ,₁(P, Sym₁, ..., Symᵢ, `*`), Volcanoⱼ,₁(Q, Sym₁, ..., Symⱼ, `◦`))) [i := card P][j := card Q]

인 관계로, P와 Q사이의 다루고자 하는 전사 사상이 존재하는 관계이다.

다루고자 하는 전사 사상 epimorphism은,

epimorphism(f, Volcanoᵢ,₁(P, Sym₁, ..., Symᵢ, `*`), Volcanoⱼ,₁(Q, Sym₁, ..., Symⱼ, `◦`)) : homomorphism(f, Volcanoᵢ,₁(P, Sym₁, ..., Symᵢ, `*`), Volcanoⱼ,₁(Q, Sym₁, ..., Symⱼ, `◦`)), Surject(f) [i := card P][j := card Q]

으로, 단사성을 가지는 준동형사상을 말한다.

#### 동형 (Isomorphism)

동형 Isomorphism이란,

Volcanoᵢ,₁(P, Sym₁, ..., Symᵢ, `*`) Isomorphism Volcanoⱼ,₁(Q, Sym₁, ..., Symⱼ, `◦`) : (∃FunctionalRelationship(f, P, Q))(isomorphism(f, Volcanoᵢ,₁(P, Sym₁, ..., Symᵢ, `*`), Volcanoⱼ,₁(Q, Sym₁, ..., Symⱼ, `◦`))) [i := card P][j := card Q]

인 관계로, P와 Q사이의 동형사상이 존재하는 관계이다.

동형사상 isomorphism이란,

isomorphism : monomorphism, monomorphism

으로, 전사 사상이고 단사 사상인 사상으로,

걍 일대일대응인 준동형사상이라고 보면 된다.

동형인 두 대수구조에서, P, Q는 등수관계이므로,

i = j이다.

k = i = j라고 하면,

Sym₁, ..., Symₖ가 동형사상을 통하여 일대일대응되어, y = f(x)에서, z ∈ {x, y} 로 잡으면, x와 y의 대수구조 종류가 같고, 성질이 같으며, 심볼의 모든 대수구조상의 특성이 동등함(=동치임)을 알수있다.

요컨데, 동형임은 대수적 구조로서 완벽하게 동일함을 말한다.

#### 자기동형 관계 (Automorphism)

자기동형 관계 Automorphism(이)란,

Volcanoᵢ,₁(P, Sym₁, ..., Symᵢ, `*`) Automorphism Volcanoⱼ,₁(Q, Sym₁, ..., Symⱼ, `◦`) : (∃FunctionalRelationship(f, P, Q))(automorphism(f, Volcanoᵢ,₁(P, Sym₁, ..., Symᵢ, `*`), Volcanoⱼ,₁(Q, Sym₁, ..., Symⱼ, `◦`))) [i := card P][j := card Q]

인 관계로, P와 Q사이의 자기동형사상이 존재하는 관계이다.

지기동형사상 automorphism이란,

automorphism : isomorphism, endomorphism

으로, 동형 사상이고 자기 사상인 사상으로,

동형이고, 자기사상을 낀 관계이다.

#### 위상동형사상 관계 (homeomorphic)

위상동형사상 (Homeomorphism)

Homeomorphism(f) : Biject(f), continuous(f, dom f), continuous(f⁻¹, codom f)

### 심볼 목록

아래 심볼은, Volcano에서 사용 목적이 정해진 특수한 심볼이다

#### 항등원 (identity element)

이항연산 `*`의 항등원은

 - 좌항등원 eₗ
 - 우항등원 eᵣ

이 존재하고,

각각

+ eₗ * x = x
+ x * eᵣ = x

를 만족하며, (이게 바로 정의)

다음 술어

항등원이존재함(eₗ, eᵣ) : eₗ = eᵣ

에 대해,

항등원이존재함(eₗ, eᵣ) ⊨ ∃e s.t. eₗ = e = eᵣ

인, 즉, 좌항등원과 우항등원이 같으면, "항등원이 존재한다"고 하고, 좌항등원과 우항등원이 같으니, 그것을 "항등원"이라고 하며, 이것의 존재조건인 좌항등원과 우항등원이 같을것이 항등원의 존재 조건이다.

N.B. ATTENTION, WARNING, NOTE(IMPORTANT), WATCHOUT, TIP, DECLARE, READIT : 이하에서, 좌항등원 및 우항등원 기호도 여기에서 정의했으므로, 여기를 참고해야한다는걸 강조하고 또 경고하겠다.

### Laval 대수구조 명칭 목록

**Laval은 Lava + -al이라서, Lava + -적(的) 이라는 뜻이다. `Laval == Lava적(的)`인것이다. (오타아님, 중요)**

어떤 Laval 대수구조 명칭 (= Lava식 대수구조 명칭) K란,

K(Volcanoₘ,ₙ(D, Sym₁, ..., Symₘ, fun₁, ..., funₙ)) : "대수구조 Volcanoₘ,ₙ(D, Sym₁, ..., Symₘ, fun₁, ..., funₙ)가 그 Laval 대수구조 명칭 K가 지칭하는 대수구조를 이룬다"

인 K를 말한다.

예컨데, Magma(Volcanoₘ,₁(D, `*`))은 항진인것이, lava는 기본적으로 닫혀있기에, 그 대수구조 위에 연산이 정의되어있디면 마그마다.

요컨데, Laval 대수구조 명칭은 술어이다.

예컨데 마그마의 Laval 대수구조 명칭 Magma는

Magma라는 영문 명칭 술어이다

#### 1. 1. 단위 마그마 (unit magma)

이항연산 `*`가

Volcano₁,₁(D, e, `*`) ⊨ "이항연산 `*`가 (D, `*`, e)를 이룸"

인 `*`라면, 즉, 항등원을 가진다면,

이를 단위 마그마라고 부른다

Laval 대수구조 명칭은 UnitMagma 이다.

#### 1. 3. 중가환 마그마 (medial magma)

이항연산 `*`가

Volcanoₘ,₁(D, Sym₁, ..., Symₘ, `*`) ⊨ "이항연산 `*`가 (D, `*`)를 이룸", Medial

인 `*`라면, 즉, 당연히 `*`는 마그마니까, 그 마그마가 중가환법칙을 만족시킨다면,

이를 중가환 마그마라고 부른다.

Laval 대수구조 명칭은 MedialMagma 이다.

#### 1. 2. 가환 마그마 (commutative magma)

이항연산 `*`가

Volcanoₘ,₁(D, Sym₁, ..., Symₘ, `*`) ⊨ "이항연산 `*`가 (D, `*`)를 이룸", Commutative

인 `*`라면, 즉, 당연히 `*`는 마그마니까, 그 마그마가 교환법칙을 만족시킨다면, 즉, 가환이라면,

Laval 대수구조 명칭은 CommutativeMagma 이다.

이를 가환 마그마라고 부른다.

#### 2. 1. 반군 (semigroup)

이항연산 `*`

Volcanoₘ,₁(D, Sym₁, ..., Symₘ, `*`) ⊨ "이항연산 `*`가 (D, `*`)를 이룸", Associative

인 `*`라면, 즉, 당연히 `*`는 마그마니까, 그 마그마가, 결합법칙을 만족하면,

이를 반군이라고 한다.

Laval 대수구조 명칭은 Semigroup 이다.

#### 2. 2. 모노이드 (monoid)

이항연산 `*`가

UnitMagma(Volcano₁,₁(D, e, `*`)), Semigroup(Volcano₁,₁(D, e, `*`)) ⊨ "이항연산 `*`가 (D, `*`, e)를 이룸"

인 `*`라면,

즉, 이항연산 `*`가 반군을 이루며, 단위 마그마를 이루면, 

이를 모노이드 (monoid)라 한다.

Laval 대수구조 명칭은 Monoid 이다.

#### 2. 3. 군 (Group)

이항연산 `*`가

(⊨ Monoid(Volcano₁,₁(D, e, `*`)) ⊨ EntireInvertiblity) ⊨ "이항연산 `*`가 <D, `*`>를 이룸"

인 `*`라면,

즉, 이항연산 `*`가 반군을 이루며, 전가역이면 (= 전가역성을 띄면 = 전가역성을 만족하면)

이를, 군이라 한다.

Laval 대수구조 명칭은 Group 이다.

#### 2. 4. 아벨 군 (Abelian Group) • 가환군 (Commutative Group)

> 솔찍히 중학교때 생각한 생각인대 소신발언 하자면, 오차방정식의 근의공식이 없다는걸 밝힌 위대한 수학자 아벨(Abel)님이 너무 고생하고 비참하긴 한데, 대학못간새끼만큼 비참한건 아니니까, (반대하면 인신공격하고싶... 크흠..), 우리 학생들을 위해 과감히 버리고, 가환군이라고 부르는게 좋다고 본다. 소신발언임 주의.

이항연산 `*`가

CommutativeMagma(VoLeftQuasigrouplcano₁,₁(D, e, `*`)), Group(Volcano₁,₁(D, e, `*`)) ⊨ "이항연산 `*`가 <D, `*`>를 이룸"

인 `*`라면,

즉, 이항연산 `*`가 군을 이루는 동시에 가환 마그마를 이룬다면,

이를, 가환군 • 아벨군 이라고 하며,

(또한, AbelianGroup = CommutativeGroup 이고)

Laval 대수구조 명칭을 CommutativeGroup로 한다.

(당연히 AbelianGroup = CommutativeGroup이므로, AbelianGroup로 해도 된다. 왜 대입이 되는지는 "Laval명칭"의 정의 참고. (술어임))

#### 2. 5. 자명군 (trivial group)

이항연산 `*`가 

Group(Volcano₁,₁(D, e, `*`)) s.t. D = {e} ⊨ "이항연산 `*`가 <{e}, `*`>를 이룸"

일때, 이를 자명군이라고 하고, Laval 대수구조 명칭을 TrivialGroup 이라 한다

#### 3. 1. 1. 왼쪽 유사군 (LeftQuasigroup)

Volcanoₘ,₂(D, Sym₁, ..., Symₘ, `*`, `◦`) [`◦` := LeftInverseOf(`*`)] ⊨ "이항연산 `*`가 (D, `*`, `◦`)를 이룸", BijectiveLeftFunctor

인 `*`라면, 즉, 당연히 `*`는 마그마니까, 그 마그마가, 왼쪽 함자 전단사성을 만족시킨다면, 이를 왼쪽 유사군이라고 한다.

#### 3. 1. 2. 오른쪽 유사군 (RightQuasigroup)

Volcanoₘ,₂(D, Sym₁, ..., Symₘ, `*`, `◦`) [`◦` := RightInverseOf(`*`)] ⊨ "이항연산 `*`가 (D, `*`, `◦`)를 이룸", BijectiveRightFunctor

인 `*`라면, 즉, 당연히 `*`는 마그마니까, 그 마그마가, 오른쪽 함자 전단사성을 만족시킨다면, 이를 오른쪽 유사군이라고 한다.

#### 3. 1. 유사군 (Quasigroup)

LeftQuasigroup(Volcanoₘ,₂(D, Sym₁, ..., Symₘ, `*`, `◦`)), RightQuasigroup(Volcanoₘ,₂(D, Sym₁, ..., Symₘ, `*`, `◦`)) ⊨ "이항연산 `*`가 (D, `*`, `◦`)을 이룸"

왼쪽 유사군이자 오른쪽 유사군인것.

즉, 함자가 bijection이면 유사군이다

유사군의 Laval 대수구조 명칭을 Quasigroup라 하자.

<br>

`=== well... ===`

<br>

시실 쉽게말해서, 항상 역연산이 성립하는건게, 항등원 개념이 없어도 된다.

역연산의 특성은 유사군에서 오고, 왼쪽•오른쪽 함자에서 역함자가 존재해서 역연산이 정의되는거다.

어떤 함자 방정식의 해가 유일하게 결정되기 때문이다.

군이라서 역연산이 있는게 아니다.

군이 유사군을 이루기 때문이다.

왜?

전가역성 때문에, a에 대해 그 가역원 b에 대해, (* b)가 (* a)의 역연산으로 정의 가능하기 때문에, 그리고 실제로 일대일대응이 되버리기 때문에, 군은 유사군을 이룬다.

#### 3. 2. 고리 (Loop, 위키백과에선 고리라고 했다만, 수학계에서는 루프라고 부른다고 카더라)

이항연산 `*`가

Quasigroup(Volcano₁,₁(D, e, `*`)), UnitMagma(Volcano₁,₁(D, e, `*`)) ⊨ "이항연산 `*`가 <D, `*`>를 이룸"

일때, 이를 고리라고 하고, Laval 대수구조 명칭으로 Loop 이라 한다.

Quasigroup에 대해서는 최근 설명을 추가했으니, 위 항목 참고

### 성질, 예약 심볼, 대수구조에 대한 해설

#### 결합법칙에 대해 해설하며 ; Associatival Extension과 반군

m항연산 f가 Associative를 만족한다면, m < n인 n에 대해,

f(x₁, ..., xₙ) ≜ f(x₁, ..., xₘ₋₁, f(xₘ, ..., xₙ))

로 제귀적으로 정의하며,

이러한 구조의 작동 원리는 결합법칙에 근거한다.

이러한 제귀적 정의를 결합적 확장 (Associatival Extension)이라고 부르며, 내가 방금 만들어낸 조어이다

m, n은 무한해도 좋을거다. 아마도.

Associatival Extension에 의해, m항연산과 가변항연산의 경계가 허물어지는 특징을 보이기에, 반군인 연산은 k항연산이라면, 최소 항의 수를 k로 간주한다.

#### 역원임-술어에 대해 설명하기 : 좌역원이자 우역원이면 역원임 정리

좌역원이자 우역원이면 역원임 정리는 내가 만든 정리로, 사실 정리라고 하기에도 존나 애매한 난이도다.

+ p' = p ∧ r
+ q' = q ∧ r
+ s = p ∧ q
+ s' = s ∧ r

에서,

p' ∧ q' = s'임은 당연히 안다.

이때,

+ p = 좌역원임-가술어이고
+ q = 우역원임-가술어이고,
+ r = 항등원이존재함(eₗ, eᵣ)일때,

좌역원임-술어, 우역원임-술어, 역원임-가술어, 역원임-술어의 정의에 따라, 

좌역원임-술어 ∧ 우역원임-술어 = 역원임-술어

이라는것이다.

## 의미해석

(작성중; 규칙도입계와 기초적 파악이 어떻게 작동하는지를 먼저 적겠음. 나중에.)

### 규칙도입계

(작성중)

### 기초적 파악

앞으로 말할 L은 모델론적 언어라는 맥락에서 말하는거다.

또한, (작성중)

#### 명세관계 ; isInterfaceOf

T isInterfaceOf L : isInterface(L, T) : (L ⊨ T) s.t. (∀T' ⊨ L)(T ⊨ T')

T는 L의 명세인 관계로, L의 기초임을 알리는 관계다.

L의 정의 ⋅ 규칙을 담당하는 부분으로, 논리 언어 Lₗₒₛᵢₖ (저 및첨자들은 원래 "losik"이 아닌 "logic"로 쓰려고 했지만, 유니코드의 한계상 포기)이 자연 연역(Natural Deduction)하는걸 제외한, 규칙계형 파트로 전반적 논리를 구성한다.

예를들어 L은 TensorFlow, T는 그 공식 document로, 기능은 L에 있고, 그 원리가 T이다.

예를들어,

L = 페아노 산술, T = peano axioms and defines이면,

L"1 + 1 = 2"에서,

정의는, T에서,

```markdown
## DEFINITION

### 덧셈 `+`의 정의

1. x + 1 = x⁺
2. x⁺ + y = (x + y)⁺

여기에서, 정의 2번에 1번을 대입하면, (x + 1) + y = (x + y) + 1로, 결론을 부정하는 조건을 만족하는 명제를 역산해보자면, 그것이 바로 교환법칙의 부정과 결합법칙의 부정이므로, 부정한 결론이 틀림에 근거하여, 이중부정을 통해, 덧셈은 가환반군을 이룸을 알 수 있다. 참고로, 0을 정의하지 않은 버전에서는 모노이드도 아니고 걍 반군이다.

## AXIOMS

다음 다섯 공리를 만족하는 상수 1과 집합 ℕ이 존재한다.

1. 1 ∈ ℕ
2. n ∈ ℕ ⇒ n⁺ ∈ ℕ
3. ∀n ∈ ℕ, n⁺ ≠ 1
4. ∀n ∈ ℕ ∀m ∈ ℕ, n⁺ = m⁺ ⇒ n = m
5. ∀S ⊂ ℕ, (1 ∈ S ∧ (n ∈ S ⇒ n⁺ ∈ S)) ⇒ (S = ℕ)

공리 5를 자연수의 귀납적 정의라고 하며, 이는 무한공리에서 말하는 무한집합 중 최소의 크기를 가지는 집합이라는 뜻이다. 또한, 저기에서 수학적 귀납원리가 나온다.

저걸 함수의 언어로 바꾸면, 어떻게 모델을 구축해야할지 보인다.

4번 공리를 보아하니, 다음수 연산 `⁺`는 단사(일대일함수)이다. 그런데, 치역이 1 이상의 자연수 전체이므로, 해당 자연수를 정의역으로 하고 치역이 1이상의 자연수를 치역으로 한다면, 전단사함수(일대일대응)일것이고, 따라서, 다음수 연산은 역함수인 이전수 `⁻`를 가진다. (이 설명의 근걸는 2번 공리 함고)

3번, 1번, 5번 공리를 보면, 자연수는 1에서 시작해서 연쇠적으로 세어나가면서 나오는 수들의 집합이다.

참고로 5번 공리를 보지 말고, 2번 공리만 보더라도 알 수 있다.

사실 5번 공리에 1번 공리에 쓰인 텍스트와, 2번 공리에 쓰인 텍스트가 전부 들어간 점에서, 우리는 자연수 집합 S = ℕ을 다룰떄, 1번, 2번, 3번 공리를 보면 됨을 쉽게 알 수 있다.

사실은, 이것의 모델에서 1은 상수 심볼인데, 번외에서 신기한 특징을 다루겠다.

## 번외

다음 술어 ℙ₁, ℙ₂, ℙ₃, ℙ₄, ℙ₅를 DEFINE하자.

ℙ₁(k, ℕₖ) : k ∈ ℕₖ
ℙ₂(k, ℕₖ) : n ∈ ℕₖ ⇒ n⁺ ∈ ℕₖ
ℙ₃(k, ℕₖ) : ∀n ∈ ℕₖ, n⁺ ≠ k
ℙ₄(k, ℕₖ) : ∀n ∈ ℕₖ ∀m ∈ ℕₖ, n⁺ = m⁺ ⇒ n = m
ℙ₅(k, ℕₖ) : ∀S ⊂ ℕₖ, (ℙ₁(k, S) ∧ ℙ₂(k, S)) ⇒ (S = ℕₖ)

다음은 AXIOMS이다.

다음 공리를 만족하는 상수 k와 집합 ℕ이 존재한다.

1. ℙ₁(k, ℕₖ)
2. ℙ₂(k, ℕₖ)
3. ℙ₃(k, ℕₖ)
4. ℙ₄(k, ℕₖ)
5. ℙ₅(k, ℕₖ)

여기에서도, 4번공리를 통해 다음수의 특징이 유추되며,
1, 2, 3번공리를 통해, k부터 시작하는 자연수(서수) ℕₖ를 정의함을 알 수 있다.

참고로, 덧셈의 정의를 통해서 다름수의 뜻을 알수 있음은 너무 당연한 사실이고, 여기서도 동일하다.

참고로 ℕ₀를 범자연수라고 하며, 𝕎 = ℕ₀로 표기하기도 한다.

참고로,

수가 0, 수가 null(=Null), 수가 NaN인것의 차이가 뭐냐하면,

0은 잔액이 0,
null은 잔액이 없음 (= 그런거 없음)
NaN은 잔액이 수가 아님 (= 0/0꼴)
인것이라서,

0은 통장 잔액이 텅장
null은 통장이 없음
NaN은 통장 잔액이란 개념이 없음

이었던가...? 그랬다.

그런데 잔액이 없는거 (수량을 보는데 그값이 없음(=null))랑 잔액이 0인거 (수량이 0인것)가 무슨 차이인가?

수량으로써 0은 그것이 수량으로 있어야 한다.

0은 없는것을 의미하는, 즉, 1 - 1을 의미하는 수량이고,

이게 자연수가 되야하는지는 논란이었다. (= 자연에 있는 수인지, 자연으로부터 나오는지 논란)

그러나, 수라는게 자연을 설명하는것이고, 셈을 시도했을때, 무조건 ℕ₀(= 𝕎)나 NaN(=원래는 실수에서 정의역 벗어남이지만, 여기서는 범자연수로 치자.)으로 세어지므로, 범자연수로 다룬다고 합리화하는것 같다.

솔찍히 나도 뭐가 맞는지 모르겠고, 걍 범자연수로 구축하는게 용이한건 확실하다.

그래서 실제로, 페아노 공리계를 구축할때는, 범자연수를 쓴다고 한다.
```

이므로, 해당 언어는 모델론이 의미하는 규칙에 따라, L"1 + 1 = 2"가 L"1⁺ = 2"로 치환되서 (덧셈의 정의), 심볼 '2'가 의미하는 바가 1의 다음수를 표기하는 Notation임을 알 수 있다.

그러니까 십진법 기호 표기법은,
1. 2 = 1⁺
2. 3 = 2⁺
3. 4 = 3⁺
4. 5 = 4⁺
5. 6 = 5⁺
6. 7 = 6⁺
7. 8 = 7⁺
8. 9 = 8⁺
   
를 만족하는 모델론적 언어로 볼 수 있다.

십육진법에서는
1. 추가규칙 아님, 상단참고
2. 추가규칙 아님, 상단참고
3. 추가규칙 아님, 상단참고
4. 추가규칙 아님, 상단참고
5. 추가규칙 아님, 상단참고
6. 추가규칙 아님, 상단참고
7. 추가규칙 아님, 상단참고
8. 추가규칙 아님, 상단참고
9. A = 9⁺
10. B = A⁺
11. C = B⁺
12. D = C⁺
13. E = D⁺
14. F = E⁺
    
인 추가 규칙이 생기는것이고 말이다.

참고로, 범자연수식으로 보자면, 1 = 0⁺로 정의된다.

물론 이에 대해, 항상 참인거 아니냐고 물을 수 있을텐데, 무한공리를 허용하지 않으면, 이러한 구축방법은 참이 아니고, 이런식으로 정의와 공리를 적고 나서 그를 만족시키는 모델이 존재하지 않는...

예컨데, 공리에 1 = 2를 추가하면 배중률을 어기는데, 이를 만족하는 모델은, 더이상 형식논리가 아니므로, 항상 참은 아니다.

하필 자연수의 덧셈을 가져와서 항상 참이지만

하필.

#### 구현관계 ; isImplementOf

M isImplementOf T : isImplementOf(T, M) : T isInterfaceOf L, M ⊨ T ⊨ L

M이 T의 구현 (Tip : 구현체로 이해해도 좋음)인 관계로, M은 T인 체계를 구성한다.

L언어와 그것을 이룰 요건인 기초 T를 만족하는 M은 구조모델이고, M은 기초 T와 Pre와 Fun, Sym정의 등을 구현(=구성)하며, M ⊨ L ⊨ T인 측면이 있다.

그러나 T의 본질이 M인지 확신할 수 없으며, 당장 FOL에서 뢰벤하임-스콜렘 정리 (Löwenheim–Skolem theorem)등에 따라서, 본질이라기 보다는, 수학적 • 구조적 정합성 측면에서 본질로 볼 수 있는 측면이 있는 구현(=형식화, 사실 정의 되는지도 모르겠는걸 분석 후 모델로써 정의하는것같은 원리다)이지, 유일한, 그리고 절대적인 진리 따위가 아니다.

뢰벤하임 스콜렘 정리에 따라서, 여러가지 모델로 본질을 표현할 수 있다고 하고, 당장에 실수에 대해서, Łoś's theorem으로 만든 `ℝ*` (초실수체, hyperreal field) 만 봐도, 알 수 있다.

그러나 겉모습만 보여주고 그걸 본질이냐고 묻는데에 대해서는 전혀 그렇게 확신할 근거가 없다고 단언한다. 근거를 가져와야한다.



다시 돌아와서, T와 M에 대해 말하자.

예컨데 T는 TensorFlow의 document, M은 일게 그 구현체,

혹은 T는 C언어나 LISP, M은 gcc나 Racket을 예로 들수 있을것이다.



다시한번 이전에 peano공리계로 예를 들었듯 peano공리계 T와 체르멜로(Zermelo)의 구성(Constructure) M과, 폰 노이만 (von Neumann)의 구성 `M'`으로 예를 들어보자 

먼저 M은

```markdown
s(x) = x⁺에서,

0 := ∅
s(x) := {x}

즉,

M = <ℕ₀, 0 = ∅, s(x) = {x} s.t. codom s = ℕ>

인 체계로,

16진수 표기법은,

0 := ∅에서,

1. 1 := {0}
2. 2 := {1}
3. 3 := {2}
4. 4 := {3}
5. 5 := {4}
6. 6 := {5}
7. 7 := {6}
8. 8 := {7}
9. 9 := {8}
10. A := {9}
11. B := {A}
12. C := {B}
13. D := {C}
14. E := {D}
15. F := {E}

로 볼 수 있다.

덧셈은, 범자연수에 대해 가환 모노이드를 이룬다.

> 
> pf.
> 
> 기본적으로 덧셈은 가환 반군을 이룬다.
> 
> 집합 중간에 구멍을 송송내서 닫히지조 못하게 고문하는 경우는 제외하고 말이다.
> 
> 그런 비정상정임경우를 가져오는 미친놈은 아마 없을것이다.
> 
> ~~(가져온다면 덧셈왈 나는 입이없지만 소리를 질러야 한다 이럴듯하다)~~
> 
> 0 + 1 = 0⁺ = 1이므로,
> 
> (0 + x)⁺ = 0⁺ + x = 1 + x = x + 1 = x⁺임을 알수 있는데,
> 
> (x + 0)⁺ = x⁺이므로,
> 
> x + 0 = x임을 알 수 있다.
> 
> 즉 항등원을 가지니, 단위 마그마를 이룸을 알 수 있다.
> 
> 가환 반군이자 동시에 단위 마그마인것은, 가환이고 반군이자, 동시에 담위 마그마인것으로, 가환이고, 모노이드인것으로, 가환 모노이드이다.
> 

2 + 2 = 4인것은,

2 = 1⁺이기에,

2 + 1⁺ = 1⁺ + 2 = (1 + 2)⁺ = (2 + 1)⁺ = 3⁺ = 4로 구할 수 있다.



덧셈은,

1. Φ₁(`*`) : `x * 1 = x⁺`
2. Φ₂(`*`) : `x⁺ * y = (x * y)⁺`
3. Φ : Φ₁, Φ₂

이게 정의한 술어 Φ에서,

Φ(`+`)인 연산이다.

사실은 (+ 1) = s 이게 정의되며, 닫혀있다면 가환반군을 이룰성질을 부여해서 구축했다고도 볼 수 있다.

근데, 이러면, 단점이 좀 있어서, 충분히 나은 폰 노이만 방식을 택한다.

당연히 최대효율을 택하는 한계효용 생각해보면 합리적으로 보인다.
```

`M'`은

```markdown

자연수가 서수(ordinal) 이게도 만들어주는 장점많은, 삐까뻔쩍한 구성이다.

s(x) = x⁺에서,

0 := ∅
s(x) := x ∪ {x}

식으로 구성한다.

즉,

`M'` = <ℕ₀, 0 = ∅, s(x) = x ∪ {x} s.t. codom s = ℕ>

사실 도매인(정의역, 모델의 닫여야하는 집합)이 ℕ₀일떼, codom s = ℕ임은 전부 그렇다.

이 점에서, 자연수가 간단히 나오니 걍 범자연수 구축이라도 왜 이래야 하는지 따지지 말고 받아들여줬으면 좋겠다.



자, 폰 노이만 구성에서 16진수 표기법은

0 := ∅ (= {}) 에서,

1. 1 = {0}
2. 2 = {0, 1}
3. 3 = {0, 1, 2}
4. 4 = {0, 1, 2, 3}
5. 5 = {0, 1, 2, 3, 4}
6. 6 = {0, 1, 2, 3, 4, 5}
7. 7 = {0, 1, 2, 3, 4, 5, 6}
8. 8 = {0, 1, 2, 3, 4, 5, 6, 7}
9. 9 = {0, 1, 2, 3, 4, 5, 6, 7, 8}
10. A = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
11. B = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A}
12. C = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B}
13. D = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C}
14. E = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D}
15. F = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E}

이다.

마찬가지로 반군을 이루고, 덧셈의 구성 방법도 같다.



폰 노이만 식이든 체르멜로 식이든

Rank x = x 임은 같고,

x ∈ x⁺임도 같지만

폰 노이만 방식은

0, 1, ..., x ∈ x⁺

이며,

card x = x (단. 이 문장은 엄밀하지 못하다. 범자연수와 기수와 서수는 다른것이, 기수(카디널리티, 카디널)는 "××집합의 카니덜은"이라고 말하는데에서 알수 있듯, 집합에 대한것이다 (정의상), 집합의 카디널리티는 일대일대응이 있으면 같은것이므로, 카디널리티(기수)를 범자연수로 정의하지 아니하였다면, 카디널이 같은지 여부에서는, 에초에 관계의 정의역에 들어가지 못하는 불상사다 일어나, 항위일것이니, 카디널리티가 범자연수인 경우에 맞는 문장이다)

이라는것이 특징이다.

또한, y ≤ x에서,

y ⊂ x으로,

외연공리를 이용하여 같은지 다른지를 알 수 있는 장점이 있다.

사실 범자연수 집합의 존재성은, 무한 공리에서 보장한다.

ZF공리계에서 초한수의 최소이자 초한기수의 최소는 자연수번째 무한 혹은 자연수의 카디널, 즉 자연수 크기의 무한인데,

무한 공리에서 말하는 최소 크기의 무한집합이 자연수이기 때문이다. (자연수의 정의)

그리고 이게 표준 방법이다.

비표준이라고 틀린건 아니지만, 권총과 망치로 인해 표준이 맞는것처럼 치도록 강제할수 있다.

사회라는 약속으로.
```

위와같이 모델을 만들수 있어도, 이것이 왜 그 구현이여야 하는지 잘 모르겠지 않나?

진짜 자연수는, 그 본질이 공리계에 있을것이다.

(사실 굳이 그 공리계로 잡지 않아도, 다른 공리계가 그 공리계를 만족시킨다.)

아마도 말이다. 이것은 본질이라기에는 실용적 구현에 가까워보이니, 함부로 명세가 본질이네 구현이 본질이네 할 증거가 없다고 단언한것이다.

그 증거를 더 가져와야 한단것을.

그리고, 자연수의 두 구현체를 보고, 당연히 그런식으로 약속했으니 그렇게 되는것 아니냐고 묻는다면 말하겠다.

당신은 Lisp(언어)와 Racket(구현체)이 완전히 동일하다고 생각하는가?

#### 상속자 : Extender

N.B. ATTENTION, WARNING, NOTE(IMPORTANT), WATCHOUT, TIP, DECLARE, READIT :  자, 이제부터 다루는 내용이 핵심이다. isInterfaceOf나 isImplementOf는 일게 모델론적 개념의 표기법용 노트의 설명에 불과하다.

N.B. ATTENTION, WARNING, NOTE(IMPORTANT), WATCHOUT, TIP, DECLARE, READIT : 내가 설명항 내용은 지금부터 시작이고, 의미해석의 핵심 파트는 상속사, 피상속자, 참피상속자, 섹터, 명제귀결, 구조귀결, 폼페이 함수를 이용한, 기초적 파악이고, 이중 피상속사 참피상속자, 섹터같은 구조가 상속자에서 나온다.
N.B. ATTENTION, WARNING, NOTE(IMPORTANT), WATCHOUT, TIP, DECLARE, READIT : 그러나 핵심적인 논리흐름은 명제귀결, 구조귀결을 알아야 하고,
N.B. ATTENTION, WARNING, NOTE(IMPORTANT), WATCHOUT, TIP, DECLARE, READIT : 다루는 대상은 기초적 파악이다.

자, 본론으로 들어가보자.

Interface, Implement, Extend... 사실 이것들은 다 Object Oriented Programming Language인 Java에서 따온 명칭이다.

뭐... 그냥 그렇다는거다.

Extenderₙ(M₁, ..., Mₙ) ≜ M s.t. M₁, ..., Mₙ ⊨ M

Extender(상속자)란 n개의 Implement들을 상속한 Structure Model을 주는 함수로 Extender의 용법의 대표적 예시로는, DustunalExtenderalObject와 Sector가 있다.

상속자를 아래 예시로 살펴보자.

```python

class CORE(bool):
    def __init__(self, value) -> None:
        super().__init__(value)
    
    def __gen_my_type(self, ob):
        return type(self)(ob)

class ConjuntionLattice(CORE):
    def __init__(self, value) -> None:
        super().__init__(value)
    
    def __and__(self, other):
        return self.__gen_my_type(self and other)

class ANF(ConjuntionLattice):
    def __init__(self, value) -> None:
        super().__init__(value)
    
    def __xor__(self, other):
        return self.__gen_my_type(int(self) ^ int(other))

class NagationStructureModel(CORE):
    
    def __init__(self, value) -> None:
        super().__init__(value)
    
    def __invert__(self):
        return self.__gen_my_type(not self)

class CNF(NagationStructureModel, ConjuntionLattice):
    def __init__(self, value) -> None:
        super().__init__(value)

class DNF(NagationStructureModel):
    def __init__(self, value) -> None:
        super().__init__(boolean)
    
    def __or__(self, value):
        return self.__gen_my_type(self or other)

class PsudoAngdeAlgebra(ConjuntionLattice):
    '''
    # diffrence between PsudoAngdeAlgebra and Angde Algebra
    
    while Angde Algebra is defined by me, and also it only use imply and use boolean value , not using conjuntion, but PsudoAngdeAlgebra is using Conjunction to form the logical operated.
    
    model theory to make an logical language or gödel numbering's logical operand.. blablabla

    it used in past as whole diffrent forms. that's an critical diffrence betwean AngdeAlgera
    '''

    def __init__(self, value) -> None:
        super().__init__(value)
    
    def __le__(self, value):
        '''
        letter `<=` seems like reversed implication operator `⇐`, so it will coded as `<=` means `←` which implication symbol s.t. `x ← y` means `y implies x` s.t. `x ← y = y → x = (¬y ∨ x)`
        '''
        return self.__gen_my_type(self or not value)

class HighschoolLevelLogicalOperator(PsudoAngdeAlgebra, CNF, DNF, ANF):
    '''
    L = {'~', '&&', '||', '^', '<='}
    '''
    
    def __init__(self, value):
        super().__init__(value)
```

이처럼 상속 구조는 필드(구조체 상수)및 메서드(구조체 함수)를 가져오는데,

다음 c/c++코드를 보라.

```cpp

struct intSizeTyp {
    int main_value;
    
    intSizeTyp(int main_value) {
        this.main_value = main_value;
    }
}

struct MathmaticalStructure : intSizeTyp;

struct MathmaticalStructure {
    const MathmaticalStructure Sym1 = MathmaticalStructure(0);
    const MathmaticalStructure Sym2 = MathmaticalStructure(1);
    
    MathmaticalStructure Fun1(intSizeTyp x) {
        return x + this.Sym2
    }
    
    MathmaticalStructure Fun2(void) {
        /* null-ary operand */
        return this.Sym1
    }
};
```

저 구조체는 다음과 같은 튜플이다.

MathmaticalStructure = <constructer, Sym1, Sym2, Fun1, Fun2, main_value>

각각 도메인(이라고 치자고 ㅋㅋ ㅠㅠ) 상수기호 Sym1, Sym2, 함수기호 Fun1, Fun2, 변수기호 main_value가 차례대로 담긴 그저 튜플이다.

그리고 이건 시벙 놀랍게도 C의 구조체의 역할인 그냥 이름붙여 묶기를 잘 수행하는 튜플이다.

예를 들어보자.

```cpp
struct cardesian_coordinate {
    double x; //8B = 64bit
    double y; //8B = 64bit
};

cardesian_coordinate v;
```

위 코드는 다음과 같이 메모리에 적제될것이다. (컴파일 예시지 실제로 저러진 않는다.

```
memory addr : 0000 0000 0000 07B4 | v.x
memory addr : 0000 0000 0000 07BC | v.y
```

그러면 저 필드가 가르키는건 순전히 <x, y>인 튜플의 원소다.

실제로 SIMD vectorization연산도 이와 유사하다.

이와같이, 어떤 구조체 M, N이 있어서, M ⊨ N의 만족관계를 가지면, 상속된다고 비유적으로 이해할 수 있다.

#### 피상속자 ; ExtenderalObject

피상속자 ExtenderalObject는 External과 반대로, 부모를 쫒아간다 생각하면 편하다. (편하다고 했지, 꼭 그런건 아닌게, 피상속 관계를 만족시키는걸 뱉는 다가함수로, 부모 모델들의 집합을 뱉지만 그걸 여러개 뱉으므로, M, N, L을 상속했더라도 `M'`, `N'`, `L'`이 나오지 않으리란 보장이 없다. 사실 둘다 다가로 나오는 함수니까. (이가라고 한정한 적 없음))

ExtenderalObjectₙ ≜ (Extenderₙ)⁻¹

ExtenderalObject는 다가함수로, M이 상속된 자식이게 하는 M₁, ..., Mₙ들의 모임 `M'`을 뱉는 다가함수로, M'이 여러개이기에, 튜플(=구조체)집합(=모임)(=M')의 집합족(M'들의 모임)으로 가는 치역을 가진다.

ExtenderObject는 결국 M을 만족시키기에, 자신을 낳을(=모델링할) 부모를 파악하는 함수이다. 또한, 

(작성중)

#### 참피상속자 ; DistunalExtenderalObject

(작성중)

#### Sector

(작성중)

#### 명제귀결 ; ProposolalConsequence

(작성중)

#### 명제귀결도입기반 구조귀결 ; ProposolalConsequenceIntroduceSystemicConsequence

(작성중)

#### 폼페이 함수 ; Pompeii

(작성중)

#### 기초적 파악

(작성중)

## NOTE

으아....
````

# infos.md

그동안 탐구한거 난잡히 모아놓음.

## Quatro

````markdown
# Quatro (미완성)

## ideas

`<ℝ ∪ ℝ*, *, ᵤ, st>`인 대수구조는 전달원리, 울트라곱 구성, 표준부분원리까지 세가지 함수가 정의된 신기한 대수구조네? ㅋㅋㅋ
`o.o* ≜ <ℝ ∪ ℝ*, *, ᵤ, st>`로 정의하자.
p-adic은 언어(문자셋)를 L = Z/pₖZ를 놓았을네, 기수법에서의 덧셈 • 뻴셈 • 곱셈 • 나눗셈 • 로그 • 지수 • 기타 하이퍼연산 등이 정의된 무한 문자 시퀀스와 동형이네? ㅋㅋㅋ 이런 언어 L을 `adₖ`라고 할께. 수열인 이유는 pₖⁿ [n := ∞]와 동형이니까.

```
Φ₁(v, w, *) : v₁ * w₂= w₁ * v₂
G(a, *, k) : {b | Φₖ(a, b, *)}
Φ₂(v, w, *) : ∀k ∈ ℕ, Φ₁(<vₖ, wₖ>, <v₁, w₁>, *)

a ; b ≜ G(<a, b>, +, 1)
v₁ ; ... ; vₙ ≜ G(Σₖ vₖ [k := 1 ~ n], +, 1
a : b ≜ G(<a, b>, ×, 1)
v₁ : ... : vₙ ≜ G(Σₖ vₖ [k := 1 ~ n], ×, 1)
```
이거 만드려고...

이러니까 확실히, v₁ ; ... ; vₙ가 각 차가 일정하고, 벡터 위치가 달라도 같으니까, 아핀 공간의 원소네

G(<v₁, ..., vₙ>, pow, k)는? 항상Φ₁(log(v₁, w₁), log(vₙ, wₙ), pow)니까, 자연로그의 비네.

에초에,
G(<a, b>, ×, k)는, G(<ln a, ln b>, +, k)와 동형이고,
G(<a, b>, ↑, k)는, G(<ln a, ln b>, ×, k)와 동형이고,
G(<a, b>, ↑ⁿ, k)는, G(<ln a, ln b>, ↑ⁿ⁻¹, k)와 동형이니까, 모든 하이퍼연산에 대해 성립하네.

동형인 이유는 동치류는 집합 S인데, 집합 P, Q에 대해,
Q = f(P) = {ln x | x ∈ P}
인 동형사상이 존재하니까.

그러면 이러한 G를 Grandpiano라고 할께.

에초에 ZFC에서 정수와 유리수의 정의를 보면, 역산으로 간주할 튜플의 동치류로 구성하니까, Grandpiano는 그러한 하이퍼연산의 역연산들을 닫혀있게 구성해주는 함수네?

잠시만, 그러면 유리수체에서, Cauchy Sequence를 만들어 놓으면, `o.o*`를 구성할 수 있고, `o.o*`에서는 `adₖ`를 구성할 수 있는데?

잘생각해봤는데 말이야, 무한 문자 시퀀스 t에 대해, f(x) = tₕ pₖʰ로 놓고, f는 자연수에서 정의된 함수이므로, 극한을 취한 무한합의 역할을 해줄만함건 부정적분이므로, ∫ f(x) dx가 p-adic을 원래대로 되돌리는 함수같은데?

그러면 daₖ(t) ≜ f(pₖ) [n! (dⁿ/dxⁿ) f(x) := tʰ]인 메클로린 급수 f에 대해서 잘만 표현되네.

이렇게 p-adic의 의미하는 값으로 수렴하는 함수를 da라고 하겠음

그러면, `<ℝ ∪ ℝ* ∪ {adₖ | k ∈ ℕ} ∪ {{{adₖ | k ∈ ℕ}}, *, ᵤ, st, da, ad>`는 함수 ad를 이용하여 언어를 만들수 있고, da를 이용하여 복귀할수 있는 기능을 `o.o*`에 추가시킨 셈이니, 이를 `σ.σ* ≜ <ℝ ∪ ℝ* ∪ {adₖ | k ∈ ℕ} ∪ {{{adₖ | k ∈ ℕ}}, *, ᵤ, st, da, ad>`로 정의해서, `σ.σ*`라 하겠음.

Grandpiano로 구성된 유리수체 모델을 구현이 특별하는 특별히 `comQ`라고 하겠음

comQ위에서 정의된 `σ.σ*`를 특별히 `α.α*`라고 하겠음.

(a : b) ± (c : d)는, 에초에 <a, b>, <c, d>라는 베이수 수준에서,
Gigachad(±, <a, b>, <c, d>) ≜ <ad ± bc, bd>로 정의한 기가차드 함수에서, Gigachader := λx. λy. Gigachad(x, y)로 정의하면, kuratowski 쌍의 제귀적 정의를 이용하면, Gigachader(±)(x, y) = Gigachad(±, x, y)이므로, 연산자답게 중위표기해주면,
x Gigachader(±) y = Gigachad(±, x, y)
따라서, (a : b) ± (c : d) = G(<a, b> Gigachader(±) <c, d>, ×, 1)로 연산을 정의해서, 연산을 준다.

사실은 곱셈은 루프(Loop, 가환인 유사군)와 가환환을 동시에 이루므로, 역연산이라는 툴으로, 함수의 이항을 구현해서, 비례식과 동형임을 증명할 수 있어, 일관성이 깨지지 않기에, 저런식으로 정의하는것.

에초에 유클리드 공간에서 단위길이의 선분 OX와, 선분 OX에서 X방향으로 무한히 연장한 반직선 OX에 대해, 선분 OX위에 없고, 반직선 OX위에 있는 점 P에 대해, 선분 OP의 길이를 t로 두자.
직각을 유일하므로, 컴퍼스를 통해 이미 구성되어있는 직각을 작도하여 (구성주의적으로 할수있을거라 가정한것 뿐), 반직선 OX와 수직인 반직선 OX`을 그린다. 그리고 선분 OP를 컴퍼스를 이용하여 원호를 그리고, 반직선 OX`와 만나는 점을 P`이라고 하자, 이제 자를 통해 선분 PX`및 XP`를 그리면, 직각삼각형 ΔOX`P와 직각삼각형 ΔOXP`은 합동이다. 즉, 우리는 ΔOX`P에 대해, 이를 y=x에 대해 대칭이동한것을 작도한것이다. 마지막으로, 선분 P`X와 평행하고, 점 X`을 지나는 직선 X`T를 그어주고, 직선 X`T가 선분 OX와 만나는 점이 T이다.
이러한 과정을 통해 단위선분 OX의 1:P-1 외분점 P가 존재하여, OP에 대해, 그것의 역수 길이 선분은, OT로 작도 가능하여 존재하고, OT는 기하학적 선분으로 t배하면, OX이므로, 합과 곱을 아름답게 정의할 수 있다.

사실 딱히 아름답다고 생각하지 않지만, "잘 정의되됨"과 "잘 작동함"을 동시에 쓰기 귀찮아서 아름답게 정의된다고 말함.

정수에서 다음 단항연산을 정의함.
-x ≜ 0 - x

x = x ↔ x - x = 0임.

정수에서 덧셈, 뺄셈이 정의된다 가정하면 다음을 만족한다.

1.1. x = -|x| ↔ x - (-|x|) = -|x| - (-|x|) = 0 ↔ - (-|x|) = |x|임. 따라서, 범자연수 x에 대해, -(-x) = x
1.2. 음의 정수 x에 대해, x = -|x|에서, -(-x) = -(-(-|x|)) = -(|x|) = x
1.3. 따라서, 1.1. 및 1.2.에 따라서, 정수 x에 대해, -(-x) = x이며, 특히, -(-1) = 1
2.1. 범자연수 x에 대해, (-1)x = -x
2.2. 음의 정수 x에 대해, (-1)|x| = -|x| = x에서, -(-1)|x| = -x = |x| = -(-|x|) = -((-1)|x|)에서,

아시바 증명이 뭔가 이상한데 ㅋㅋ 오늘은 여기까지.

오늘에서는 결과적으로 `σ.σ*`라는 거대한 수 체계를 만드는 구성인 `α.α*`을 만들었네. 그러면서 Grandpiano를 이용하여, 하이퍼연산과 그 역연산에서 닫힘을 보장하며, 이를 통해서 아핀공간의 벡터와, 비, 그리고 여러 Grandpiano류 대수들을 만들었네. 그래서 Grandpiano류 대수와 `α.α*`구성을 통한 `σ.σ*`대수를 통해서, n중차, n중비를 다루며, 동시에 p-adic • hyperrealfield까지 다룰수 있으니 일석 이조고, 이걸로 n² 행렬인 벡터의 코벡터를 만들어서, 복소수, 분할복소수, 멱등원, 사원수, 팔원수 등을 만들 수 있겠네

컴퓨터 구현시에서는 p-adic, hyperreal, real, fraction을 각각 다룰때 자료형을 만들어서 변환하는걸로 생각하면 되겠네.

소인수분해시에는 고전 소수열 pₖ = 1 if k = 0 else pₗ s.t. pₗ = inf {gcdᵢ pᵢ = 1 [i := 1 ~ k]}에, 최대공약수 gcd(x, y) ≜ x if y = 0 else gcd(y, x mod y)및 최소공배수 lcm(x, y) = xy/gcd(x, y)를 만들수 있으고 특히 최대공약수는 가환모노이드니, pₖ가 옳고 (오 시바 ㅋㅋ 삼성키보드 사용하기 뭣같아서 육성으로 욕나왔넼ㅋㅋㅋㅋ) 새로 만든 정수용 소인수열 ₩ₖ ≜ cis(π) if k = 0 else pₖ에서, 단위로그눈금자 alₖ ≜ ln(₩ₖ)에 대해, ln이 자료형인 형태로 소인수분해 결과를 뱉을수 있겠네.

함수 제작같은 경우에는, Rₘ(M)ₙ(V) ≜ Σₖ (ln(Σᵢ Vₜ) - Vₖ)eₖ [t := Mₖᵢ][k := 1 ~ m][i := 1 ~ n]에서, 음함수, Rₘ(M)ₙ(V) = 0꼴로, 실수 미지수가 V에 생기고, 요기서, V₁ ↦ V₂가 실수, V₃ ↦ V₄로 가는 실수열을 각각 코시수열과 초실수 제작용 수열로 보면 이미 있을건 다 있겠네. 이런 방식을 근본-nibble-array라는 뜻으로 NewageNibleArray라고 부르면 되겠네. 이미 이걸로 연립방정식 재작은 다 케리되니까 사실상 행렬 M이 실수 생성 행렬이 되는거고. R을 Relator라고 해야지. 그러면, 아싸존애 정의한 ln이 ln(x + y) ≜ ln(x) + ln(y)하면 자동으로 자연로그가 되기에 (복소로그의 정의상, 저런 일반화 로그는 복소로그의 정의로 귀결되어, 항상 ln임), 이전 정의도 가저온거고, 이 시스템을 Relator와 NewageNibleArray라고 부르면 되겠네, 이때 실수 • 초실수의 정의는 `α.α*`를 쓰고. 이걸 `oωo*`라고 부름 되겠군

이거완전 복잡한 부분은 거의 행렬기반이니까, 쉽게 컴퓨터에 구현 가능하고, 자동증명용 • 형식증명검증으로도 용이할듯. 나머지 부분에서 실수같은 비 대수적 부분은 자료형으로 만들기 용이하고, 타입케스팅 함수도 있으니. `oωο*`로 프로그래밍 시스템 만들면, 대박 엄밀할듯

## 유리수체 ℚ를 구성하는 모델 Quatro

Quatro = <𝔻, QMinus, Qrev, Qadder, Qmuler, Qcmp, Qeq>

Quatro는 Polandian-Notation인 연산을 지원한다. 프로그래밍에도 용이해보이고, 선형사상이므로 자연스럽고, 연산자도 중위표기라는 거북한 표기가 아닌, 커링된 함수 표기여서, 훨씬 통쾌한것같다.

텐서 렝크가 3이 넘어가냐고 묻는다면 그건 아니고, 집합 렝크가 그렇냐고 묻는다면 모르겠다.
이름이 Quatro인 이유는 그냥 그게 멋있어서.

사실은 Quatro는 Quatro Real을 만들기 위해서 "Quatro다!"라고 ~~개소리~~ 하기 위해서 Quatro로 지었고 하겠다.

0. Domain

𝔻 ≜ ((𝕍²)² ∪ 𝕍² ∪ 𝕍 [𝕍 := ℤ²]

도메인에서 `(𝕍²)²)²`는 이항연산자 `(𝕍²)²`는 단항연산자고, 𝕍에 대해서, 동치관계 Qeq에 대한 동치류, v ∈ 𝕍, {w | Qeq(v, w)} ∈ ℚ 이도록, 유리수를 구성할 수 있다.

1. Constants

 + QMinus = <<-1, 0>, <0, 1>>
 + Qrev = <<0, 1>, <1, 0>>

앞서 말한 기준에서, QMinus와 Qrev는 단항연산자임을 알 수 있다. `QMinus x`는 `-x`를 의미하고, `Qrev x`는 `1/x`를 의미한다.

 + Qadder = <<<0, 1>, <1, 0>>, <<0, 0>, <0, 1>>>
 + Qmuler = <<<1, 0>, <0, 0>>, <<0, 0>, <0, 1>>>

Qmuler의 정체가 궁금할수 있으니 말하겠다. 이차원 벡터 v, w에 대해, Qmuler v w는 아다마르 곱 v ∘ w 이다.

앞서 말한 기준에서, Qadder와 Qmuler는 이항연산자임을 알 수 있다. `Qadder x y`는 `x + y`이고, `Qmuler x y`는 `xy`를 의미함도 알 수 있다.

2. Functions

 + Qcmp(v, w) = ((Qadder (QMinus w)) v) • e₁

Qcmp는 단순히 v - w의 분모는 저리치우고, 분자를 따진다. 이건 더이상 선형이 아니다.

3. Relation

 + Qeq(v, w) : Qcmp(v, w) = 0

겉보기엔 Qcmp의 근을 나타내는 방정식의 해집합 Qeq로 술어 내지 관계를 만든것 같지만, Qcmp의 근은 유리수체에서 `v = w`를 의미하므로, 동치관걔임을 알 수 있다.

1. 유리수 p, q에 대해, p - q = 0시, p - q = 0 = q - p이므로, 가환이고, p = a/b이고, q = c/d 일시,
2. p - q = (ad - bc)/bd 이므로, 완전히 비율로 취급하고 계산하는것이라서, a:b = c:d이면, Qeq(<a, b>, <c, d>)이므로,

a:b:c = d:e:f에서,

Qeq(<a, d>, <b, e>), Qeq(<b, e>, <c, f>) ⊨ Qeq(<a, d>, <c, f>)임은,

1. r = a:b, R = b:c에서,
2. a = br, b = cR, a = crR에서,

에초에, w:x = y:z부터, t = w:x로 잡았을때,

xy = xzt = xtz = wz 이므로,

a = br에서도, b = cR에서도, a = c(rR)에서도 마찬가지임을 알 수 있고,

이런식으로 계산되는것이 애초에 비례식과 분수의 덧•뺄셈의 본질적인(Immediatly) 부분이므로, 

a:b:c = d:e:f에서 당연하다는 한마디로 정리된다.

### 선설명 : Qrev, Qadder, Qcmp, Qmuler, QMinus, Qeq

첫번째 쳅터로, 연산자들을 정의해보자.

Qadder ≜ <<<0, 1>, <1, 0>>, <<0, 0>, <0, 1>>>

열벡터에 대해, 
```
[ <0, 1> <1, 0> ][ a ] = [ b a ]
[ <0, 0> <0, 1> ][ b ] = [ 0 b ]
```

즉,
Qadder <a, b> = <<b, a>, <0, b>>

따라서, 이에 <c, d>를 적용하면,

```
[ b, a ][ c ] = [ bc + ad ]
[ 0, b ][ d ] = [   b d   ]
```

아주 훌륭하게 연산자가 정의된다.

Qmuler ≜ <<<1, 0>, <0, 0>>, <<0, 0>, <0, 1>>>

열벡터에 대해,
```
[ <1, 0> <0, 0> ][ a ] = [ a 0 ]
[ <0, 0> <0, 1> ][ b ] = [ 0 b ]
```

즉,

Qmuler <a, b> = <<a, 0>, <0, b>>

따라서, 이에 <c, d>를 적용하면,

```
[ a 0 ][ c ] = [ ac ]
[ 0 b ][ d ] = [ bd ]
```

아주 훌륭하게 연산자가 정의된다.

두번째 쳅터로, 동치관계를 주는 부분을 해보고 싶다.

1. (a : b = c : d) : ad = bc 로,
2. (a : b = c : d) : ad - bc = 0 이므로,

아주 정확히 v - w = 0일시 동등하므로,

뺄셈 연산자를 구해야 한다.

Qmuler <-1, 1> = <<-1, 0>, <0, 1>>

혹은

QMinus ≜ Qmuler <1, -1> = <<1, 0>, <0, -1>>

애서, QMinus가 -x 역할을 하는 연산자이므로,

(Qadder QMinus w) 가 (-w) 일것이므로,

해당 연산자를 구하면 된다. 젠장 함수합성시 선형이 아니라서, 선형사상이 아니다...

뭐 그럴만도 하지...

앞으로 QMinus는 여기서 정의한거다.

다음 함수를 보자.

Qcmp(v, w) ≜ ((Qadder (QMinus w)) v) • e₁

이건 비교 함수이다.

이제 우리는 Qadder, Qcmp, Qmuler QMinus를 모두 정의하였다.

참고로, Qrev = <<0, 1>, <1, 0>> 에서, Qrev x는 x의 역수를 구해주는 함수이다.

이렇게 우리는 이제 우리는 Qrev, Qadder, Qcmp, Qmuler, QMinus를 모두 정의하개 될 수 있는것이다.

그리고 이제야말로 진짜로 두번째 쳅터인 동치관계 정의로 넘어간다.

사실은 아까전에는 훼이크였기 때문이다.

두번째 쳅터로, 동치관계를 정의해보자.

v = <a, b> 이고, w = <c, d> 일때,

a : b = c : d 인 동치관계는,

다음 방정식 Φ로 서술된다.

Qeq(v, w) : Qcmp(v, w) = 0

위 방정식은 어떻게 보면 술어이자 관계이다.

1. 의미론적으로 볼때, 유리수체 위의 뺄셈 함수의 방정식에 대해, x - y = 0 ↔ x = y이기에
2. 방정식을 만족하는 해집합 Qeq에 대해, (v, w) ∈ Qeq ↔ ((v, w) ⊨ Qeq) ↔ Qeq(v, w)이기에, 이 술어이자 관계 Qeq는 유리수체 위의 동치관계를 노리고 코딩하였음을 쉽게 알 수 있다.

이하에서 Qrev, Qadder, Qcmp, Qmuler, QMinus, Qeq를 모두 설명했다.

### 후명세 : Qrev, Qadder, Qcmp, Qmuler, QMinus, Qeq

0. Domain

𝔻 ≜ ((𝕍²)² ∪ 𝕍² ∪ 𝕍 [𝕍 := ℤ²]

1. Constants

Qminus = <<-1, 0>, <0, 1>>
Qrev = <<0, 1>, <1, 0>>
Qadder = <<<0, 1>, <1, 0>>, <<0, 0>, <0, 1>>>
Qmuler = <<<1, 0>, <0, 0>>, <<0, 0>, <0, 1>>>

2. Functions

Qcmp(v, w) = ((Qadder (QMinus w)) v) • e₁

3. Relation

Qeq(v, w) : Qcmp(v, w) = 0

이렇게 Qrev, Qadder, Qcmp, Qmuler, QMinus, Qeq가 명세된다.

## Quatro Real

Quatro Real은 두가지 파트로 구성된다.

1. Quatro Relation System Metrix
2. Quatro Number

그리고,

Quatro Relation System Metrix와 Quatro Number도 두가지로 구성된다.

먼저, Quatro Relation System Metrix는
1. QRSM FakeLog Model
2. QRSM Standard Inclusive Model

그리고, Quatro Number는,
1. QN Cauchy Sequence
2. QN Ultraproduct Sequence

QRSM FakeLog Model부터 보자.

### QRSM FakeLog Model

QRSM FakeLog Model은 다음과 같은 모델이다.

(근데 내가보기에는 Lava시스템 기준에서는 걍 대수구조급으로 단순힌 모델인데)

QFLM ≜ <ℚ ∪ ℤⁿ ∪ {S | S ⊆ ℕ}, ¥, gcd, lcm, fac, p, ₩, $, €, FakeLog> [n := ∞]

#### QFLM 선명세

이번엔 명세가 먼저다.

0. Domain

1. Constants

¥ ≜ Σ $

¥가 무한합인데, 정의되는 이유는 $를 참고하라. (보면, $는 기저벡터 e에다가 그 차원번째 순서(0부터 시작해야하는데 축의 차원은 1부터 시작했기에, "차원번째 소수"가 아닌, "차원번매 순서의 소수"라고 한거다. 축의 차원이 t면, t - 1번째 소수인 샘이다)의 소수를 FakeLog를 취해서 곱해준다. )

2. Functions

gcd S ≜ if (|S| = 1) {
    return x s.t. x ∈ S
} else if (|S| = 2) {
   if (0 ∈ S) {
       return x s.t. 0 ≠ x ∈ S
   } else {
       return gcd {min S, (max S) mod (min S)}
   }
} else {
    return gcd {gcd (S - {min S}), min S}
}

와... 함수 분기가 너무 많아가지고, 거의 psudo code급.. ㄷㄷ

gcd가 집합을 인자로 받은 이유는, 가환 반군을 이루기 때문이다. 사실 가환군을 이루는지 가환군을 이루는지는, 잘 모르겠고, 에초에 군을 이루면 반군도 이루니까....

암튼 gcd에서, |S| = 2일때의 처리는 유클리드 호제법의 처리이다. base condition은 0 ∈ S이며, 이때는 인자를 리턴해주므로, Tail Requation이다.

psudo code인 python예제로는,

```python
# req : 3.10 >= version

def gcd(x : set):
    match len(x):
        case 1 :
            ret, = x
        case 2 :
            if 0 in x:
                ret, = x - {0}
            else:
                ret = gcd({min(x), max(x) % min(x)})
        case _:
            ret = gcd({gcd(x - {min(x)}), min(x)})
    
    return ret
```

lcm S ≜ (Π S)/(gcd S)

이렇게 정의한 이유는,
Π S = (lcm S)(gcd S)이기 때문이다.

수열의 곱인 파이 `Π`가 집합을 받은 이유는, 시그마 `Σ`처럼, 집합 내를 일괄적으로 계산하는걸 나타냈기 때문이다.

에초에 시그마와 파이가 기존의 gcd(x, y)및 lcm(x, y)처럼 적어도 기환반군을 이루는 연산자들은 저런식으로, 집합을 인자로 두어 코딩할수 있기에, 의미론적으로 동일한 feature를 만들수 있다는거다.

참고로, 나는 feature를 코딩하는 관점에서, 어떤 객체의 구성을 설명할수 있다는 사실에서, 엘런 튜링이 생각했듯, 수학을 코딩처럼 보고 정리하는 방식도 탁월하다고 본다.

이것도 psudo code인 python으로 보이면,

```python
from math import prod

def lcm(x : set):
    return prod(x)//gcd(x)
```

pₙ ≜ if (n = 0) {
    return 1
} else {
    return min ({x | ∀k ∈ ℕ₀ ∩ (, k), gcd {pₖ, x} = 1} - {0})
}

이렇게 정의하면 p₀ = 1이 소수인지 아닌지는, 수열 인자에 0부터 시작할것인지 정하는것과 같다.

그리고 0이 Natural한지 혹은 1이 소수인지는 재미없는 주제이니 넘어가자.

사실...

>
> 이러한
> 
> p₀ = 1
> 
> pₙ = min ({x | ∀k ∈ ℕ₀ ∩ (, k), gcd {pₖ, x} = 1} - {0})
>
> 수열의 귀납적 정의이다.
>

어떤 n에 대해서도 후자가 존재하기에 소수열은 무한하다. (**중요**) (유클리드가 소수가 무한함을 증명시에, 모든 소수와 서로소인 수를 말했다는점이 주목할것.)

₩ₙ ≜ if (n = 0) {
    return -1
} else {
    return pₙ
}

위에 있는 유사소수열 ₩ₙ에서, ₩₀ = -1 이므로, 정수의 소인수분해에 매우 유용하다.
특히 𝕍 = 𝔹 × ℕ₀ⁿ [𝔹 := {0, 1}][n := ∞]인 𝕍로 소인수분해할것이라면 금상첨화.

이것은 `-1`을 소수처럼 다뤄서, 음의 정수까지 다루기에, 진짜 졍수범위 소인수분해다.

그래서 저것은

>
> 이러한
> 
> ₩₀ = -1
> 
> ₩ₙ = pₙ
>
> 분기별 수열의 정의이다.
>

자, 그런데 같은방법으로, 유리수를 소인수분해할수 있다는 사실은 우리를 소름돋게 한다.

$ₙ ≜ FakeLog(₩ₙ₋₁)eₙ

그렇다. $ₙ은 fac에서 말할 친구이다.

그전에 먼저 €를 소개하겠다.

€ ≜ (• ¥)

€가 내적 기호에 대한 Functor를 쓴걸 알 수 있는데, ¥가 뭔지는 상수 목록 참고.

FakeLog(x) ≜ €(fac(x))

이게 뭘 의미하는지는 곧 알게 될거다. fac을 통해서 말이다.

fac(x) • ¥가 벡터인 fac(x)에 소수열을 곱해주는 모양세이다.

즉, Σ fac(x) • Sₖ 인 형태이다.

왜 이게 될까?

fac(x) ≜ if (x < 0) {
    return <1, f(x)>
} else {
    return <0, f(x)>
} [f(x) := if (x ∈ ℕ) {
    return g(x, 1, Σₖ 0 eₖ)
} else {
   return f(first(x)) - f(last(x))
}] [g(x, k, ret) ≜ if(x = 1) {
    retuen ret
} else if (gcd(x, pₖ) = pₖ) {
    return gcd(x/pₖ, k, ret + $ₙ)
} else {
    return gcd(x, k + 1, ret)
}] [first(x, y) := x] [last(x, y) := y] [COMMENT := ("g는 평범한 자연수 소인수분해 알고리즘이다... 원래는 while문을 이용해서, pₖ으로 나눠지지 않을때까지 나누면서, 리턴값인 벡터에, 소인수의 지수를 적어야하는데, 여기는 그런거 없으니, tail Requation의 flow를 이용했다. 솔찍히 어떻게 되더라도, 명세만 만족하멷 된다. (Tip : fac(1) = <0, ..., 0>이기에, 인자로 받은 리턴값 ret을 리턴하는거다. (Tip : 마지막 else는 나눠지지 않을때, 다음 소수에 대한 처리다. (Tip : 의도한대로 실행되는 이유는 처리 흐름을 따라가보면 알 수 있다.))", "x < 0인경우는 따로 음수 비트를 활성화하는것 뿐이니 나머지 부분을 설명해보자. f에서, 자연수가 아니면 f(first(x)) - f(last(x))로 처리하는걸 보았을것이다. 이걸 해설해보이겠다.", "벡터는 튜플이므로, first(<x, y>) = x이며, last(<x, y>) = y에서, f(first(x : y)) - f(last(x : y)) = f(x) - f(y)인것이다. 이게 `핵심`")]

이해을 돕기 위해 g만 특별히 psudo-code로 써보겠다.
psudo-code용 언어는 python이다.

```python
from its_せかい에_어ㅂㅅ다 import primes, inf_vector

def original_ver(x):
    p = 2
    ret = []
    while x != 1:
        if x % p:
            p += 1
        else:
            x //= p
            ret.append(p)
    return ret

def vector_ver(x, k = 1, ret = inf_vector.full_zero()):
    while x != 1:
        if x % primes(k):
            k += 1
        else:
            x //= primes(k)
            ret[k] += 1
    return ret

def finnally_tailreq_ver(x, k = 1, ret = inf_vector.full_zero()):
    if x == 1:
        return ret
    elif x % primes(k):
        return finnally_tailreq_ver(x, k = k + 1, ret = ret)
    else:
        ret[k] += 1
        return finnally_tailreq_ver(x // primes(k), k, ret)
```

휴... 이정도면 이제 쉬울것이다.

### 후설명

fac(±x/y) = <(1∓1)/2, 0, ..., 0> + fac(x) - fac(y) 이며,

fac(x) = <0, a₁, ..., aₙ> s.t. x = Πₖ (pₖ ↑ aₖ) 이다.

즉, fac(x) • (Σₖ ₩ₖ₋₁ eₖ) = x 이다.

F(x) + F(y) = F(xy)라면,

z = x/y 에 대해, x = yz이므로,

F(z) + F(y) = F(x)에서, F(z) = F(x) - F(y) 이므로,

F(x/y) = F(x) - F(y) ... (1)

Σₖ F(x) = nF(x) = F(Πₖx) = F(xⁿ) [k := 1 ~ n]

F(x) - F(y) = F(x) + F(z) = F(x + z) 에서,

x + z = x - y이므로, z = -y

-F(y) = F(-y)

따라서, 정수 n에 대해, nF(x) = F(xⁿ)

nF(ⁿ√(x)) = F(x)에서, (1/n)F(x) = F(ⁿ√(x))으로, 유리수 p에 대해, pF(x) = F(xⁿ)

유리수 p, q에 대해,
pF(x) + qF(x) = (p + q)F(x) = F(px) + F(qx) = F((p + q)x) ... (2)

이게 코시 수열을 극한으로 보내줬을때도 성립하는 이유는 잘 모른다.

아무튼 (1), (2)에서 F는 로그법칙을 만족한다.

그런데, 정수에 대한 소수 범위에서,

FakeLog(Πₖ (₩ₖ ↑ Aₖ)) = Σₖ Aₖ FakeLog(₩ₖ) 를 만족한다.

즉, 정수 Aₖ에 대해, fₖ(x) = FakeLog(₩ₖx)인 fₖ는 선형이고, 따라서, 정수 Aₖ범위에서 FakeLog는 (1), (2)의 로그법칙을 만족한다 (**중요**) (¤ 핵심임 ¤)

FakeLog(Πₘ pₘⁿ [n:= Aₘ]) = Σₘ FakeLog(pₘⁿ) [n:= Aₘ] 이기에, 유리수체 위에서 로그법칙을 만족하지만, 역함수가 지수함수라는 보장이나, 밑변환이 된다는 보장이 없으니 유사 로그함수이다.

즉, 치역은 "codom FakeLog"이고 이것은 잘 규정된 대상들의 모임이므로, 객체의 모임이고, FakeLog객체인것이다.

아무튼 이러한 방식으로 **유리수에 대해 곱셈과 덧셈과 로그법칙이 적용되는 함수 FakeLog가 정의되어서, 곱셈을 이루기 위해서 소수를 최소원으로, 그 지수를 나열한 벡터를 자료형마냥 다룰수 있는 체계가 준비되었다.**

### QRSM Standard Inclusive Model

QRSM Standard Inclusive Model은 다음과 같은 모델이다.

Quatro로 정의된 유리수 ℚ에 대해, Qrev, QMinus, Qadd, Qmul정의되었으니, Qsub, Qdiv를 각각 f(x, y) = Qadd (QMinus y) x인 f와 f(x, y) = Qmul (Qrev y) x 인 f로 정의하면, Quatro로 유리수체를 준비할 수 있다. 이러한 ℚ를 유리수체로 다루겠다.

다음은 n-QRSM Standard Inclusive Model 이다.

`Mₙ = <((ℚⁿ)ⁿ) ∪ ℚⁿ, zero_vectorₙ, QSIMImplicitFunctionₙ, L_QSIMIFₙ, R_QSIMIFₙ`....



... (작성중) ...
````

## 주요

### 알게 된 정보



#### Abstract Collection등등

````markdown
# Abstract Collection

## 2025.09.26

(주의 : 이 글에서 Abstract Collection은 스칼라가 실수 전체일수도 있음에도, 아니 사실상 기본적으로 유리수임은 깔고가는거에도 불구하고, 슬라이싱이나 인덱싱같은걸 할때, 범자연수처럼 취급합니다. 주의하세요.)

Abstract Collection이란 내가 발견한 연산인데, 나는 보통 배열류 객체를 프로그래밍의 컬렉션으로 보는 시각이 있다.

그런데 이제보니, Sequence나 Tuple이나 Vector나 공통된 추상적 속성이 있는것같다고 느끼고 발견한 추상적 객체를 지지난주쯤이 적어놨다.

처음 여러번 적다 정리한 Abstract Collection을 지난주 쯤에 완성된 서술본을 만들었고, 이번에 아예 github에 포스팅할겸 새롭게 적어놨다.

그래서 실제로 모델을 제시할때쯤 되야 이것인 그제서야 없는 대상에 대한 이상한 논의가 아니게 될것이다.

지금부터 말하는 내용들중에 근거를 찾을수 없는 내용은 전부 어쨌든 Ac의 성질에 따라 성립하는것이니,

추후에 사실상 대수구조인 모델 <Ac, -•, •[L], •[•], •[:•], •[•:], •[::•]>을 통하여 재대로 성질에 대한 공리계를 만들어 정의해야겠다고 생각한다.

어쨌든간에 나답게 맥락없이 바로 본론으로 들어가자.

Abstract Collection의 집합 Ac에 대해,

닫힌 연산인 Collection concat연산 •[•]은

∀A, B, C ∈ Ac, A[B[C]] = A[B][C] 이다.

즉, 결합법칙을 만족하므로, 반군을 이룬다.

Empty(=Blank) Collection ε에 대해,

A[ε] = A = ε[A]

즉, ε는 Collection concat연산의 항등원이다.

따라서, 반군이 항등원을 가지므로, 모노이드이다.

길이를 제는 연산은 ∀A ∈ Ac, A[L]인데, 이 연산 역시 닫혀있다.

그렇다. 보통의 연산에 대하여 A는 벡터공간을 이루므로, A[L] = 1c인 A는 Ac의 스칼라와 동형이다.

애초에 정의 자체가 SIMD연산처럼 배열간 잡연산이 처리되니 벡터공간을 이루는거지만 말이다.

중요한건 체 F위의 벡터공간은 합과 스칼라배만 정의되면 된다는거다.

스칼라 S에 대해 S¹, S², S³, ..., Sⁿ [n := ℵ₀]까지 싹다 합집합으로 묶은 백터공간인 셈이다.

정의상 벡터공간인 점에 주목해서 보자.

참고로, ε[L] = 0c이다.

참고로, 1c, 0c는 쌍대기저 c'가 A[L] = 1c인 A의 집합에서 스칼라로 가는 동형사상이므로, c' 1c = 1, c' 0c = 0인 1c, 0c이다.

그러나, Ac에서 벡터공간들의 기저공간의 기저는 차원 축에 대하여 유일하다.

그러니까, A[L] = 2c이고, 2c[L] = 1c이니, A = ac + bc₂일때, 기저 c, c₂는 2c, 1c에서 기저 c에 대해, {c}의 확장으로 {c, c₂}가 있는것으로 두 c는 같다.
그러니까, 진짜로 무한차원 벡터공간의 기저가 모든 차원을 죄다 생성한 벡터공간들의 합집합인 이 컬렉션 셋에서, 저차원의 공간은 국소적으로 축을 줄였을 뿐이지, 벡터공간을 이루게 하는 핵심 요소인 기저는 같은거다.

사실 길이가 같은 배열끼리만 벡터연산할꺼니까 달라도 되긴 하는데, 설명을 위해서 비표준적으로 같게 설정했다.

사실은 실제 정의상에서 기저는 다르다! 지금 저 "c"를 쓰고싶어서 저젛게 잡은거다. 표준적으로는 다르다.

벡터로써의 연산 *에 대해,
A, B, C = A * B에서,

first(x, y) = x
last(x, y) = y

를 정의하고,

tuple의 제귀적 정의에 따라,

first <x, y> = x
last <x, y> = y

이므로, 벡터에다가 first와 last를 적용할수 있음으로, 이를 통하여 C를 설명하겠다.

Ac에서 Vector연산은 정확히 Vectorized SIMD연산과 동형이다.

first C = (first A) * (first B)

이고

last C = (last A) * (last B)

이라는거다.

어찌보면 이쯤되면

사실상 A[L] = (dim A) c이지 않냐고 할수 있겠다.

뭐... 기저 c = 1c이므로 맞긴 하다.

그니까 이 벡터공간에서 유일하게 스칼라와 연산하는건 상수배밖에 없으며,

유일하게 길이가 다른 연산은 Ac의 고유연산이다.

행렬곱을 추가하면 되지 않느냐고 생각할수 있는데,

행렬이나 텐서를 코벡터로 취급하는 기법을 이용하여, rank-1텐서인 벡터공간 𝕍를 스칼라로 놓는다면, 그건 rank-2텐서인 행렬이고, 그걸 또 스칼라로 놓고 이런식으로 뇌절해서 구하면, 사실상 1 × n행렬, 즉 행벡터와 1 × 1행렬인 일차원 벡터를 곱하는것과 같으므로 보통을 필요성을 느끼지 못한다.
그럼에도 더 생각해보자면 결정적인 문제로, 벡터간의 곱셈은 n벡터와 n벡터사이의 상수배가 아닌 곱셈만이 정의되는데, 보통은 행렬표현을 한다면, 곱셈은 행렬곱으로 취급하므로, 행렬곱과 오인의 여지가 있기에 기호 혼용의 여지때문에 정의하기 더럽게 까다롭다.

그래서 사실 1×1행렬과 1×n행렬을 곱하는 시나리오도 같이 영원히 사요나라~ 하면서 정의하지 않은거다.

신기한걸 보여주겠다. •[L]은 다음과 같은 준동형사상이자 자기사상이다.

A[B][L] = A[L] + B[L]

그리고 영벡터들에 대해 생각해보자면,

(0A)[0B][L] = (0A)[L] + (0B)[L]

으로 자기동형사상이다.

마지막으로, functor ([L][L])는 상수함자인데,

A[L][L] = 1c이다.

그래서 지금부터 1c = codom ([L][L]) 으로 취급하겠다.

Collection reverse 연산자 -• 에 대해서, 

-(-A) = A이고 involution이다.

-(A[B]) = (-B)[-A] 를 만족한다.

(-A)[L] = A[L]이다.

Collection Slicing 연산자 •[•:]및 •[:•]및 •[::•]에 대해

A와 I[L] = A[L][L]에 대해, A[:I][L] = I이다.
또한, I ≤ A[L]일때, -(A[:I]) = (-A)[:A[L] - I]이다.

마치 처치 인코딩의 뺄셈같이 I > A[L]일때, -(A[:I]) = ε이다.

역정렬 연산자 - • 와 뺄셈을 명확히 구분하여 이해하도록 하자.

J[L] = I[L]이라면,

A[I:][J:] = A[I + J:]이고
A[:I][:J] = A[:I + J]이다.

사실상 자기사상 함자 [I:], [J:], [:I], [:J]에 대하여,

[I:][J:] = [I + J:], [:I][:J] = [:I + J]인

f(x) = [:x]혹은 f(x) = [x:]에서,

f가 f(x + y) = f(x) ◦ f(y)인 준동형사상이자 자기사상이다.

python에서 slice객체가 start:end:step순이듯, 여기서 •[::•]는 step순이다.

마치 python list x에 대해, y[n] = x[kn]인것같이 만드는것같은 심상이 든다.

A[::I][L] = k + I[L]은 A[L] ÷ I = k ••• (A[L] mod I)이듯이 k이다.

A[::I][::J] = A[::I×J]이다.

즉, [::I][::J] = [::I×J]로, 요것은 또, f(x) = [::x]일때

f가 f(I×J) = f(I) ◦ f(J)인 준동형사상이자 자기사상인것인거다.

A[I:][:I[L]] = A[:I+I[L]][I:]이다.

indexing처럼 생각하면 편하다.

[::I][J:][J[L]:] = [I×J:][:I[L]]이다.

다시한번 말하지만 마치 python list x에 대해, y[n] = x[kn]인것같이 만드는것같은 심상이 든다.

n벡터 A에 대해,

1. n + k = n
2. 0 - k = 0
3. -k = n - k
4. p × q > n이라면, p × q = n으로 한다.

라는 규칙을 추가해서, [0, n)범위의 자연수에서만 마치 셀처럼 작동하는 수 체계를 Collection Index System이라고 하겠다.

-f = (-•) ◦ f식으로 reversed연산자를 정의한 표기법을 Nero라고 하겠다. (작명은 내맘임 ㅋㅋ 검은고영이 네롴ㅋㅋㅋ Nego에서 g를 r로 바꿨다. 고양이가 연상되는게 마음에 들기 때문이... 사실은 지금 Night Dansor듣고있어서 감성이 충만해서 그런 감도 있고, 진짜로 ㄹㅇ로 작명은 완전 개썅마이웨이여서 그렇다.)

Nero와 Collection Index System에서,

-[:I] = [I:]이고,
[:I][:J] = [:I + J]이며,
[::I][::J] = [::I × J]이다.

[;]은 함자의 최초 입력을 뜻하고, [;][L]은 최초 입력의 값의 길이를 말한다.

따라서, [:[;][L]] = I이다.

사실 함자식 P에 대해, P(x)가 P([;]) [[;] := x]로 평가받는 셈이다.

나는 Collection Index System가 수직선상의 ln(x)스케일에서, 정의역을 n등분하여, 상한이 최댓값이고 그걸 n으로, 하한이 최솟값이고 그걸 0으로 하는 자연수 서수로 대응시킨 수 체계 집합같다고 느낀다.

그리고 •[•:], •[:•], •[::•], •[•], •[L]가 Collection Index System과 동형인 구석을 통해 대부분 설명된다고 본다.

아예 그냥 [X]식으로 함자를 만들면, 단항연산 •[L], (-•) 및 연산 •[•], •[:•], •[•:], •[::•]과 함자 [•], [:•], [•:], [::•]에 대하여, 동형성등 닮은구석이 많은 Collection Index System와 비교하는 방법으로 정리할수 있을것이라고 본다.

그러면 오늘은 "슬라이싱되는 무언가"에 대해, 지지난주 정도에 발견한 Ac를 적어보았다.

의사코드 예시로 python코드를 적고 끝내고싶지만 귀찮다.
(현 고딩인데 Python이 제2외국어 선택 과목인데 python을 평소에 안쓰고 공부도 전혀 안하는데 제2외국어 선택에서 저득점이아니라 만점맞고, 심지어 처음보는 라이브러리도 알아서 척척 이해할정도로 내부구조와 바이트코드 및 문서화 및 클린코드와 모듈화 및 라이브러리 제작법까지 다 아는 내가 python으로 프로그래밍하는데 어려움이 있는건 아니지만, 귀찮다고 하는건 작업이 쉬운데도 안하는것으로, 그냥 나태한거다. 돈을 굶겨봐야 정신을 차릴거다 아마도. 사실은 애니보고싶은데 동시에 작업하기는 귀찮아서 미룬거다. ~~이미 그러고 있지만~~)

나같으면 int랑 tuple을 다 상속받아서 연산을 구현한 후, ε, 0, 1은 기본적으로 클래스에서 상수처럼 가지고 있으며, __neg__에서, tuple->yield이용하거나 이터레이터 이용하여 역방향->tuple해주고, __getitem__에서 len을 받아서 len(self)해주며, 여러 연산들을 구현해야하는데, 굳이 그런 괴상한짓을 할 이유가 무엇인지 모르겠다.

개다가 젠장할, slice부분에서, 음수를 넣지 말아야하며, start, end, step부분을 각각 적절히 우리 시스템에 맞게 python타깃으로 컴파일하여, start는 길이 이상이면 ε를, end는 0이면 ε를 리턴하는 아주 개꼴받게 힘든짓을 해야한다.

결정적으로 [;]같은 노테이션이 안통하고, Collection Index System같은 경우 int비스므리한 자료구조를 하나 더 만들어야 한다.

다음번에는 그 귀찮은 과정을 직접 해와서 코드를 적을것이다.

그렇기에 마크다운에서도 `###`가 아닌 `####`로 된 곳에 날짜를 적어서 이 글을 부연설명하는 문단정도로 만들거다.

아마 곧 만들어올거다.
````

#### 어떤 대수학 명제는 ε-δ 없이 증명 • 반증 불가

초월수와 실수의 완비성 관련된 부분.

어떤 대수학 명제는 ε-δ 없이 증명될수 없음을 밝힌 점.

````markdown
# Euler

```
Fact) ¬p ∧ p ↔ ⊥
Fact) ¬(±1 = +1) ↔ (±1 = -1)
p.f. 결론을 부정하여, p = (±1 = +1)에서, q = (±1 = -1) ≠ p로 놓자.
그러면, p ∧ q ↔⊥이므로, p와 q는 모순관계에 있으므로, 결론을 부정하면 거짓임을 알 수 있다.
Q.E.D.
Fact) (¬p → q), (p → q) ⊨ q
Fact) ((±1 = +1) → q, (±1 = -1) → q) ⊨ q
p.f. 항진명제를 늘어트려서 이야기하자면, ¬(±1 = +1) ↔ (±1 = -1)이고, (¬p → q), (p → q) ⊨ q이므로,
p = (±1 = +1)로 대입하면,
((¬p → q), (p → q) ⊨ q) ↔ (((±1 = +1) → q, (±1 = -1) → q) ⊨ q)이므로, 결과도 항진명제다.
Q.E.D.
Fact) z = x + yi이면 z̄ = x - yi
pf. z̄의 정의가 z = x + yi인 z에 대해, x - yi이므로,
z = x + yi이면 z̄ = x - yi
Q.E.D.
Fact) ((x + yi) ± (x - yi))/2iᵗ = ((1±1)/2iᵗ)x + ((1∓1)/2iᵗ⁻¹)y [t := ((1∓1)/2)]
p.f. 결합법칙, 분배법칙, 교환법칙, 결합법칙, 분배법칙, 곱셈의 교환법칙, 곱셈의 교환법칙 순으로 적용하여 계산하면,
((x + yi) ± (x - yi))/2iᵗ [t := ((1∓1)/2)]
 = (x + yi ± (x - yi))/2iᵗ [t := ((1∓1)/2)]
 = (x + yi ± x ∓ yi)/2iᵗ [t := ((1∓1)/2)]
 = (x ± x + yi ∓ yi)/2iᵗ [t := ((1∓1)/2)]
 = ((x ± x) + (yi ∓ yi))/2iᵗ [t := ((1∓1)/2)]
 = (1±1)x/2iᵗ + (1∓1)yi/2iᵗ [t := ((1∓1)/2)]
 = ((1±1)/2iᵗ)x + ((1∓1)/2iᵗ)yi [t := ((1∓1)/2)]
 = ((1±1)/2iᵗ)x + ((1∓1)/2iᵗ⁻¹)y [t := ((1∓1)/2)]
Q.E.D.
Fact) ((x + yi) ± (x - yi))/2iᵗ = ((1±1)/2)x + ((1∓1)/2i¹⁻ᵗ)y) [t := ((1∓1)/2)]
p.f. ((x + yi) ± (x - yi))/2iᵗ = ((1±1)/2iᵗ)x + ((1∓1)/2i¹⁻ᵗ)y [t := ((1∓1)/2)]일때 ((1±1)/2iᵗ)x + ((1∓1)/2i¹⁻ᵗ)y = ((1±1)/2)x + ((1∓1)/2)y를 증명하면, 증명할수 있기에, ((±1 = +1) → q, (±1 = -1) → q) ⊨ q에서, q에 맞는 논리식을 계산하면,
±1 = +1일시) ((1±1)/2iᵗ)x + ((1∓1)/2i¹⁻ᵗ)y = ((1+1)/2iᵗ)x + ((1-1)/2i¹⁻ᵗ)y = x = ((1+1)/2)x + ((1-1)/2)y = ((1±1)/2)x + ((1∓1)/2)y [t := (1∓1)/2 (=(1-1)/2 =0)]
±1 = -1일시) ((1±1)/2iᵗ)x + ((1∓1)/2i¹⁻ᵗ)y = ((1+1)/2iᵗ)x + ((1-1)/2i¹⁻ᵗ)y = x = ((1+1)/2)x + ((1-1)/2)y = ((1±1)/2)x + ((1∓1)/2)y [t := (1∓1)/2 (=(1-1)/2)]
따라서, q = ((x + yi) ± (x - yi))/2iᵗ = ((1±1)/2)x + ((1∓1)/2i¹⁻ᵗ)y)
Q.E.D.
Fact) z = x + yi일때, (z ± z̄)/2iᵗ = ((1±1)/2)x + ((1∓1)/2)y [t := ((1∓1)/2)]
p.f. z = x + yi이면 z̄ = x - yi이고, ((x + yi) ± (x - yi))/2iᵗ = ((1±1)/2)x + ((1∓1)/2i¹⁻ᵗ)y) [t := ((1∓1)/2)]이므로,
대입법을 이용하여 풀면,
(z ± z̄)/2iᵗ = ((x + yi) ± (x - yi))/2iᵗ = ((1±1)/2)x + ((1∓1)/2)y [t := ((1∓1)/2)]이다.
Q.E.D.
Fact) z = cis θ에서, z̄ = cis(-θ)
p.f. cos는 우함수, sin는 기함수이므로,
z = cis θ에서,
cis(-θ) = cos(-θ) + sin(-θ) = cosθ - i sinθ = z̄
Q.E.D.
Fact) z = cis θ에서, z̄ = z⁻¹
pf. z = cis θ에서, z̄ = cis(-θ)이므로,
(cis θ)⁻¹ = cis(-θ) = z̄
Q.E.D.

Φ(z) : z ± 1/z = (z² ± 1)/z
Ψ(x, y, z) : z = x + yi ⊨ (z ± z̄)/2iᵗ = ((1±1)/2)x + ((1∓1)/2)y [t := ((1∓1)/2)]
P(z) : z̄ = 1/z
Θ(x, y, z) : Φ(z), Ψ(x, y, z), P(z)

Fact) P(z) ↔ (zz̄ = 1)
Fact) Θ(cos θ, sin θ, cis θ)
p.f. 나머지는 전부 항진이니, P(z) ↔ (zz̄ = 1)에서,
cisθ × cis(-θ) = cos²θ + sin²θ = 1
Q.E.D.
Fact) zz̄ = 1 ↔ z = cisθ
pf. 양방향함의는 논리적 동등 기호 `↔`이기에 분해 가능
1. zz̄ ≠ 1에서, cisθ × cis(-θ) = cos²θ + sin²θ = 1로 모순이므로, zz̄ = 1 → z = cisθ
2. z̄cisθ ≠ 1에서 zz̄ = 1일때, z = cisθ이므로, 모순.
```

Q.E.D.

질문 : 그렇다면 f(n) = aⁿ이 주기함수라면, cis(τn/T)로 표현 가능한가?
````

답변 : 그건 초월수와 실수의 완비성을 건드려서 ε-δ를 꺼내게 한다.

어떤 점 변항이 0에 한없이 근접하는 행태를 보이기 때문이다


## 부가

### 수학의 메타분석 구조

SemiProbability와 UBDG라는 수학의 메타분석 구조를 소개한다.

이 구조가 왜 발생하는지 솔찍히말하자면 너무 궁금하다.

#### SemiProbability

```markdown
# semiProbability and ㄴStatisticalMetaSystem

일단 말하기 앞서 다음과 같이 공리적 확률론을 분할할 생각임.

Kolmogorov’s axioms
 - Probability (including contingent proposition)
 - semiProbability (allow only formal proposition)

## semiProbability on DiscreteUniformDistribution (DUD-semiProb)

표본공간 Ω가 이산균등분포인 경우다.
이 경우 역시 두가지로 나누겠다.

DUD-semiProb
 - Finite-DUDSemiProb (|Ω| < ℵ₀)
 - infinite-DUDSemiProb (|Ω| = ℵ₀)

### Finite-DUDSemiProb (F-DUD-SmPr)

이 경우에는 매우 특이한 상황이 된다.

P(Φ)가 Φ일 확률이라고 치면,

P(Φ) = |Mod(Φ)|/|Ω|

를 만족하기 때문이다.

따라서 이때 두가지를 정의하겠다.

ㄴSIZE ≜ |Ω|
ㄴNumberOfCase ≜ ㄴSIZE P

굳이 `ㄴ`을 쓴 이유는 원래는 `ㄱSIZE`, `ㄱNumberOfCase`와 같이 써서 혹시모를 중복을 피하려고 했는데, `ㄱ`이 부정(Nagation) 기호같이 생긴 탓에 `ㄴ`을 골랐다.

표본공간의 측도가 ㄴSIZE이 되고, 경우의 수가 ㄴNumberOfCase가 되는데, P(Φ) = |Mod(Φ)|/|Ω|이기에,
이런 P를 ㄴSIZE배 해준 ㄴSIZE P는  |Mod(Φ)|이기에, ㄴNumberOfCase는 |Mod(Φ)|이다.

이렇게 두가지 심볼 ㄴSIZE 및 ㄴNumberOfCase가 정의된 모델을 ㄴStatisticalMetaSystem 이라 하겠다.

#### ㄴStatisticalMetaSystem (semiProbability에서 새로 정의한 ZFC를 분석하는 Meta System. (사실상 Model이고 확률론 공리계의 Extension처럼 동작하지만, 그냥 메타적으로 분석하니까 메타시스템이라고 함.))

ㄴStatisticalMetaSystem는 다음 Symbol이 정의되고 다음 Axiom이 만족된 Kolmogorov’s Axioms & ZFC 위의 Model Structure이다.

1. Constant Symbol Assignment

ㄴSIZE ≜ |Ω|

2. Function Symbol Assignment

ㄴNumberOfCase ≜ ㄴSIZE P

3. ㄴStatisticalMetaSystem Axioms

∀A ⊆ Ω, P(A) = |A|/|Ω|

4. ㄴSMS Notation (선택사항, 그냥 표기 방식 명시)

ㄴNumberOfCase(Predicate)
 = ㄴNumberOfCase(Predicate ∩ Ω
 = ㄴNumberOfCase(Mod(Predicate) ∩ Ω)

식으로, 어떤 명제를 술어로 다루겠다는거. 어짜피 술어가 집합이니까 이 표기법은 옳은 표기법이지만, 명확히 할 필요가 있음.

이하에서, ㄴSIZE = t면, 그 ㄴStatisticalMetaSystem을 t-ㄴSMS 라고 하겠다.

t-ㄴSMS에서, 케이스의 수 (ㄴNumberOfCase)는 술어(=문장)가 만족되는 케이스의 수이기에, 모델집합의 카디널을 다루는것이다.

또한 이건, ZFC에 대한 메타분석처럼 볼 수도 있다. 판단 대상이 ZFC상의 논리를 가지고, 모델집합의 측도를 분석하기 때문이다.

매우 흥미롭고, 조심해야할것같다.
```

#### UBDG (a.k.a. 과학구조)

```markdown
# 과학구조 (유추 구조, 가정구조공리술어, 통계구조생성자, 귀추 구조)

유추 구조, 가정 구조, 귀추 구조는 각각 수학적 수식 혹은 술어이거나 대수 구조이다.

그러니까 과학구조는 탐구방법론같은 시시콜콜한 과학자들의 좆 비스무리한 개쓰래기 똥 씨발 멍청한 찐따같은 씨발 좆이 아니라 그냥 Fuck도 아니고 과학이라는 Fuck 똥 씨발 좆 좆 좆이 아니라 씨발 그런 개같은게 아니라, 술어 혹은 시시콜콜하고 좆같은 술어보다는 사실은 대수구조 및 대수에서 구성한 함수(연산)이다. 그러니까 모델론 및 범주론 및 추상대수학적인 연구 대상이다.

통계 구조는 유추 구조로 만들어지며 그러지 않는다면 빛 좋은 개살구다. (통계적 구조는 퍼지논리 공리계의 모델을 제시하는 전혀 다른 통계의 언어로 구성한 수학 언어를 쓰는데 이것이 무려 일반 수학의 확장이다. 따라서 나는 연역법 만능주의자기 때문에 이런걸 좆같아해서 통계적 구조를 유추 구조로 환원해서 연역화하지 않고 제시한다면 내가 당신 목따러 달려갈수도 있다.)

N.B. 씨발씨발 좆좆같네 아아아악이거는 절대 좆 shit 등신같은 과학이 아니라 과학처럼 보이는 ZFC및 Alkalic공리계 공통기반 공리이용 추론 혹은 자연연역법을 통한 특정한 추론(유추 구조에서 말하는 추론, 가정구조에서 말하는 추론, 귀추구조에서 말하는 추론)의 대수구조화라고 보면, 어느정도 맞는데 틀리다. 이거는 추론의 대수구조화 그 똥같은게 아니라, 그냥 대수구조다. 여기서 추론을 붙이는것은 금지된다. 의미론적으로 추론으로 규정해버리는 순간 대수구조의 의미가 아니기에, 여기서 정의하는 내용은 대수구조지 좆같이 추론에 간섭하는게 아니라고 해두겠다.

씨발 좆좆좆같은 추론내용에 대한 간섭 싫어

## 유추 구조

Zhegalkin Polynomial에서,

Φₙ : "n번째 관측된 결과"에서,

Ψₙ(Φ) ≜ Πₖ Φₖ [k := 1 ~ n]로 정의하고,

lim Ψₖ(Φ) : ∀n ∈ ℕ, Φₙ (k → ∞)
이므로, 이러한 Ψ를 유추 구조라 한다.

## 통계 구조

정해진 y에 대해, x ↔ y를 FuzzyLogic으로 쓰면,

x ↔ y ~ B(n, pmf(x))이므로,

부울 도메인을 실수로 확장한 Alkalic논리는 실수로 확장됬으니까, 이 경우에 한정하여 원래 불 도메인인 {0, 1}에서와 달리 FuzzyLogic및 확률과 통계의 확률 개념과 동형이다.

따라서,

Alkalic논리에서의 (x ↔ y) = (x = y)로 놓는 순간, Alaklic이 FuzzyLogic을 따르고, x와 y는 확률과 통계의 연언명제가 될 수 있음이 당연하다.

따라서,

H : (x ↔ y) = (x = y)에 대해,

Alkalic에서 논리언어의 모델을 H로 바꿔놓는 개짓거리를 하는 순간, 유추 구조를 통계 구조라고 하고, 이는 수학을 모호하게 만든다. (그니까 H를 공리화하는 좆같은거다, 이게 통계 구조의 포괄적 정의다, 즉, 쓸모없는 좆을 포함한 포괄적 정의.)

통계 구조의 정의는 아래 참고.

### 왜 쓰나?

통계 구조 S(X)에 대해, 이 통계 구조가 본래의 부울 도메인 {0, 1}에서 정상작동할것이므로,

일반적인 Alkalic수학에서 유추구조를 정의한 모델 X만을 정의역으로 하는 S에 대해, (S는 statistics)

S(X) = Y s.t. Alkalic에서 논리언어의 모델을 H로 바꿔놓는 개짓거리를 한것

이고, 이때,

A)
항상 우연명제일줄 알았던 참인 가정을 입력시키는데에 있어 적절한 추론을 썻다면, S(X)가 디렉델타함수의 평행이동으로 동작하며, 동시에, 당연히 이분논리적인 결과가 나오기 때문에

B)
즉, 확률적 추측이 아닌, 통계적 관찰에서 통계는 빼고 관찰만 가지고 연역적 추론을 한 이분논리적 연역법이기에, 건전하게 되는 상황과 동등하기에 (Tip : A ↔ B임)

이에따라서, 무한시도의 무한발생이라는 보편양화적인 과정에 따라서 참이 될 수 있다.

즉, X에서의 Ψ를 S(X)에서의 Ψ로 옮기면, 이것 역시 큰 수의 법칙을 따르며, 심지어 극한을 보내면 연역법이다.

함수 S가 바로 "통계구조생성자"이며, 이것이 통계구조의 정의이다.

#### 그래서 왜 큰 수의 법칙을 따르는걸 만들어놓느냐?

귀추 구조로 유추 구조 Ψ가 의미하는 바가 가설이라는 귀추 구조를 만들수 있기 때문이다.

## 가정 구조

다음 술어 μ를 보라.
μ(H) : Ψ(Φ) = H ∧ (⊨Ψ(Φ))

μ(H)를 가설로 놓아 공리를 설정하는 귀추 구조를 가정 구조하고 한다.

그리고 μ는 "가정구조공리술어"라고 한다.

#### 가정구조 한줄요약 = 가정구조공리술어 한줄요약

"유추구조에서 계량하는 명제가 바로 가설 H이다."는 귀추구조용 공리.

원래 유추구조에서 판단 불가능한걸 의미해석 중간에 빼돌려서 가능하게 함.

## 귀추 구조

가설을 공리로 증명하는 규칙도입계 모델 M을 만들고,

1. M이 일관됬는가?
2. M이 증명하고자 하는 공리계와 호환되는가?
3. M이 증명하고자 하는 공리계에서 증명가능한가?

절차로 만족시키면, 증명될것이므로, 이러한 M을 귀추 구조라고 한다.

## 마치며

Q. 추론의 모델링인가요?
A. 그냥 대수구조가지고 추론을 모델링했다? 지랄하네 목적에 벗어나는 과대해석이지? 그냥 어떤 추론과정을 모델링한것과 같은 결과라고 하면 뭐 맞긴한데 그게 핵심이 아니라고. 핵심은, 내가 추론에 대해서 탐구하는중에 대수구조를 하나 발견한거고, 저건 추론이 아니라 대수구조야. 씨발 추론을 모델링한 목적에 충실하지 않은데 뮤ㅓㄴ 개소리야? 에초에 만들어진 이유가 우연히 발견한 대수구조이고, 그 대수구조는 추론의 목적의 충실하지 않으니 수정해야하네가 개소리된다 죽어버려 개씨발아!! 개소리하지마!! 거짓 거짓 거짓!! 추론의 모델링? 아니오 아니오아니오 씨발아 아닙니다!
Q. 추론 과정을 모델링한것과 같은 결과네요?
A. 개씨발새끼야 그럼 미적분은 미분소로 하는게 참이고 무한소쓰는게 표준해석하기겠지 죽어라!! 미적분이 역사적으로 무한소를 쎴지, 초실수체를 다루는 연상이 아닌 δ-ε논법적 연산인것처럼, 과학구조도, 전혀 추론과정따위 좆을 다루능게 아니라 그냥 평범하게 규칙도입계 대수를 이용한 대수구조라고요!!

이 저주받은건 이름부터 "우연이발견한대수구조"(UBDG : U연이 Bar견한 Desu gujo)로 해서 UBDG₀, UBDG₁, UBDG₂, UBDG₃로 고쳐여겠어. 이름이 하느님아버지와 예수님의 분노를 사서 저주받았기에 이렇게 오해받는걸꺼야.
```

## 대수

### 대수학

#### 항 by 대수적 성격

# 항이 뭐가 중요한진 모르겠지만 노트중

```markdown
항이랑 인수가 이항연산 +, ×에서 Σ, Π에 대해 각 최소 인자들이라 추상대수학에서 중요하다는대 난 잘 와닫지 않는다. 항은 걍 아직까지는 용어처럼 보이기 때문이다.

참고로 숫자는 constant인데, 모델론적 언어의 constant symbol이기 때문

참고로 항에대한 설명에 앞서서, 마지막에 언급할 내용을 주의하라

항 : Products of Symbols
e.g. product of constant or variable
상수항 : constant만 있는 항
계수 : product of constant and variable에서 constanct부

단항식 : 전형적인 한국어 유형인 한자어로 이루어진 한국어이며, 말을 풀이하면 한자어(한자어는 기표인 한자와 그것의 발음이 있는데, 보통은 기의인 뜻을 □, 발음을 ○라 둘때, 기표인 한자를 "□ ○"라는 명칭으로 부른다. 어떤 알파벳 기표 ◇에 대해 그것을 칭하는 명칭 ♡ (e.g. ◇ = B, ♡ = Bee)로 부르듯, 한자어는 발음 ○로만 부르기에는 우리가 중국도 아니고 무리가 있으니, 대부분 "□ ○"식으로 명칭을 붙인다. 학습만화인 마법천자문을 읽어서 익히는것이 좋다) 單(홑 단) 項(항목 항)式(법 식), 영어로는 monomial이다. 이때, 홑 단 (單) 자는 전형적인 한국어 유형인 한자어로 이루어진 한국어 단어 "단일 (한자어로 單一)"에서의 "단"이다. 영어 말풀이로는 mono + nomial인데, mono는 라틴어 어근이다. 라틴어로 mono는 (번역하자면) "하나"라는 뜻으로 사실은 이과 용어에서는 거의 대부분 "단일"이라는 의미로 쓰인다. ("단일"이라는 말을 모른다면 초등학교에서라도 도서관에 있는 책을 거의 다 정독해보면 감이 올것이다.) (라틴어 어근을 쓰는 이유는, 로마 제국이 유럽을 정복한 이래 표준어였던 라틴어가 언어 어근 구성에 많이 있었고, 전통적으로 중새때부터 그랬으며, 사실상 나는 이과에서만 쓰는것같다고 느낄정도로 흔하니, 쓰다보면 신조어처럼 입에 착착 들러붙으니 문제는 없다.) 요약하자면 정신나간 뜻풀이 상, 항이 하나인 식. 다항식의 일종이다.
다항식 : 전형적인 한국어 유형인 한자어(한자어는 기표인 한자와 그것의 발음이 있는데, 보통은 기의인 뜻을 □, 발음을 ○라 둘때, 기표인 한자를 "□ ○"라는 명칭으로 부른다. 어떤 알파벳 기표 ◇에 대해 그것을 칭하는 명칭 ♡ (e.g. ◇ = B, ♡ = Bee)로 부르듯, 한자어는 발음 ○로만 부르기에는 우리가 중국도 아니고 무리가 있으니, 대부분 "□ ○"식으로 명칭을 붙인다. 학습만화인 마법천자문을 읽어서 익히는것이 좋다)로 이루어진 한국어이며, 말을 풀이하면 한자어로 多(많을 다)項(항목 항)式(법 식), 영어로는 polynomial이다. 많을 다 (多) 자는 전형적인 한국어 유형인 한자어로 이루어진 한국어 단어 "다중 (한자어로 多重)"에서의 "다"이다. 영어 말풀이로는 poly + nomial인데, poly는 라틴어 어근이다. 라틴어로 poly는 (번역하자면) "여럿", "다중"의 의미로 사실은 이과 용어에서는 "여럿", "다중" 그 자체임이 확정이다. ("다중"이라는 말을 모른다면 초등학교에서라도 도서관에 있는 책을 거의 다 정독해보면 감이 올것이다.) (라틴어 어근을 쓰는 이유는, 로마 제국이 유럽을 정복한 이래 표준어였던 라틴어가 언어 어근 구성에 많이 있었고, 전통적으로 중새때부터 그랬으며, 사실상 나는 이과에서만 쓰는것같다고 느낄정도로 흔하니, 쓰다보면 신조어처럼 입에 착착 들러붙으니 문제는 없다.) 요약하자면 정신나간 뜻풀이 상, 항이 여럿인 식, 사실상 항이 제로만 아니면 되기에, 단항식은 다항식의 일종이다.

차수 (degree)는 deg xⁿ = n이고, Θ(f) = Θ(g) ↔ deg f = deg g인 함수 f에 대한 deg f 값이다.

마지막으로, 보통 수학에서는 사칙연산(가감승제, +-×÷; Ed Sheeran의 곡의 사칙연산시리즈 엘범 커버 그림이 이렇다 ㅋㅋ)에 대해 암시적 곱셈을 쓰고 나눗셈 대신 의미가 동일한 분수를 사용한다. 그러니까 일반적인 표기를 끄는게 정상이라는거니 소개한다.

곱셈의 생략 : 암시적 곱셈 (implicit multiplication)혹은 병치 표기법(juxtaposition notation)이라고 불리우고 PM(PRINCIPIA MATHEMATICA)에서 약속된 약식(abbreviated notation)으로 통하는 ab = a × b인 구문론적 정의문인 표기법(Notation)은 그냥 너무 당연하게도 항상 그랬듯 쓰는 표기이니 약속된거라고도 볼수 있고, 곱셈이 암시된걸로도 볼수 있으며, 병치(한자어로 竝置, 뜻풀이로는 나란히 배치)하는 형식으로 작성된다. 이거는 표준이고 누구나 이렇게 쓰니까, 곱셈은 병치표기를 이용하여 암시적 곱셈으로 생략할수 있음은 너무나 당연한 약속된 약식인것이다. 웃기지 않는가? 너무 당연한걸 이리 길게 설명하다니.

나눗셈을 표기하는 기호 : 피연산항을 나눗심 기준 좌항과 우항으로 생각할때, 제수(除數, divisor)와 피제수(被除數, dividend)는 각각 우항과 좌항이고, 몫(quotient)과 나머지(remainder)는 말줄임표(ellipsis, ⋯)기준으로 좌항과 우항이다. 사실 말줄임표로 만든건 일반적인 나눗셈이 아닌 몫과 나머지로 인위적으로 나눈거고, 사실은 나눗셈의 값으로 장수비, 즉 정수의 분수인 유리수가 나오는게 맞다. 나눗셈은 가감승제(사칙연산)의 "제"에 해당한다. 기호로는 `÷`혹은 `/`를 쓴다. 개인적으로 `/`는 분수로써의 느낌을 잘 나타내고, `÷`은 비로써의 느낌과 `/`로써의 느낌을 잘 나타낸다고 느낀다. 단점으로는 그런식으로 해석하자면 `/`를 눕혀서 뺄셈기호(-)처럼 보인다는거. 분수(分(나눌 분)數(셀 수), fraction)에서 분자(分(나눌 분)子(아들 자; 엄마한태 업혀있음, 사실은 하위 개념의 의미임, 젠더운동 순화에 따라 윗수라고 함 (젠더운동은 싫지만 순화어 대박 좋네 ㄷㄷ)), , numerator)와 분모(分(나눌 분)母(어미 모; 아들을 업고있음, 사실은 근본 개넘의 의미임 (e.g. 모국어), 젠더운동 순화에 따라 아랫수라고 함 (젠더운동은 싫지만 순화어 대박 좋네)), denominator)에서 위와 아래가 각각 분자와 분모이고, 퍼(per)기호 `/`에서 보이듯, 대각선 모양의 퍼 기호에서, 중점에 대해 대각선과 평행한 동일한 두 힘을 주었을때, 수직 factor가 상•하를 향하는것이 수평 factor에 각각 대응되어, 일차함수의 그래프 모양의 저기호의 기울기 a에 대해 아크탄젠트한 각도 θ의 늘림•줄임에 따라 factor비가 바뀌는데, 그거가지고 0°인 `÷`와 0°<θ<90°인 `/`와 90°인 분수 기호로 나뉘는게 참 글자가 예쁘다고 생각한다. 단위 분수라고 하여 정수의 역수로 나타내는 분수가 있는데, 고대 이집트인들이 주로 썼으며, 그래서 나는 단위분수를 쓰기 귀찮으면 이집트인들이 하던 위에 짝대기긋는 표기를 하고싶은 욕망이 때때로 들어서, 위의 E혹은ㅌ자를 그리거나, 더 약칭으로 ㄷ을 그리는 고도의 귀차니즘을 가지고 있다. 비례식의 비는 피타고라스에 의해 고도의 힘을 입게되었지만, 사실상 의미상 그 비율 r = r:1인 나눗셈으로 보는게 현실. 참고로 수학자들은 대분수(mixed fraction)를 싫어하고 가분수(improper fraction)를 좋아하니 가분수를 죄다 대분수로 바꿔서 발작버튼을 눌러줄수 있다. 그러면 "일관성없는 표기법!"이라고 들며 하나같이 싫어하는 진광경을 볼 수 있다. proper은 적절한이라는 의미이고 improper는 가짜라는 뜻인데, fraction(분수)은 일부분, 즉 전체보다 작은 것을 의미한다. proper fraction은 "진정한 의미에서의 부분", 즉 전체(분모)보다 작은 일부(분자)를 표현하는 분수이고, improper fraction은 그에 반대되는 의미로서 그밖의 모든 분수, 즉 분자가 분모보다 같거나 커서 사전적 의미에서 벗어난 분수를 의미한다. 기약분수(Irreducible fraction)는 a:b = a/b에서, 더이상 (-1) 혹은 자연수로 나눠주는 방식으로 약분하여도 (1)로 나눠주는 방식이 되는게 다라 최종적으로 약분 불가능한 gcd(a, b) = 1꼴의 분수로, 이 꼴로 만드는걸 기약화라고 한다. 참고로 대분수는 정수부와 분수부의 합을 의미하는 Notation으로 하필 암시적 곱셈과 충돌한다. 그래서 나는 개인적으로 대분수가 있을때 뒷쪽에 곱셈을 쓰거나 괄호를 쓰는걸 선호하지만, 수학자들은 그냥 발작버튼이다. 굳이굳이 그런게 싫다면, 분수에 대해서 그냥 기본적으로 괄호를 탑제하고 가거나 싹다 "0과 n분의 m"꼴로 생각하고 표기하면 될텐데 라고 나는 생각하지만 말이다. 참고로 비는 초등학생한태 엄청 어려운 형식 언어처럼 느껴질수 있다.
```

#### Fucking Polynomial by 대수적 성격

```markdown
# 다항식은 좋다가도 싫다.

대수적 난이도만 다룬다.

## 일차식 ~ 사차식

즉, 근의공식이 존재하는것들만

1. 근의공식에 대해
2. 인수분헤에 대해
3. 다항식 수식에 대해
4. 다항방정식에 대해
5. 다항함수에 대해
6. 그 그래프에 대해
7. 기본적 응용에 대해

다룬다.

### 일차식

해당하는 노트가 아직 없다.

### 이차식

이차함수는 짝(Even)함수(Func) (즉, 우함수)로, 비선형 다항차수 다항식 중에서, 유일하게 평행이동만으로 xⁿ꼴에서 만들수 있다.

이차함수의 그래프를 대칭이동할때, 표준형 완전제곱식 항의 계수, 즉, 최고차항이었던 것(사실은 q = c - ap²라서, a를 빠꾸면 안됨)에 부호를 플립시 y축 대칭, p의 부호를 바꾸면, x축 대칭이다.

y = a(x - α)(x - β) = ax² + bx + c = a(x - p)² + q꼴로 생각해야 전체를 볼 수 있다.

#### 이차식의 특징

x에 대한 완전제곱식 y에 대해 y에 대한 합차공식 꼴로,

q = -D/4a에서, 완전제곱식이 중근을 가지고, 실근을 하나밖에 안가지는 기하적 위치에 있음을 알 수 있다.

q < 0에서, 실근이 두가지이고, q > 0에서 허근이 두가지다.

이에따라서,

(b/2)² = ac일 조건이 무슨 조건인지는 D/4와 D에 따라, 쉽게 알 수 있다.

(ax + b)(cx + d) = acx² + (ad + bc)x + bd = Ax² + Bx + C에서,

+ A = ac
+ B = ad + bc
+ C = bd

(사실 이차함수는 조립제법 안쓰고, 한 근을 주었을때 풀이가능할정도 난이도다, 저 구조에서, 어느 하나에 대해 시도시 잘 구해지므로, 저걸로 풀이가 쉬운 이유.)

이므로, 일차식의 곱 꼴인

y = Πₖ (x Aₖ + Bₖ)중에서 유일하게 써먹을 만한 난이도다.

(ax + b)(cx + d) = ac(x + b/a)(x + d/c)에서, ac = t로 두면 이해가 쉽다.

이런 구조로써, 근의공식도 유도된다.

#### 이차함수의 최대 • 최소

+ y = f(x) = a(x - p)² + q
+ P = (n, m)
+ Q = (inf f(x), sup f(x)) (x ∈ P)
일 때, x ∈ P → y ∈ Q임.

n = p - b, m = p + d 일때,

명제 Φ : inf Q = q 에 대해,
+ Φ일때, t = sup Q
+ 아닐때, t = inf Q로,
q를 극값 경계, t를 비극값 경계로 명명하겠음.

그러나, p < n < m이거나, n < m < p인 경우, 극값 경계니 뭐니는 의미 없다.

y = ax² + bx + c = a(x - p)² + q 에서,

b = -2ap이므로, 취른하우스 변환에서 나왔던 공식,
p = -b/2a를 얻을수 있고,

x에 단순히 p를 대입해, q를 구할 수 있다.

만약 극값 경계니 뭐니 논하는 문제가 아니면, q를 구할필요가 없고, a를 이용하여 증가 감소를 생각해야하므로, 다음 결론을 얻는다.

case₁ : n < m < p
case₂ : n < p < m
case₃ : p < n < m

case₂의 경우
1. a > 0일때
 - 극값 경계가 하한
 - 비극값 경계가 상한이고, f(p ± k) 가능한한 큰 k
2. a < 0일때
 - 극값 경계가 상한
 - 비극값 경계가 하한이고, f(p ± k) 가능한한 큰 k

case₂가 아니면, 
1. case₁시
 - a > 0시 감소로, f(m) < f(n)
 - a < 0시 증가로, f(n) < f(m)
2. case₃시
 - a > 0시 증가로, f(n) < f(m)
 - a < 0시 감소로, f(m) < f(n)

(n다음 m을 쓴건, 자주 쓰이는 순서로 간 게 아니라, 내가 알파벳 순서대로 해야하는걸, 습관적으로 n, m순서로 썼다는거)

### 삼차식

이것도 해당하는 노트 없다.

다만, (u + v)³ = u³ + v³ + 3uv(u + v)를 르네상스 시기에 아름답다고 수학자들이 생각했으며,
타르탈리아가 이를 통해, x³ + px = -q의 해를, x³과 x에, x := u + v하므로 구하고,
카르다노가 쌔벼서 연구한 후, 재대로 된 훌륭하고 칭송받을만한, 삼차방정식 근의 공식으로 만들었다는데에서,

당시 수치나 수학의 대칭성에 주목하던 시선이 과연 무었인지,
추론해보면, 이부분에 대해 작성할 가능성이 있다.

### 사차식

여기서는, 나는, X² + aX + b [X := x²]꼴의 사차식 수식에 주목된다.

이차함수 f, g에 대하여, f(g(x))꼴의 수식으로,

다항함수 f, g에 대해여, f(g(x))꼴이 f및 g보다 차수가 높은 동시에, 일반해를 구하는 대수적 공식을 가지려면, f및 g가 선형함수보다 차수가 높은데에다가, f(g(x))가 사차함수 이하여야 하므로, 이차함수 f, g에 대하여, f(g(x))꼴의 수식이 대표적이다.

1. 카르다노의 제자 페라리가, 사차식을 완전제곱식으로 강제로 분해하는 과정에서, 삼차방정식 근의 공식을 썼고
2. 타리탈리아는 삼차방정식 x³ + px = -q의 해법을 구할때, -p = 3uv와, -q = u³ + v³에서 이차방정식의 근의 공식을 썼으며
3. 이차방정식의 근의 공식을, 완전제곱식으로 만드는 방법(팁 : 취른하우스 변환은, 이차식을 완전제곱식의 합차공식꼴로 만든다)으로 유도할 때, 일차방정식의 해법을 이용하므로,

흥미로움을 떨칠수가 없다.

그래서 삼차식 탐구 이후에 알아보려 한다.

단지 헬조선에서 대학은 가야 곱게보는 미친 나라이니까, 공부해야해서 미룰거임.

## 식을 만드는 꼴

### xⁿ에 직접적으로 연관된것

완전제곱식(다항정리), 합차공식꼴(xⁿ ± yⁿ꼴)을 말한다.

이항정리꼴, 이항 아니고 삼항공식꼴, 다항공식꼴, 합차공식꼴, 완전제곱식, 완전세제곱식, 완전 내제곱식, 합차공식, x³ ± y³, x⁴ - y⁴로 분류한다.

#### 완전제곱식

(x ± y)² = x² ± 2xy + y² 꼴이다.

아 짜증나 지금 쓰기 싫어

#### 완전 세제곱식

(x ± y)³ = x³ ± 3x²y + 3xy² ± y³

(u ± v)³ = u³ ± v³ ± 3uv(u ± v)

이꼴을 굳이 지금 할 필요가 없다. 나는 이걸 이미 미뤘다고 말한 바 있다.
```

### 해석학 • 미적분학 ; 극한

#### 극한에 대해 탐구를 빙자한 주절주절

```markdown
극한을 정의할때 나온 0 < |x - a| < δ → |f(x) - L| < ε 라는 말에서, x → a에서의 함수 f의 극한값은 정확히 L인거야? (즉, |f(x) - L| < ε항에서, |f(x) - L| = 0식으로 계산되서 극한값이 정의되는지.) 아니라면, 왜 0 < |f(x) - L| < ε가 아니지?

아, 그 이유가 기본적으로 |f(x) - L| < ε꼴의 오차범위 캡쳐여서 (즉, 거리가 0인 꼴이 나올것을 전제하지 않아서) 그렇구나?! 그러면 0 < |x - a|인, 즉; x ≠ a인, 즉, 정의역에 들어가지 않아도 되고, 함수값 f(a)도 아닌 (함수값 f(a)랑 같아버리면, x ≠ a에서 f(x) = f(a)이게 되는것이라 연속이라는 특수한 이름으로 부름) 값으로 정의되는 신묘한 경우이기 때문이구나!

그러면 genfₙ(a)(x) = ((x - a)^(1/2 + n/2))/((x - a)^(1/2 + n/2))를 정의하고, 연속함수 f에 대해, g(f, a, b) = (Πₙ genf₀(aₙ))(Πₙ genf₁(bₙ)) × f로 정의하면, g(f, a, b)는 원래 연속이었던 함수애 불연속점이나 불연속 구간을 단순히 추가해준 함수에 불과하므로, g(f, a, b)(x)가 x = t에서 정의되어 있을때, g(f, a, b)(t) = lim g(f, a, b)(x) [x → t]이며, g(f, a, b)로 구성 불가능한 함수는 도약 불연속 등으로 인해서 극한을 이용해서 파악할수는 없겠군.
좌극한•우극한•상극한•하극한 개념을 생각해보면, 극한을 보낸다는건 기본적으로 여러가지 값이 극한이 되는거고, 예외적으로, 극한값이 유일할때, 수렴한다고 하고, 이를 다시 극한값으로 부르는구먼...
왜냐하면 무한히 근접한다고 하면 실수 x에 대해서, 방향성이 문제가 되니까 극한값의 상한이 상극한, 하한이 하극한이 되겠군. 한마디로 g(f, a, b)(x)가 x = t 정의되어 있지 않을때 x→t가 극한이 구하고자 하는 바가 되겠군.

한마디로, 연속함수 f에 대해서, 임의의 수열 a, b가 존재하여, g(f, a, b)인 꼴의 모든 함수에 대해서, 극한은 g(f, a, b)를 f처럼 다룬다. 어떻게? 정의되어 있지 않은 상한•하한에 대한 접근으로, 어떻게? x를 좌측에서 보내줬거나 우측에서 보내줬거나.

그리고 그러한 방식으로 작동이 되고, 개념이 함수값의 개념과는 다르기에, 0 < |x - a| < δ → |f(x) - L| < ε인, 즉, 저 논리식을 풀어 쓰면, a - δ < x < a + δ → L - ε < f(x) < L + ε (단. x ≠ a)가 되는거겠군.

x ≠ a에서, x → a일때, f(x) → L일때 그 L을 극한값이라고 한다고 할때, 극한값 존재한다는건, 즉, 수렴한다는것은, 해당 극한들의 집합의 상한과 하한이 동일하여, 유일한 경우 뿐이군.

따라서, 연속함수 f에 대해서, 임의의 수열 a, b가 존재하여, g(f, a, b)인 꼴의 모든 함수에 대해서, 극한은 g(f, a, b)를 f처럼 다루어서, 극단적인 경우인, 도약 불연속 이외의 경우를 기하학적이고 해석적인 특성을 이용하여 분석할수 있게 해주는 논리적 귀결 모델이네

어?

g(f, a, b)는 정의역을 제한한 연속함수꼴이니까, 집합 S에 대해 S²범위에서 graph f가 연속이라고 하더라도, 연속이 아닌 범위에서 불연속이 될 수 있고, 국소적인 연속적 특성 및 해석적 특성을 다루게 하는 연속일때 값을 극한직업마냥 한없이 보내서 expect하는 도구가 극한이군.

그렇다는건 f = (X, Y, graph f)인 f에 대해, graph f가 끊어지지 않을때, 함수값과 극한값이 같댜는개 핵심인거네?

와...

"두 직선사이의 임의의 점을 찍을수 있음"이 극한의 대수적•기하적 의미를 함의하며, 동시에 극한이란 개념의 핵심도 되는구나

그러면 초실수체에서 무한소 `ε`는 대체 왜 Łòs's Theorem을 통해서 실수에서 그 의미를 전달받는거지? 지금까지 우리가 논의한 극한과 완비성이 사라지고 그 자리에, 극한과 완비성을 의미하는 수가 추가된건가?

뭐 ε-δ? 한마디로 ε-δ의 ε을 의미한다라? 하....
```

#### 합성함수의 극한

```markdown
# 합성함수의 미분 하나 다루겠다고 복잡하게 식쓴거

001 | 

002 | Definition) 함수 y = f(x)가 그리는 도형 위의 정점 P₀(x₀, f(x₀))부터 정점 P₁(x₁, f(x₁))까지 동점 P가 움직였을때, 

003 | P₀ + <Δx, Δy> = P₁을 만족하는 Δx, Δy를 각각 x와 y의 증분이라고 정의한다.

004 | 

005 | Definition) 함수 y = f(x)에서 차분 Δf(x) ≜ Δf(x₀) ≜ Δy [x₀ := x] 로 정의한다.

006 | 

007 | P₀, P₁, <Δx, Δy> 이중 두가지만 결정되더라도 Vector의 덧•뺄셈은 SIMD마냥 x-y축이라는 요소 종류중에서 같은 종류의 요소에만 연산되기에, 완벽히 해당 스칼라에서의 덧•뺄셈을 흉내내기에, 나머지 하나가 결정된다 (대수구조 중 Loop)

008 | 

009 | 함수 y = f(x)에 대해, 그 정의역 위에 x₁, x₂가 존재하여, y₁ = f(x₁), y₂ = f(x₂)를 만족한다면, 함수라는것은 반드시 x₁ = x₂ → y₁ = y₂를 만족한다.

010 | 

011 | 즉, 정의역 위의 x₁에 대해 card {y | y = f(x)} = 1이다. 함수값은 매개변수의 값에 의해 하나로 결정된다.

012 | 

013 | 따라서, x₀, x₁에 대해 각각 y₀, y₁는 하나씩 결정된다.

014 | 

015 | 즉, x₀, x₁, Δx중 어느 두가지만 결정되어도, P₀, P₁, <Δx, Δy>가 다 결정된다.

016 | 

017 | 그러므로, 

018 | 

019 | P₀ + <Δx, Δy> = P₁

020 | = <x₀, y₀> + <Δx, Δy> = <x₁, y₁>

021 | 

022 | 애서, 

023 | 

024 | <Δx, Δy> = P₁ - P₀

025 | = <x₁, y₁> - <x₀, y₀> = <x₁ - x₀, y₁ - y₀>

026 |  = <x₁ - x₀, f(x₁) - f(x₀)>

027 | 

028 | 이다.

029 | 

030 | 따라서, 평균변화율 Δy/Δx = (f(x₁) - f(x₀))/(x₁ - x₀)이 x₀, x₁, Δx중 어느 두가지가 결정되면 결정된다.

031 | 

032 | 사실, x₀ + Δx = x₁, Δx = x₁ - x₀을 만족하므로, x₀이 정해졌을때나 x₁이 정해졌을때, 각각 x₁과 x₀은 Δx와 일정한 차나 일정한 합을 가지는 관계이고,

033 | 

034 | 특히, x = x₀인 차분에서, x₀ + Δx = x₁로 x₁이 결정된다.

035 | 

036 | 사실은, 이 정의는 일부러 "P₀, P₁ ∈ graph f ∧ P₀ + <Δx, Δy> = P₁"라는 기하적으로 증분을 정의한것이므로, 일부러 x₁ 혹은 Δx를 건드려줄것을 기대하고 만든 증분의 정의로, x₁, y₁및 x₀, y₀의 함수관계와, Δx증분관계 하에 놓인 함수 graph상의 변수들의 관계 선언한것이지, 어떤 정상적인 함수나 변수를 선언한것이 아니다. 따라서, 앞으로 나올 x₁, y₁, x₀, y₀, Δx, Δy는 아주 기깔나게 자유변항마냥 조작되는 모습을 볼 수 있을것이다.

037 | 

038 | 앞으로 증분 Δx, Δy를 건드린다면, x-y 평면상의 graph f위의 동점의 이동에 따른 벡터 증가량으로 표시될것이다.

039 | 

040 | Definition 교육과정상 미분과 계수) $y = f(x)에 대해, (d/dx f(x)) ≜ dy/dx ≜ lim_{Δx → 0} Δy/Δx$ (Tip : 입출력 축은 달라질 수 있음)

041 | 

042 | 여기서 정의한 차분에 따라서,

043 | $lim_{Δx → 0} Δy/Δx = lim_{Δx → 0} (f(x + Δx) - f(x))/Δx$

044 | 

045 | 또한, 여기서 정의한 증분에 따라,

046 | $lim_{Δx → 0} Δy/Δx = lim_{t → x} (f(t) - f(x))/(t - x)$

047 | 

048 | 이런식으로 동작하게 해놨다.

049 | 이것 역시 x축과 y축이 아닌 다른 축의 원소다 미지수가 되면 기호를 dx, dy에서 다른걸로 바꾼다.

050 | 

051 | Theorem 합성함수의 미분법) (f◦g)' = g' × (f'◦g)

052 | Proof) 합성함수의 미분법을 증명해보자.

053 | 

054 | 미분할것을 목표로 하는 함수는 y = (f◦g)(x)이다.

055 | 

056 | 그래프 위에서 도형을 그리는 다음 연립방정식 y = f(u), u = g(x)을 살펴보자. 미지수 u가 생김에 따라서, 가상의 u축이 더해진 상태이다.

057 | 

058 | 이제 함수는 음함수꼴에서, 그래프 graph f를 술어로 간주하여, (graph f)(x, u, y)를 (graph f)(u, y) : (∀x (graph f)(x, u, y)) 로 표기하여 간주하고,

059 | 

060 | graph g를 술어로 간주하여, (graph g)(x, u, y)를 (graph g)(x, u) : (∀y (graph g)(x, u, y)) 로 표기하여 간주한다.

061 | 

062 | 그 이유는 (graph f)(u, y)및 (graph g)(x, u)및 (graph (f◦g))(x, y)에서, 미지수를 저 꼬라지로 만들었기에, output = function(input)꼴을 만들고, 각 축에대해 값을 표기하는, 즉, 음함수 graph f의 해(근), 즉, 음함수꼴을 만족시키는 값이

063 | {(input, output) | output = function(input)}꼴인데, 세가지 함수를 연립하면, 각각의 미지수에 대한 관계로 graph로 만든 술어관계가 변하므로,

064 | 음함수꼴을 만족하는 점이 사용되지 않는 변수의 축도 존재하여야 한다.

065 | 

066 | y₀ = f(u₀), u₀ = g(x₀)이라면, 

067 | 

068 | (x₀, u₀, y₀) ⊨ (y = f(u), u = g(x))여야 한다.

069 | 

070 | 사실, 음함수가 관계 역할을 함으로, 그 음함수 "(y = f(u), u = g(x))"에 대해, (y = f(u), u = g(x))(x₀, u₀, y₀)을 만족한다는건, (y = f(u), u = g(x)) ⊆ 𝕏 × 𝕌 × 𝕐 (단. (x, u, y) ∈ 𝕏 × 𝕌 × 𝕐)이기에,

071 | 

072 | (x₀, u₀, y₀)가 (x = x₀, u = u₀, y = y₀)로 동작함은 누구나 알것이다.

073 | 

074 | 사실 저 구조체같은게 튜플이던 아니던, 걍 내부 문장들을 전부 연언해주면, 논리적 귀결같이 작동하는건 똫같으므로, 굳이 태글걸 곳도 없다.

075 | 

076 | y = f(u), u = g(x) 이면이 y = f(g(x)) 이므로, 두 식 y = f(u), u = g(x) 을 연립한 좌표평면 위의 도형 y = f(g(x))은 y = f(g(x))가 그리는 그래프와 같다.

077 | 

078 | 이하에서, y = f(g(x))는 두 식 y = f(u), u = g(x) 을 연립한 좌표평면 위의 도형과 동일하게 보겠다.

079 | 

080 | 함수 y = f(g(x))의 미분은, $dy/dx = lim_{Δx → 0} Δy/Δx$ 이다

081 | 

082 | 그런데

083 | 

084 | 함수 u = g(x)에 대해, 그 미분이 $du/dx = lim_{Δx → 0} Δu/Δx$ 이고

085 | 함수 y = f(u)에 대해, 그 미분이 $dy/du = lin_{Δu → 0} Δy/Δu$ 이다. ⋯ ①

086 | 

087 | 평균변화율에서, Δx, Δy, Δu가 다 연동이 되게 선언하였으니,

088 | 

089 | Δy/Δu × Δu/Δx = Δy/Δx 이므로,

090 | 

091 | x-u 평면상의 함수 u = g(x)에서

092 | 

093 | Δx → 0일때 분모 → 0이므로 분자 → 0이여야 한다.

094 | 

095 | 즉, Δx → 0에서, Δu → 0이다.

096 | 

097 | 따라서, 함수 y = f(g(x))에서

098 | 

099 | 미분계수 $dy/dx = lim_{Δx → 0} Δy/Δx = lim_{Δx → 0} (Δy/Δu) (Δu/Δx)$ 는

100 | 1. Δx → 0일때, Δu → 0이고

101 | 2. $lim_{Δx → 0} Δu/Δx = du/dx$이며

102 | 3. $lim_{Δu → 0} Δy/Δu = dy/du$이기에,

103 | 

104 | 극한의 성질 $lim_{x → a} [f(x) g(x)] = [lim_{x → a} f(x)] [lim_{x → a} g(x)]$에 따라서,

105 | 

106 | $dy/dx = lim_{Δx → 0} (Δy/Δu) (Δu/Δx) = [lim_{Δx → 0} (Δy/Δu)] × [d/dx g]$ 이다.

107 | 

108 | 이제 남은 식을 풀이해야함은 당연히 그것이 목적이니 당연하다.

109 | 그러기 위해서 $lim_{Δx → 0} Δy/Δu$에서의 식의 꼴을 알아내기 위해 Δu의 값을 구해야 한다.

110 | 사실은 누구나 직관적으로 알았겠지만 0/0꼴이다.

111 | 왜냐하면 기존의 정보 Δx → 0에서 Δu → 0, 즉, $lim_{Δx → 0} Δu = 0$을 만족하므로, 0/0 꼴이 되는것은,

112 | 

113 | 1. $lim_{Δx → 0} Δy = 0$

114 | 2. $lim_{Δx → 0} Δu = 0$

115 | 에서, 이미 그 두 충분조건이 마련된 논리적 귀결이기 때문이다. (참고 : 0/0꼴은 $lim_{x → a} [분자/분모]$ 식에서, x → a일때, 분자 → 0이고, x → a일때 분모 → 0인 꼴이다.)

116 | 

117 | 다시 돌아와서 Δx → 0에서 Δu → 0이므로,

118 | 

119 | $dy/dx = [lim_{Δx → 0} (Δy/Δu)] × [d/dx g] = [lim_{Δu → 0} (Δy/Δu)] × [d/dx g]$ 이다.

120 | 

121 | 이제 남은 식을 풀이해야함은 당연히 그것이 목적이니 당연하다.

122 | 그러기 위해서 $lim_{Δu → 0} (Δy/Δu)$의 값을 구해야 한다.

123 | 당연히도, 우리가 아는 바에 의하면 직관적으로 ①을 구한것을 떠올릴 가능성이 높다. 저 식은 미분계수를 평균변화율로 나타낸 식이기에, 미분계수를 연상할 수 있기때문이다.

124 | 

125 | 다시 돌아와서

126 | 

127 | $dy/dx = [lim_{Δu → 0} (Δy/Δu)] × [d/dx g]$ 에서,

128 | 

129 | ①에 따라, $dy/du = lim_{Δu → 0} Δy/Δu$ 이므로,

130 | 

131 | $dy/dx = [lim_{Δu → 0} (Δy/Δu)] × [d/dx g] = [d/du f] × [d/dx g]$ 이다.

132 | 

133 | 도함수의 정의인 미분계수와 도함수가 같다는 점에 따라서,

134 | 

135 | 1. ý = f'(u) = dy/du이고

136 | 2. u = g(x)이므로,

137 | 3. ý = f'(g(x)) = dy/dy 이다.

138 | 

139 | 따라서, 

140 | 

141 | dy/dx = [d/du f] × [d/dx g] = ([d/dx f]◦g) × [d/dx g] 다.

142 | 즉, (d/dx) [f◦g] = [d/dx g] × ([d/dx f]◦g) 이다.

143 | 

144 | Q.E.D.

145 | 

146 | 이제, 뽀너스로 발견한것들을 적겠다

147 | 

148 | Δ(f × g) = fΔg + gΔf + ΔfΔg에서,

149 |

150 | d/dx (f × g)

151 | 

152 | = $lim_{Δx → 0} Δ(f × g)/Δx$

153 | 

154 | = $lim_{Δx → 0} {fΔg/Δx + gΔf/Δx + (ΔfΔg/(Δx)²)Δx}$

155 | = $lim_{Δx → 0} {f × g' + g × f' + (g' × f')Δx}$

156 | 

157 | 이렇게 Δy의 증분부분을 차분으로 바꾼후 분배해서 나눠서 미분으로 만들어도, Δx가 하나 남는다,

158 | 그런데 보통 우리다 미분이나 차분에서 h 혹은 Δx라는 기호를 어떻게 취급하는지 아는가?

159 | 

160 | 그러한 부분은 무한소로써 나눠지는 부분이다. (미분계수의 식이 바로 도함수이니, 그것에 대해서 무한소를 곱해주면 당연히 극한값이 0으로 가는 값과 곱해서 0으로 나오기에 0이다. 사실은 차분에서 나왔던 쓸대없는 계산부가 날아간거로 설명되지만...)

161 | 

162 | = $lim_{h → 0} {f × g' + g × f' + (g' × f')h}$

162 | 

163 | = f × g' + g × f'

164 |

165 | 참고로 교과서에서는 $lim_{h → 0) f(x + h) = f(x)$임을 이용한다.

166 |

167 | 표준부분원리인지 뭔지로 실수체계랑 같이 사용가능한 초실수체 `ℝ*`에서,

168 | 

169 | A. st(f*(x + ε)) = f(x)이고, 

170 | B. x = st(x) + ε (표준부분원리) 이기에,

171 | 

172 | 직관적으로, $lim_{h → 0) f(x + h) = f(x)$임이 당연하다는걸 알 수 있다.

173 | ad-equality `≈`에서,

174 | x + ε ≈ x 이며,

175 | st(x) + ε = x이고,

176 | $lim_{t → x} f(t) = f(x)$

177 | 이기에... 아 근데 아무도 의심하지 않는데 왜 내가 쓸때없는 소리를 하는지 모르겠다.

178 | 

179 | 

180 | ...

181 |

182 | 

183 | Calculate 연산자 Ca = (d/dx)라고 해보자.

184 | 

185 | 그러면, C¹ f, C¹ g및 a, b ∈ ℝ에서,

186 | Ca(af + bg) = a Ca(f) + b Ca(g) 이다, 

187 | 

188 | 즉, 미분 연산자 Ca는 선형이다.

189 | 

190 | 왜냐하면, 평균기울기 연산자 Δ/Δx = k Δ [k := 1/Δx]로, 차분연산자 Δ에 단순히 상수배를 해준걸로 취급... 뭐 ㅋㅋㅋ 변수배라고 하겠다 ㅋㅋㅋ 아니 농담이고,

191 | Δx를 보통 고정시켜서 실체있이 취급하기에 그렇게 말한거다.

192 |

193 | Δx에 대해, 차분연산자를 그 역수배해주면, 평균기울기 연산자다.

194 |

195 | 그런데, 차분은 선형이므로, 평균기울기 역시 선형이고, 

196 | 따라서 $lim_{Δx → 0}$으로 Δxᵤ = ε로 만들어버린 경우 역시나, 

197 | C¹ f, C¹ g에 대해, Ca (여기서는 d/dx라는 의미로써) 는 $lim_{Δx → 0} Δ/Δx$로,

198 | 

199 | 단지 모든 실수 Δx에 대해 전칭 양화하여 선형이었으므로, 당연히 극한으로 보냈어도 선형이다.

200 |

201 | 오미크론 ο에 대해서 서술한 다음에,

202 | 

203 | 중괄호 `{`, `}`안에 쓰인 오미크론 ο에 대해, ο → 0으로 보내주는걸 epsilon-delta-omicron-notation(edon)이라고 명명하겠다.

204 |

205 | edon은 Notation이다. 구문론적으로 정의되었고, 중괄호를 함수마냥 취급해서 그 안에있는 ο에 극한을 취해주는,

206 | 흡사 형식문법같이 작동하는 표기법 말이다.

207 | 

208 | 또한 ο = ε로 선언하는 경우을 epsilon-based-omicron-notation(ebon)이라고 하겠다.

209 | 

210 | ebon은 구문론적으로 ο를 ε로 선언하였으므로 ε에 할당된게, 비 유한 초실수 상수 중 무한소일수 있으며, 혹은 이원수 체계의 멱영원 ε = [[0, 1], [0, 0]]인 이차 정사각 행렬일수도 있다.

211 | 

212 | 뭐 메크로처럼 만들어논걸 쓰는건 표기법으로 적는사람 책임이지만 뭐... 못알아둬서 나쁠일은 솔찍히 별로다.

213 |

214 | 이러한 오미크론 표기법 (omicron-notation) 에 대해서,

215 | 

216 | 미분계수는 `dy/dx = Δy/Δx [Δx := ο]` 인걸로 볼수 있으므로,

217 | 

218 | 차분을 통하든 증분을 통하든, 거기서 거기. 같은 의미인지라, 완전히 다르게 정의해서 우선순위가 달라진 상태로써,

219 | `d/dx = Δ/Δx [Δx := ο]`으로써의 미분과, `dy/dx = Δy/Δx [Δx := ο]`으로써의 미분 계수에 대해서,

220 | 

221 | omicron-notation에 대한 미분연산자 (omicron만큼의 평균기울기 연산자인, 순간기울기) • 미분계수 (omicron만큼의 Δx증분을 통한 평균변화율인 미분걔수) 의 정의라고 하겠고,

222 | 이는 각각 "(× 1/ο)된 차분연산"과 "ο급 크기의 증분의 비"라는 대척점에 있는 관점이 되기에,

223 |

224 | 전자를 뉴턴식, 후자를 라이프니츠식이라고 부르겠다. 실제로 뉴턴이나 라이프니츠다 이렇게 생각했단건 아니고,

225 | 걍 이름을 붙이고싶은대 뭐가좋을까 싶다가, 라이벌인 두명을 떠올려서 히히...

226 | 

227 | "평균기울기의 극한과 미소의 비는 일반적인 미분 그 자체에 대한 관점과, 본질적인 관점이여서 다르다"고 말해도 되는지 모르겠다.

228 | 

229 | 암튼 뉴턴식은 추상적인 연산자 그 자체로써의 속성으로 몰빵하기 위해서 평균기울기에 극한을 달아주고, 라이프니츠식은 미소의 비라는 미분형식같은 관점이다....만.

230 | 

231 | 이렇게쓰는거 왠지 죄책감드니까 걍 뉴턴식 • 라이프니츠식 말고 "연산자식" • "미소비식"이라고 하겠다.

232 | 모르는상태에서 "새상 ×까라"는 식으로 탐구하니까, 속새의 이름을 더럽히지 말겠음.

233 |

234 | ! (본인의 지능이 열화되서 횡설수설한다는걸 깨닫은 나)

235 |

236 | 어이고, 힘들어서 뇌정지된것 같으니 내일이나 반나절정도 지나서 이야기하자
````

## 유용

```markdown
# 성분 선택기 혹은 켤래 구성기

실수성분 re(z)와 허수성분 im(z)를 다음과 같이 놓겠음.

(re, im) ≜ ri
[ri := (re, im)
  [re := λz. (z + z̄)/2]
  [im := λz. (z - z̄)/2]
]

z̄는 복소수 z의 켤래복소수임.

혹은 다음 정의

z̄ ≜ re(z) - im(z)

로 하여도 좋음.

*텔레그라피체 re와 im이 내 중학교 시절 추억이 녹은 기호인데 못적어놓는게 ㄹㅇ 인생 최대의 한이다 이거 레알 진짜 실화냐 ㅠㅠ*

두번째 정의에 첫번째 정의를 대입해보면 항진이고, 반대로 첫번째 정의에 두번째 정의를 대입해봐도 항진으로...

둘 다 동등. (동치라는 일본식표현을 자제하라고 정주희 저 수리논리와 집합론 입문에서 저술해 놓아서 이렇게 적음. 절대 정치적 성향땜에 그렇게 적는건 아니고, 어릴때부터 일본식 문화 자제하는걸 교육받아서 그럼)
```