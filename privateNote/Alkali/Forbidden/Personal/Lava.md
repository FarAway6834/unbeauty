# Lava System

(내가 추상대수학 배우려고 만든 체계)

닫힌형태의 대수구조를 폐구조라고 명명하고, Lava라고 부르겠음.

관계가 주어지지 않은 n개의 함수와 m개의 심볼을 가진 Structure

M = <D, Sym₁, ..., Symₘ, fun₁, ..., funₙ>를 (m, n)-Lava라고 하겠음

(m, 0)-Lava는 (심볼을 정의한, 즉 정의용) 집합인 기본적인 대수구조이다.

참고로, (m, 1)-Lava이상은, 각 연산이 전부 D와 마그마를 이룬다.

Volcanoₘ,ₙ(D, Sym₁, ..., Symₘ, fun₁, ..., funₙ) ≜ <D, Sym₁, ..., Symₘ, fun₁, ..., funₙ>

라 하겠다.

Volcano는 (m, n)-Lava를 생성하는 무한 차원의 (= 행과 열의 총 길이가 자연수 기수 길이인) 함수행렬이다.

예컨데, Volcano₂,₀(𝔹, F, T)는 부울-도메인으로 유명하다.

내가 스스로 정의한
Lava에서 확장한걸로 구조꼴 (structure form)이라는게 있는데, 아래와 같다.

StructureFormₗ,ₘ,ₙ(D, Sym₁, ..., Symₗ, fun₁, ..., funₘ, Pre₁, ..., Preₙ) ≜ <D, Sym₁, ..., Symₗ, fun₁, ..., funₘ, Pre₁, ..., Preₙ>

Pre₁, ..., Preₙ는 술어이고, 이게 뭐하나 미스되지 않고, Lava랑은 달리 있을거 다있게 정의된 구조의 최소 단위이므로, 이를 "구조꼴"이라고 하고, 삼차원 행렬 (= 이제 텐서 ㅋㅋㅋㅋ) StructureForm를 통해 만들 수 있다.

(근데 나 멀미나와서 오늘은 여기까지 작성하겠고, 추상대수학은 여기까지 배우겠음.)

## 대수 구조 공부

### 성질 목록

아래 술어들은, Lava M에 대해, 

M ⊨ Φ : "M이 성질 Φ를 만족한다"

라고 하는 술어 Φ들이고, 성질이라고 부른다.

사실 술어랍시고 써놨는데

1. 죄다 자유변항만있고, 종속변항은 없는것은 "참성질"이라고 부르고, 걍 사실상 문장명명이다.
2. 자유변항이 존재하고, 종속변항도 존재하는것을, "가성질"이라거 부르고 걍 사실상 술어다.

참성질과 가성질의 `참-`, `가-`는 참다랑어와 가다랑어에서 따왔다.

참성질을 법칙성질, 가성질을 성질부분이라고도 한다. (이것도 근데 방금 만든 조어다)

~배고프니까 천장에서 다랑어가 쏳아졌으면 좋겠다~

#### 결합법칙 (associative property)

결합법칙 Associative는 다음과 같은 법칙성질(참성질)이다.

Associative : "(a * b) * c = a * (b * c)"

#### 중가환 법칙 (medial property)

중가환 법칙 Medial은 다음과 같은 법칙성질(참성질)이다.

Medial : "(m * n) * (p * q) = (m * p) * (n * q)"

#### 교환법칙 (commutative property), 혹은 가환(commutative)

교환법칙 Commutative는 다음과 같은 법칙성질(참성질)이다.

Commutative : "a * b = b * a"

#### 좌역원임-가술어 (tunal is-leftinvers-of Predicate)

좌역원임-가술어 tunalIsLeftinversOf는 내가 방금전에 명명한 가성질이다.

가술어를 tunal 서술어를 붙이는 이유는 tunna-al (다랑어-적)이라는 뜻으로 가술어임을 말하기 위해서다. 이유는 가성질 • 참성칠 명명 유래 참고.

tunalIsLeftinversOf(e, b, a) : "b * a = e"

e = eₗ으로 대입해서 생각한다면, 좌항등원이 항등원인 좌역원임-가술어라고 하며, e = eᵣ이면 우항등원이 항등원인 좌항등원-가술어라고 한다. (심볼정의 문단의 항등원 참고)

해당사항은 하단의 우역원임-가술어에서도 통용된다.

#### 우역원임-가술어 (tunal is-rightinvers-of Predicate)

우역원임-가술어 tunalIsRightinversOf는 내가 방금전에 명명한 가성질이다.

tunalIsRightinversOf(e, b, a) : "a * b = e"

#### 좌역원임-술어 (is-leftinverse-of Predicate)

좌역원임-술어 isLeftinverseOf는 내가 방금전에 명명한 가성질이다.

b isLeftinverseOf a : isLeftinverseOf(a, b) : 항등원이존재함(eₗ, eᵣ), tunalIsLeftinverseOf(e, a, b)

로, 좌항등원과 우항등원이 같은 경우의 좌역원임-가술어이다.

#### 우역원임-술어 (is-rightinverse-of Predicate)

우역원임-술어 isRightinverseOf는 내가 방금전에 명명한 기성질이다.

b isRightinverseOf a : isRightinverseOf(a, b) : 항등원이존재함(eₗ, eᵣ), tunalIsRightinverseOf(e, a, b)

로, 좌항등원과 우항등원이 같은 경우의 우역원임-가술어이다.

#### 역원임-가술어 (tunal is-inverse-of Predicate)

역원임-가술어 tunalIsInverseOf는 내가 방금전에 명명한 가성질이다.

tunalIsInverseOf(e, a, b) : tunalIsLeftinversOf(e, a, b), tunalIsRightinversOf(e, a, b)

로, 좌역원임-가술어와 우역원임-가술어를 모두 만족시키는, 즉, 역원인 경우로써,

이경우도 e에 따라, 항등원이 좌/우 항등원인 역원임-가술어로 말할 수 있다.

### 역원임-술어(is-inverse-of Predicate)

역원임-술어 isInverseOf는 내가 방금전에 명명한 가성질이다.

b isInverseOf a : isInverseOf(a, b) : 항등원이존재함(eₗ, eᵣ), tunalIsInverseOf(e, a, b)

로, 좌항등원과 우항등원이 같은 경우의 역원임-가술어이다.

#### 가역원임-가술어 (tunal cheking-dose-it invertible-element Predicate)

가역원임 가술어 isInvertibleAs는 방금전에 내가 만든 가성질로,

역원 판별논리식 Φ에 대해,

x isInvertibleAs Φ : isInvertibleAs(x, Φ) : ∃y s.t. Φ(x, y)

인 isInvertibleAs로, FOL에서는 술어가 아닌 성질꼴로, 여러가지 성질의 접두사로 동작하며, 그 경우 Φ과 isInvertibleAs를 붙여쓴다.

그러나 권장사항은 SOL에서의 사용이다.

왜냐하면, 내가 FOL로 만들기 디껍고 귀찮기 때문이다.

다만 한가지 주의하기 위해 참고할 점은, ∃y라는 y는 해당 구조의 도메인 위에 있어야 하므로, 닫혀있는 원소인 조건이라는것이고, 따라서, 구조위에서의 의미해석을 해야함에 주의하자.

#### 가역원임-술어 (cheking-dose-it invertible-element Predicate)

가역원임 술어 isInvertible는 방금전에 내가 만든 가성질로,

x isInvertible : isInvertible(x)

이며,

isInvertible : isInvertibleAs isInverseOf

로써,

x = y, y = z, x = z에서

x isInvertible : isInvertible(x) : x isInvertibleAs isInverseOf : isInvertibleAs(x, isInverseOf)

인 isInvertible로, isInverseOf조건의 isInvertibleAs로 볼수 있으며,

가역원인지 확인하는 술어이다.

#### 전가역성 (Entire-Invertiblity)

전가역성 EntireInvertiblity는 내가 방금전에 만든 참성질 개념으로, "모든 원소가 가역원"을 말하기 귀찮아, 귀차니즘히 심히 많이 도져 귀찮고 괴로워서, 만든 개념이다.

EntireInvertiblity : "x isInvertible"

로써, 모든 x에 대해서 isInvertible인 일반명제임을 술어 Commutative과 같은 경우로 표기했다는 사실로써 능히 알 수 있다.

### 심볼 목록

아래 심볼은, Volcano에서 사용 목적이 정해진 특수한 심볼이다

#### 항등원 (identity element)

이항연산 `*`의 항등원은

 - 좌항등원 eₗ
 - 우항등원 eᵣ

이 존재하고,

각각

+ eₗ * x = x
+ x * eᵣ = x

를 만족하며,

다음 술어

항등원이존재함(eₗ, eᵣ) : eₗ = eᵣ

에 대해,

항등원이존재함(eₗ, eᵣ) ⊨ ∃e s.t. eₗ = e = eᵣ

인, 즉, 좌항등원과 우항등원이 같으면, "항등원이 존재한다"고 하고, 좌항등원과 우항등원이 같으니, 그것을 "항등원"이라고 하며, 이것의 존재조건인 좌항등원과 우항등원이 같을것이 항등원의 존재 조건이다.

N.B. ATTENTION, WARNING, NOTE(IMPORTANT), WATCHOUT, TIP, DECLARE, READIT : 이하에서, 좌항등원 및 우항등원 기호도 여기에서 정의했으므로, 여기를 참고해야한다는걸 강조하고 또 경고하겠다.

### Laval 대수구조 명칭 목록

**Laval은 Lava + -al이라서, Lava + -적(的) 이라는 뜻이다. `Laval == Lava적(的)`인것이다. (오타아님, 중요)**

어떤 Laval 대수구조 명칭 (= Lava식 대수구조 명칭) K란,

K(Volcanoₘ,ₙ(D, Sym₁, ..., Symₘ, fun₁, ..., funₙ)) : "대수구조 Volcanoₘ,ₙ(D, Sym₁, ..., Symₘ, fun₁, ..., funₙ)가 그 Laval 대수구조 명칭 K가 지칭하는 대수구조를 이룬다"

인 K를 말한다.

예컨데, Magma(Volcanoₘ,₁(D, `*`))은 항진인것이, lava는 기본적으로 닫혀있기에, 그 대수구조 위에 연산이 정의되어있디면 마그마다.

요컨데, Laval 대수구조 명칭은 술어이다.

예컨데 마그마의 Laval 대수구조 명칭 Magma는

Magma라는 영문 명칭 술어이다

#### 1. 1. 단위 마그마 (unit magma)

이항연산 `*`가

Volcano₁,₁(D, e, `*`) ⊨ "이항연산 `*`가 (D, `*`, e)를 이룸"

인 `*`라면, 즉, 항등원을 가진다면,

이를 단위 마그마라고 부른다

Laval 대수구조 명칭은 UnitMagma 이다.

#### 1. 3. 중가환 마그마 (medial magma)

이항연산 `*`가

Volcanoₘ,₁(D, Sym₁, ..., Symₘ, `*`) ⊨ "이항연산 `*`가 (D, `*`)를 이룸", Medial

인 `*`라면, 즉, 당연히 `*`는 마그마니까, 그 마그마가 중가환법칙을 만족시킨다면,

이를 중가환 마그마라고 부른다.

Laval 대수구조 명칭은 MedialMagma 이다.

#### 1. 2. 가환 마그마 (commutative magma)

이항연산 `*`가

Volcanoₘ,₁(D, Sym₁, ..., Symₘ, `*`) ⊨ "이항연산 `*`가 (D, `*`)를 이룸", Commutative

인 `*`라면, 즉, 당연히 `*`는 마그마니까, 그 마그마가 교환법칙을 만족시킨다면, 즉, 가환이라면,

Laval 대수구조 명칭은 CommutativeMagma 이다.

이를 가환 마그마라고 부른다.

#### 2. 1. 반군 (semigroup)

이항연산 `*`

Volcanoₘ,₁(D, Sym₁, ..., Symₘ, `*`) ⊨ "이항연산 `*`가 (D, `*`)를 이룸", Associative

인 `*`라면, 즉, 당연히 `*`는 마그마니까, 그 마그마가, 결합법칙을 만족하면,

이를 반군이라고 한다.

Laval 대수구조 명칭은 Semigroup 이다.

#### 2. 2. 모노이드 (monoid)

이항연산 `*`가

UnitMagma(Volcano₁,₁(D, e, `*`)), Semigroup(Volcano₁,₁(D, e, `*`)) ⊨ "이항연산 `*`가 (D, `*`, e)를 이룸"

인 `*`라면,

즉, 이항연산 `*`가 반군을 이루며, 단위 마그마를 이루면, 

이를 모노이드 (monoid)라 한다.

Laval 대수구조 명칭은 Monoid 이다.

#### 2. 3. 군 (Group)

이항연산 `*`가

(⊨ Monoid(Volcano₁,₁(D, e, `*`)) ⊨ EntireInvertiblity) ⊨ "이항연산 `*`가 <D, `*`>를 이룸"

인 `*`라면,

즉, 이항연산 `*`가 반군을 이루며, 전가역이면 (= 전가역성을 띄면 = 전가역성을 만족하면)

이를, 군이라 한다.

Laval 대수구조 명칭은 Group 이다.

#### 2. 4. 아벨 군 (Abelian Group) • 가환군 (Commutative Group)

> 솔찍히 중학교때 생각한 생각인대 소신발언 하자면, 오차방정식의 근의공식이 없다는걸 밝힌 위대한 수학자 아벨(Abel)님이 너무 고생하고 비참하긴 한데, 대학못간새끼만큼 비참한건 아니니까, (반대하면 인신공격하고싶... 크흠..), 우리 학생들을 위해 과감히 버리고, 가환군이라고 부르는게 좋다고 본다. 소신발언임 주의.

이항연산 `*`가

CommutativeMagma(Volcano₁,₁(D, e, `*`)), Group(Volcano₁,₁(D, e, `*`)) ⊨ "이항연산 `*`가 <D, `*`>를 이룸"

인 `*`라면,

즉, 이항연산 `*`가 군을 이루는 동시에 가환 마그마를 이룬다면,

이를, 가환군 • 아벨군 이라고 하며,

(또한, AbelianGroup = CommutativeGroup 이고)

Laval 대수구조 명칭을 CommutativeGroup로 한다.

(당연히 AbelianGroup = CommutativeGroup이므로, AbelianGroup로 해도 된다. 왜 대입이 되는지는 "Laval명칭"의 정의 참고. (술어임))

#### 2. 5. 자명군 (trivial group)

이항연산 `*`가 

Group(Volcano₁,₁(D, e, `*`)) s.t. D = {e} ⊨ "이항연산 `*`가 <{e}, `*`>를 이룸"

일때, 이를 자명군이라고 하고, Laval 대수구조 명칭을 TrivialGroup 이라 한다

#### 3. 2. 고리 (Loop, 위키백과에선 고리라고 했다만, 수학계에서는 루프라고 부른다고 카더라)

이항연산 `*`가

Quasigroup(Volcano₁,₁(D, e, `*`)), UnitMagma(Volcano₁,₁(D, e, `*`)) ⊨ "이항연산 `*`가 <D, *>를 이룸"

일때, 이를 고리라고 하고, Laval 대수구조 명칭으로 Loop 이라 한다.

Quasigroup에 대해서는 최하단 탐구 예정 노트 참고

### 성질, 예약 심볼, 대수구조에 대한 해설

#### 결합법칙에 대해 해설하며 ; Associatival Extension과 반군

m항연산 f가 Associative를 만족한다면, m < n인 n에 대해,

f(x₁, ..., xₙ) ≜ f(x₁, ..., xₘ₋₁, f(xₘ, ..., xₙ))

로 제귀적으로 정의하며,

이러한 구조의 작동 원리는 결합법칙에 근거한다.

이러한 제귀적 정의를 결합적 확장 (Associatival Extension)이라고 부르며, 내가 방금 만들어낸 조어이다

m, n은 무한해도 좋을거다. 아마도.

Associatival Extension에 의해, m항연산과 가변항연산의 경계가 허물어지는 특징을 보이기에, 반군인 연산은 k항연산이라면, 최소 항의 수를 k로 간주한다.

#### 역원임-술어에 대해 설명하기 : 좌역원이자 우역원이면 역원임 정리

좌역원이자 우역원이면 역원임 정리는 내가 만든 정리로, 사실 정리라고 하기에도 존나 애매한 난이도다.

+ p' = p ∧ r
+ q' = q ∧ r
+ s = p ∧ q
+ s' = s ∧ r

에서,

p' ∧ q' = s'임은 당연히 안다.

이때,

+ p = 좌역원임-가술어이고
+ q = 우역원임-가술어이고,
+ r = 항등원이존재함(eₗ, eᵣ)일때,

좌역원임-술어, 우역원임-술어, 역원임-가술어, 역원임-술어의 정의에 따라, 

좌역원임-술어 ∧ 우역원임-술어 = 역원임-술어

이라는것이다.

## 의미해석

(작성중; 규칙도입계와 기초적 파악이 어떻게 작동하는지를 먼저 적겠음. 나중에.)

### 규칙도입계

(작성중)

### 기초적 파악

앞으로 말할 L은 모델론적 언어라는 맥락에서 말하는거다.

또한, (작성중)

#### 명세관계 ; isInterfaceOf

T isInterfaceOf L : isInterface(L, T) : (L ⊨ T) s.t. (∀T' ⊨ L)(T ⊨ T')

T는 L의 명세인 관계로, L의 기초임을 알리는 관계다.

L의 정의 ⋅ 규칙을 담당하는 부분으로, 논리 언어 Lₗₒₛᵢₖ (저 및첨자들은 원래 "losik"이 아닌 "logic"로 쓰려고 했지만, 유니코드의 한계상 포기)이 자연 연역(Natural Deduction)하는걸 제외한, 규칙계형 파트로 전반적 논리를 구성한다.

예를들어 L은 TensorFlow, T는 그 공식 document로, 기능은 L에 있고, 그 원리가 T이다.

예를들어,

L = 페아노 산술, T = peano axioms and defines이면,

L"1 + 1 = 2"에서,

정의는, T에서,

```markdown
## DEFINITION

### 덧셈 `+`의 정의

1. x + 1 = x⁺
2. x⁺ + y = (x + y)⁺

여기에서, 정의 2번에 1번을 대입하면, (x + 1) + y = (x + y) + 1로, 결론을 부정하는 조건을 만족하는 명제를 역산해보자면, 그것이 바로 교환법칙의 부정과 결합법칙의 부정이므로, 부정한 결론이 틀림에 근거하여, 이중부정을 통해, 덧셈은 가환반군을 이룸을 알 수 있다. 참고로, 0을 정의하지 않은 버전에서는 모노이드도 아니고 걍 반군이다.

## AXIOMS

다음 다섯 공리를 만족하는 상수 1과 집합 ℕ이 존재한다.

1. 1 ∈ ℕ
2. n ∈ ℕ ⇒ n⁺ ∈ ℕ
3. ∀n ∈ ℕ, n⁺ ≠ 1
4. ∀n ∈ ℕ ∀m ∈ ℕ, n⁺ = m⁺ ⇒ n = m
5. ∀S ⊂ ℕ, (1 ∈ S ∧ (n ∈ S ⇒ n⁺ ∈ S)) ⇒ (S = ℕ)

공리 5를 자연수의 귀납적 정의라고 하며, 이는 무한공리에서 말하는 무한집합 중 최소의 크기를 가지는 집합이라는 뜻이다. 또한, 저기에서 수학적 귀납원리가 나온다.

저걸 함수의 언어로 바꾸면, 어떻게 모델을 구축해야할지 보인다.

4번 공리를 보아하니, 다음수 연산 `⁺`는 단사(일대일함수)이다. 그런데, 치역이 1 이상의 자연수 전체이므로, 해당 자연수를 정의역으로 하고 치역이 1이상의 자연수를 치역으로 한다면, 전단사함수(일대일대응)일것이고, 따라서, 다음수 연산은 역함수인 이전수 `⁻`를 가진다. (이 설명의 근걸는 2번 공리 함고)

3번, 1번, 5번 공리를 보면, 자연수는 1에서 시작해서 연쇠적으로 세어나가면서 나오는 수들의 집합이다.

참고로 5번 공리를 보지 말고, 2번 공리만 보더라도 알 수 있다.

사실 5번 공리에 1번 공리에 쓰인 텍스트와, 2번 공리에 쓰인 텍스트가 전부 들어간 점에서, 우리는 자연수 집합 S = ℕ을 다룰떄, 1번, 2번, 3번 공리를 보면 됨을 쉽게 알 수 있다.

사실은, 이것의 모델에서 1은 상수 심볼인데, 번외에서 신기한 특징을 다루겠다.

## 번외

다음 술어 ℙ₁, ℙ₂, ℙ₃, ℙ₄, ℙ₅를 DEFINE하자.

ℙ₁(k, ℕₖ) : k ∈ ℕₖ
ℙ₂(k, ℕₖ) : n ∈ ℕₖ ⇒ n⁺ ∈ ℕₖ
ℙ₃(k, ℕₖ) : ∀n ∈ ℕₖ, n⁺ ≠ k
ℙ₄(k, ℕₖ) : ∀n ∈ ℕₖ ∀m ∈ ℕₖ, n⁺ = m⁺ ⇒ n = m
ℙ₅(k, ℕₖ) : ∀S ⊂ ℕₖ, (ℙ₁(k, S) ∧ ℙ₂(k, S)) ⇒ (S = ℕₖ)

다음은 AXIOMS이다.

다음 공리를 만족하는 상수 k와 집합 ℕ이 존재한다.

1. ℙ₁(k, ℕₖ)
2. ℙ₂(k, ℕₖ)
3. ℙ₃(k, ℕₖ)
4. ℙ₄(k, ℕₖ)
5. ℙ₅(k, ℕₖ)

여기에서도, 4번공리를 통해 다음수의 특징이 유추되며,
1, 2, 3번공리를 통해, k부터 시작하는 자연수(서수) ℕₖ를 정의함을 알 수 있다.

참고로, 덧셈의 정의를 통해서 다름수의 뜻을 알수 있음은 너무 당연한 사실이고, 여기서도 동일하다.

참고로 ℕ₀를 범자연수라고 하며, 𝕎 = ℕ₀로 표기하기도 한다.

참고로,

수가 0, 수가 null(=Null), 수가 NaN인것의 차이가 뭐냐하면,

0은 잔액이 0,
null은 잔액이 없음 (= 그런거 없음)
NaN은 잔액이 수가 아님 (= 0/0꼴)
인것이라서,

0은 통장 잔액이 텅장
null은 통장이 없음
NaN은 통장 잔액이란 개념이 없음

이었던가...? 그랬다.

그런데 잔액이 없는거 (수량을 보는데 그값이 없음(=null))랑 잔액이 0인거 (수량이 0인것)가 무슨 차이인가?

수량으로써 0은 그것이 수량으로 있어야 한다.

0은 없는것을 의미하는, 즉, 1 - 1을 의미하는 수량이고,

이게 자연수가 되야하는지는 논란이었다. (= 자연에 있는 수인지, 자연으로부터 나오는지 논란)

그러나, 수라는게 자연을 설명하는것이고, 셈을 시도했을때, 무조건 ℕ₀(= 𝕎)나 NaN(=원래는 실수에서 정의역 벗어남이지만, 여기서는 범자연수로 치자.)으로 세어지므로, 범자연수로 다룬다고 합리화하는것 같다.

솔찍히 나도 뭐가 맞는지 모르겠고, 걍 범자연수로 구축하는게 용이한건 확실하다.

그래서 실제로, 페아노 공리계를 구축할때는, 범자연수를 쓴다고 한다.
```

이므로, 해당 언어는 모델론이 의미하는 규칙에 따라, L"1 + 1 = 2"가 L"1⁺ = 2"로 치환되서 (덧셈의 정의), 심볼 '2'가 의미하는 바가 1의 다음수를 표기하는 Notation임을 알 수 있다.

그러니까 십진법 기호 표기법은,
1. 2 = 1⁺
2. 3 = 2⁺
3. 4 = 3⁺
4. 5 = 4⁺
5. 6 = 5⁺
6. 7 = 6⁺
7. 8 = 7⁺
8. 9 = 8⁺
   
를 만족하는 모델론적 언어로 볼 수 있다.

십육진법에서는
1. 추가규칙 아님, 상단참고
2. 추가규칙 아님, 상단참고
3. 추가규칙 아님, 상단참고
4. 추가규칙 아님, 상단참고
5. 추가규칙 아님, 상단참고
6. 추가규칙 아님, 상단참고
7. 추가규칙 아님, 상단참고
8. 추가규칙 아님, 상단참고
9. A = 9⁺
10. B = A⁺
11. C = B⁺
12. D = C⁺
13. E = D⁺
14. F = E⁺
    
인 추가 규칙이 생기는것이고 말이다.

참고로, 범자연수식으로 보자면, 1 = 0⁺로 정의된다.

물론 이에 대해, 항상 참인거 아니냐고 물을 수 있을텐데, 무한공리를 허용하지 않으면, 이러한 구축방법은 참이 아니고, 이런식으로 정의와 공리를 적고 나서 그를 만족시키는 모델이 존재하지 않는...

예컨데, 공리에 1 = 2를 추가하면 배중률을 어기는데, 이를 만족하는 모델은, 더이상 형식논리가 아니므로, 항상 참은 아니다.

하필 자연수의 덧셈을 가져와서 항상 참이지만

하필.

#### 구현관계 ; isImplementOf

M isImplementOf T : isImplementOf(T, M) : T isInterfaceOf L, M ⊨ T ⊨ L

M이 T의 구현 (Tip : 구현체로 이해해도 좋음)인 관계로, M은 T인 체계를 구성한다.

L언어와 그것을 이룰 요건인 기초 T를 만족하는 M은 구조모델이고, M은 기초 T와 Pre와 Fun, Sym정의 등을 구현(=구성)하며, M ⊨ L ⊨ T인 측면이 있다.

그러나 T의 본질이 M인지 확신할 수 없으며, 당장 FOL에서 뢰벤하임-스콜렘 정리 (Löwenheim–Skolem theorem)등에 따라서, 본질이라기 보다는, 수학적 • 구조적 정합성 측면에서 본질로 볼 수 있는 측면이 있는 구현(=형식화, 사실 정의 되는지도 모르겠는걸 분석 후 모델로써 정의하는것같은 원리다)이지, 유일한, 그리고 절대적인 진리 따위가 아니다.

뢰벤하임 스콜렘 정리에 따라서, 여러가지 모델로 본질을 표현할 수 있다고 하고, 당장에 실수에 대해서, Łoś's theorem으로 만든 `ℝ*` (초실수체, hyperreal field) 만 봐도, 알 수 있다.

그러나 겉모습만 보여주고 그걸 본질이냐고 묻는데에 대해서는 전혀 그렇게 확신할 근거가 없다고 단언한다. 근거를 가져와야한다.



다시 돌아와서, T와 M에 대해 말하자.

예컨데 T는 TensorFlow의 document, M은 일게 그 구현체,

혹은 T는 C언어나 LISP, M은 gcc나 Racket을 예로 들수 있을것이다.



다시한번 이전에 peano공리계로 예를 들었듯 peano공리계 T와 체르멜로(Zermelo)의 구성(Constructure) M과, 폰 노이만 (von Neumann)의 구성 `M'`으로 예를 들어보자 

먼저 M은

```markdown
s(x) = x⁺에서,

0 := ∅
s(x) := {x}

즉,

M = <ℕ₀, 0 = ∅, s(x) = {x} s.t. codom s = ℕ>

인 체계로,

16진수 표기법은,

0 := ∅에서,

1. 1 := {0}
2. 2 := {1}
3. 3 := {2}
4. 4 := {3}
5. 5 := {4}
6. 6 := {5}
7. 7 := {6}
8. 8 := {7}
9. 9 := {8}
10. A := {9}
11. B := {A}
12. C := {B}
13. D := {C}
14. E := {D}
15. F := {E}

로 볼 수 있다.

덧셈은, 범자연수에 대해 가환 모노이드를 이룬다.

> 
> pf.
> 
> 기본적으로 덧셈은 가환 반군을 이룬다.
> 
> 집합 중간에 구멍을 송송내서 닫히지조 못하게 고문하는 경우는 제외하고 말이다.
> 
> 그런 비정상정임경우를 가져오는 미친놈은 아마 없을것이다.
> 
> ~~(가져온다면 덧셈왈 나는 입이없지만 소리를 질러야 한다 이럴듯하다)~~
> 
> 0 + 1 = 0⁺ = 1이므로,
> 
> (0 + x)⁺ = 0⁺ + x = 1 + x = x + 1 = x⁺임을 알수 있는데,
> 
> (x + 0)⁺ = x⁺이므로,
> 
> x + 0 = x임을 알 수 있다.
> 
> 즉 항등원을 가지니, 단위 마그마를 이룸을 알 수 있다.
> 
> 가환 반군이자 동시에 단위 마그마인것은, 가환이고 반군이자, 동시에 담위 마그마인것으로, 가환이고, 모노이드인것으로, 가환 모노이드이다.
> 

2 + 2 = 4인것은,

2 = 1⁺이기에,

2 + 1⁺ = 1⁺ + 2 = (1 + 2)⁺ = (2 + 1)⁺ = 3⁺ = 4로 구할 수 있다.



덧셈은,

1. Φ₁(`*`) : `x * 1 = x⁺`
2. Φ₂(`*`) : `x⁺ * y = (x * y)⁺`
3. Φ : Φ₁, Φ₂

이게 정의한 술어 Φ에서,

Φ(`+`)인 연산이다.

사실은 (+ 1) = s 이게 정의되며, 닫혀있다면 가환반군을 이룰성질을 부여해서 구축했다고도 볼 수 있다.

근데, 이러면, 단점이 좀 있어서, 충분히 나은 폰 노이만 방식을 택한다.

당연히 최대효율을 택하는 한계효용 생각해보면 합리적으로 보인다.
```

`M'`은

```markdown

자연수가 서수(ordinal) 이게도 만들어주는 장점많은, 삐까뻔쩍한 구성이다.

s(x) = x⁺에서,

0 := ∅
s(x) := x ∪ {x}

식으로 구성한다.

즉,

`M'` = <ℕ₀, 0 = ∅, s(x) = x ∪ {x} s.t. codom s = ℕ>

사실 도매인(정의역, 모델의 닫여야하는 집합)이 ℕ₀일떼, codom s = ℕ임은 전부 그렇다.

이 점에서, 자연수가 간단히 나오니 걍 범자연수 구축이라도 왜 이래야 하는지 따지지 말고 받아들여줬으면 좋겠다.



자, 폰 노이만 구성에서 16진수 표기법은

0 := ∅ (= {}) 에서,

1. 1 = {0}
2. 2 = {0, 1}
3. 3 = {0, 1, 2}
4. 4 = {0, 1, 2, 3}
5. 5 = {0, 1, 2, 3, 4}
6. 6 = {0, 1, 2, 3, 4, 5}
7. 7 = {0, 1, 2, 3, 4, 5, 6}
8. 8 = {0, 1, 2, 3, 4, 5, 6, 7}
9. 9 = {0, 1, 2, 3, 4, 5, 6, 7, 8}
10. A = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
11. B = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A}
12. C = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B}
13. D = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C}
14. E = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D}
14. F = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E}

이다.

마찬가지로 반군을 이루고, 덧셈의 구성 방법도 같다.



폰 노이만 식이든 체르멜로 식이든

Rank x = x 임은 같고,

x ∈ x⁺임도 같지만

폰 노이만 방식은

0, 1, ..., x ∈ x⁺

이며,

card x = x (단. 이 문장은 엄밀하지 못하다. 범자연수와 기수와 서수는 다른것이, 기수(카디널리티, 카디널)는 "××집합의 카니덜은"이라고 말하는데에서 알수 있듯, 집합에 대한것이다 (정의상), 집합의 카디널리티는 일대일대응이 있으면 같은것이므로, 카디널리티(기수)를 범자연수로 정의하지 아니하였다면, 카디널이 같은지 여부에서는, 에초에 관계의 정의역에 들어가지 못하는 불상사다 일어나, 항위일것이니, 카디널리티가 범자연수인 경우에 맞는 문장이다)

이라는것이 특징이다.

또한, y ≤ x에서,

y ⊂ x으로,

외연공리를 이용하여 같은지 다른지를 알 수 있는 장점이 있다.

사실 범자연수 집합의 존재성은, 무한 공리에서 보장한다.

ZF공리계에서 초한수의 최소이자 초한기수의 최소는 자연수번째 무한 혹은 자연수의 카디널, 즉 자연수 크기의 무한인데,

무한 공리에서 말하는 최소 크기의 무한집합이 자연수이기 때문이다. (자연수의 정의)

그리고 이게 표준 방법이다.

비표준이라고 틀린건 아니지만, 권총과 망치로 인해 표준이 맞는것처럼 치도록 강제할수 있다.

사회라는 약속으로.
```

위와같이 모델을 만들수 있어도, 이것이 왜 그 구현이여야 하는지 잘 모르겠지 않나?

진짜 자연수는, 그 본질이 공리계에 있을것이다.

(사실 굳이 그 공리계로 잡지 않아도, 다른 공리계가 그 공리계를 만족시킨다.)

아마도 말이다. 이것은 본질이라기에는 실용적 구현에 가까워보이니, 함부로 명세가 본질이네 구현이 본질이네 할 증거가 없다고 단언한것이다.

그 증거를 더 가져와야 한단것을.

그리고, 자연수의 두 구현체를 보고, 당연히 그런식으로 약속했으니 그렇게 되는것 아니냐고 묻는다면 말하겠다.

당신은 Lisp(언어)와 Racket(구현체)이 완전히 동일하다고 생각하는가?

#### 상속자 : Extender

자, 이제부터 다루는 내용이 핵심이다. isInterfaceOf나 isImplementOf는 일게 모델론적 개념의 표기법용 노트의 설명에 불과하다.

내가 설명항 내용은 지금부터 시작이고, 의미해석의 핵심 파트는 상속사, 피상속자, 참피상속자, 섹터, 명제귀결, 구조귀결, 폼페이 함수를 이용한, 기초적 파악이고, 이중 피상속사 참피상속자, 섹터같은 구조가 상속자에서 나온다.
그러나 핵심적인 논리흐름은 명제귀결, 구조귀결을 알아야 하고,
다루는 대상은 기초적 파악이다.

자, 본론으로 들어가보자.

Interface, Implement, Extend... 사실 이것들은 다 Object Oriented Programming Language인 Java에서 따온 명칭이다.

뭐... 그냥 그렇다는거다.

Extenderₙ(M₁, ..., Mₙ) ≜ M s.t. M₁, ..., Mₙ ⊨ M

Extender(상속자)란 n개의 Implement들을 상속한 Structure Model을 주는 함수로 (작성중)

#### 피상속자 ; ExtenderalObject

(작성중)

#### 참피상속자 ; DistunalExtenderalObject

(작성중)

#### Sector

(작성중)

#### 명제귀결 ; ProposolalConsequence

(작성중)

#### 명제귀결도입기반 구조귀결 ; ProposolalConsequenceIntroduceSystemicConsequence

(작성중)

#### 폼페이 함수 ; Pompeii

(작성중)

#### 기초적 파악

(작성중)

## NOTE

작성중이고, 함자 (* x), (x *)가 준동형사상인 마그마가 유사군(quasigroup)이라고 하는데, 어떻게 적어야 할 지 모르겠으니, 범주론 배울때 배워보자.

유사군의 Laval 대수구조 명칭을 Quasigroup라 하자.
