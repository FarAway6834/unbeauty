# 논리학 ; 이과에게 인문의 길을 열어주다.

1편 : done
2편 : *재작중...*

## (요즘 선행하는 중2도 할수있는 이과를 위한) 논리학 ; 이과에게 인문의 길을 열어주다. (고2 수준의 수학에 대한 논술로, HOL너머까지 가는 뇌절이자 급발진, 개념의 폭주. 머리 터지는 퍼즐 좋아한다면 사지 않을 이유가 없다!) - 1편

안녕, 난 저자야. 독자 여러분은 천재 중 2일거라고 기대해, 아니면 이 폭주 노트를 따라가다가 가랑이가 찢어질거야, 이건 이미 아는사람만 보이는 글이거든 ㅋㅋㅋ

먼저 고2 확률과 통계에서 확률변수와 확률분포 배웠지? 지금부터는, 수학적인 명제는 죄다 사건취급할거야. 결과가 정해진게 아닌 우연명제가 아니고서야 어케 사건이냐고? Kolmogorov공리는 그런거 신경 안쓰니까.
근데, 명제는 확률분포가, X = 1일때 P고 X = 0일때 P가 아닐때, P(X = 1 - x) = 1 - P(X = x)이고, 정수인 분포를 만들꺼고, 이러한 확률분포의 치역을 "진리값"이라고 할께. 명제에서 우리가 참•거짓을 평가할때, 기본적인 사건, 가령 "나는 17살이다"는 수학 밖이니까, 마음대로 평가할수 있기에, 값을 배정 가능한데, 이를 "진리값배정"이라 할께, 진리값배정이 자유로우니, 명제를 사건으로 보면 항상 독립이야.

미리 논리를 전개하지 앞서 말해보자.

$ \begin{cases} x, & p, \ y, & ¬p \end{cases} = P(p)x + (1-P(p))y = P(p)(x - y) + y $

이지. 이 조건문은, 너가 공식을 스스로 유도하는 고수가 아니라 중수라면 이해하기 어려울테니, 유도나 하고 와서 이해하는게 나아.

고2의 1학기에 확통에서 사건의 종속과 독립을 배웠으니, 1등급 학생이라면 쉬울것임을 확신해.

P("it's too easy to you") = 1이라고 ㅋㅋㅋ 1등급이 얼마나 힘든데 ㅋㅋ

[x := y]가 변수 x를 y로 치환하는 대입일때,

(λx. t)(v) = t [x := v]라고 하면, 이건 함수처럼 동작하지?

근데, 고1, 2학기의 첫단원에서 배운 집합과 명제 단원에서, 함수는 집합과 집합의 대응이라 했으니 함수는 아냐.

이건 람다대수야.

중학교 정보시간과 고1 정보시간에는 python을 배워. 알지?

```python
def temp(x):
    # some code
    return y
```
여기에서, y = 2 * x같은걸 적으면 프로그래밍적 함수인 서브루틴이 아닌 수학적 함수겠지?

근데 저런 일변수함수는 사실

```python
temp = lambda x : y # need to fix this code ; y to real source
```

이런식으로 작성 가능하지. 

저 주석이 뭐냐고? 별건 아니고, 다소 의역하자면, y는 x에 대한 식이니까 그 구현을 하라는거지. 저런식으로 코드짜면 안되지만, 생각하기 위해서 제시하겠다는거야.

만약 독자 여러분이 "잠시만, 그리스 문자 λ의 스펠링이 정확이 lambda잖아?"라고 생각했다면 정답이지.

(λx. y) 와 (lambda x : y)는 그 입출력에서 타입만 다르고 동작이 동일하니까, 동형이라고 보면 돼.

동형이라고 말했다지만 어찌피 HoTT에서는 같게볼 터이니 같다고 생각해도 좋아. 실제로 같진 않아도 사실상 같으니까.

그러면, 중학교 고등학교 정보시간에 배운 제귀함수는 다음과 같이 응용할수 있어.

먼저, 인지적 부하가 개빡셀테니, 오늘은 여기까지만 봐야함.

엔트리에서 함수 구문을 제귀로 쓸때 어떻개 움직이는지 따라가는 "뇌내 프로그래밍언어 실행"을 전재해야해.

놀랍게도 람다는 "입출력만 빠진 프로그래밍 언어"거든 ㅋㅋㅋ

Y := λf. (λx. f(x(x)))(λx. f(x(x)))

ㅋㅋㅋ 아찔하지? 대입해보자. 대입하면, 함수가 작동하는 "실행"이 이루어질테니.

Yf = (λx. f(x(x)))(λx. f(x(x)))

아직도 아찔해? 정답이다 연금술사! 더 실행돼!! 지옥으로 가자!

(λx. f(x(x)))(λx. f(x(x)))
 = f((λx. f(x(x)))((λx. f(x(x)))))

봤지? 못봤나? 하긴 "(λx. f(x(x)))(λx. f(x(x)))"가 겁나 복잡하잖아. 이런 프로그래밍 언어는 거의 esolang이지, 이렇게 가독성 구린거 들고가면 욕먹을껄? 그래서 처치 인코딩을 알아야하지만...
G := (λx. f(x(x)))라 하면, 무려 G(G)거든 X := G(G)에서,

이 과정에서 "대입을 한다"는 서술을, 머릿속에서

```python
G = (lambda x. f(x(x)))
```
하는 사고로 바꿔!! 그리고, "핵심 아이디어", 목적에 도달하기 위한 방법!, 우리 목적은 가독성을 통한 이해고, **가독성을 위해서 변수화한다**는 구린 방법으로 이해해보려고 하고있어! 뭐 **분해적 사고**라는 면에서 구리다고 보긴 어렵겠지. 절차 말고 모든건 다 분해하는 방식의 사고가 가능해. 유효하지 않을지라도.

아무트느 X := G(G)에서, 아까 전 식은

X = f(X)라는거야. 궁금하면 직접 아까전에 제시한거랑 문자열을 비교하던가.

f := Y(λf.λx.y) 같은 경우에, g := (λf.λx.y)로 놓으면,

답
 = f(v)
 = (Y(g))(v)
 = ((λx. g(x(x)))(λx. g(x(x))))(v)
 = g((λx. g(x(x)))(λx. g(x(x))))(v)

인데, g(X)(v) = y [x := v] [f := X] 이므로,

답 = y [x := v] [f := (λx. g(x(x)))(λx. g(x(x)))] 이지.

이야 ㅋㅋ 이래서 람다를 이해하고 나면 8086어셈블리나, Python Bytecode같은게 쉬워지나봐. Python의 모든 세부 작동 원리를, Bytecode수준이 아닌 수준중에서 가장 깊게 파도 이거 만나면 진짜 머리 터지는 재밌는 퍼즐이거든.

그치만, 이번에는 코테(코딩 테스트)대비 이론전산 공부에서 배우는 지식에 대한 사전지식이 필요할꺼야!!

수열의 귀납적 정의 알지?

펙토리얼을 수열로 나타내는 점화식을 작성해보자고.

n! = (n-1)! × n (단. 0! = 1)

귀납법은 제귀적인 연역이기에, 이건 사실상 제귀적 정의지.

Γ(n) = (n-1)!일때,

Γ := YλΓ.λn. P(n = 1)(1 - nΓ(n)) + nΓ(n)

인게 그 의미겠지.

사실은 아니 ㅋ 사실은 실행이 안되면, 정의되지 않으니 아니야 ㅋ 저걸 실행 가능하게 하려면, 조건문 공식을 람다대수의 언어수준에서 공리화해야하는데, 그건 내가 고1때 만든 프로그래밍언어 Unbeauty의 동작 방식이야, 물론 중요하진 않아.

근데 이로써 알아야하는건, 너는 이제부터 람다대수를 존나 연습해서, 함수에 함수를 넣는게 부자연스럽지 않은 인간이 되야해. 수->수 의 집합 대응을 벗어나는거야.

그래야지, 함수의 타입의 simple-type인 경우를 이해할수 있어.

만약 당신이 공학도라 하더라도 Haskell의 HM타입 처리를 물어봤을때 대답 못하면, 나같으면 컴공쩍로 천재인 사람은 아닐것같다고 느껴. 물론, 천재일수 있지만, 이론전산정도는 알아야 한다고 보는거지.

이제 술어의 레벨로 넘어가보자.

참고로, 표준 ZFC에서는 이걸 술어라 하면 안되지만, topos(논리를 포함한 대수)적인 아이디어를 가지고 확률을 구하는 함수 P를 동형사상으로서 작동시킨거니까, 별 상관 없어. 어짜피, 이렇게 이해하는게 대한민국 학생 친화적이지.

Φ(x, y) = P("x and y") = P(x)P(y)

이야. 상호 독립일때 사건을 연언시 값이야.

Φ(x) = P("not x") = 1 - P(x)

이야. 여사건의 공식이지. 부정의 값이고.

그러면 부정논리곱 NAND를 이용하여 모든 명제논리의 논리적 결합사를 유도할수 있어!

이것도 못하면 좋은 프로그래머는 아니겠고, 과학도라면 수학도는 못하는거겠지

저건 직관이 아니라, 형식적 조작과 계산의 영역이야.

**"머릿속에서 기호를 조작해라"**

그것이 이 글의 핵심이야. 고수가 되게 해주진 못하지만, 이걸 못하면 절대 초고수가 될수 없어.

고수는 뛴다면, 초고수는 딸깍이야. 극한의 개념 이해나, 극점을 딸깍으로 이해한다고, 나무위키 딸깍. 그게 천재의 영역이냐고? 뺑이치는 소리지, 웃기는소리야.

나는 천재가 아니라 보통의 범주인데, 아까전 딸깍은 나를 말하는거야. 다른애들은 문재풀면서 이해할때, 나는 고생해서 하루이틀 개념만 들여다보면 이해가 돼.

엡실론 델타에 쓰이는 수리논리가 나의 언어이니까.

사실 좋은 프로그래머니 수학도 포기니 뭐니 했는데, 그건 뭐... 개소리로 느껴도 돼. 근성이 중요해 (하루종일 연습해서 너의 언어로 만드는 재미를 알아야만 늘수 있어)

사실 에초에 이 글이 존나 폭주하는 글이라서 이해 못하는게 정상이야, 단지, 지능이 높은데 생각하기를 포기한다면의 케이스를 가정한다는거야.

작성자인 내가 성인도 아니고 평범한 고2라고 ㅋㅋ

왜 NAND가 not x or not y가 되는지는 그 쌍대성때문에 당연한 구조이긴 한데, 이는 명제와 집합 단원에서 이미 드모르강의 법칙을 배웠을테니, 너가 **교과서만 할줄 안다면** 분명히 돼. 안그러고 1등급 붙으면 그건 걍 범부고.

CICERO는 고대 로마의 집적관이자 절충주의 (중용) 철학자 • 논리학자로, 아리스토텔레스의 오르가논의 정언논리를 수용했고, 스토아 학파의 크리시포스가 탐구한 결론을 다음과 같이 내렸지.

각각 고대 그리스어 중 고전 그리스어라고 불리는, 쉽게말해 핼라어인 코이네 그리스어와, 고대 로마의 고전 라틴어, 영어, 한국어로 적을께. 라틴어 버전은 크게 어렵지 않으니 너도 시도해 봐!

(코이네 그리스어 버전 ; 크리시포스의 버전은 소실되었기에, GPT의 작문을 넣는다)
ἐὰν X ὑφίσταται, τότε A γίγνεται·
τοῦτο δέ ἐστιν ὃ οὐ X ἢ B.

(라틴어 버전 ; 실제로 CICERO가 이렇게 말했는지 기억이 안나는데, 내가 저 문장을 보고 이해했기 때문이다. 고대에는 쉼표나 말줄임표가 없었고 틸다도 없었으므로, 이건 걍 CICERO가 한말의 어절만 안틀리고 배낀 행위다, 이해했으니까.)

SI ~, ERGO ⋯ . HOC EST QUOD, NON ~ VEL ⋯ .

(베드런트 러셀과 화이트해드의 Principia Mathamatica에서 정의된 논리곱 기호는 사실 "VEL"에서 유래된거고, 논리합이 쐐기곱 기호를 쓰는건 그 쌍대이기 때문이야, 걍 아래 영어 버전으로 이해해봐)

(영어 버전 ; 이건 내가 영작한거야, 나는 영어를 잘 못하니까, 주의!)

"If ~, than ⋯. this is what, not ~ or ⋯"

(나같으면 저질스럽게 that을 남발할텐데, 피드벡을 받아서 고치긴 했어. 그러니까 내가 영작했단건 구라야. what대신 that을 썼었을껄...)

(한국어 버전 ; 뭐.... 난 한국인이지만, 다소 의역이지.)

"~면 ⋯라는 것. 이것은 다음; ~가 아니다, 혹은 ⋯이다. 과 정확히 들어맞는다."

왜일까? 훌륭한 해커나 프로그래머인 칼리리눅스를 쓰는 친구를 이해시킨 방법으로 말해볼께,

전건긍정과 후건긍정이 통하고, 전건부정의 오류와 후건긍정의 오류가 존재하니까, 진리표를 그리면, 두 논리식의 interpretation이 정확히 같다.

어때? 쉽게 말하자면, 

| P | Q | | SI P ERGO Q | HOC EST | NON P | VEL | Q | 비고 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| T | T | | T | T | F | T | T | P긍정시 Q는 긍정됨, 가언문 valid |
| T | F | | F | T | F | F | F | P긍정시 Q는 긍정됨, 가언문 invalid |
| F | T | | T | T | T | T | T | SI 0/0 = 1, ERGO 0 = 0은 자연수 산술을 정의하면 부당하지만, 정의하지 않았다면 타당하고 불건전하다. 전제가 거짓인데, 결론이 참인 경우는 충분히 가능하다. 그런 추론은 불건전하다. 그러나, 이항이라는 규칙 자체는 타당하다. 전건이 부정되었더라도 후건이 참일수 있다는 진술이 참임이 중요하며, 후건이 긍정되었더라도 이전 맥락에서 말한 경우일수 있다는 진술이 참임이 중요하다. 전건이 거짓이라서 어짜피 추론으론으로써는, 타당하지만, 불건전하므로, 공허한 참(Vacuous Truth) 이다. 추론의 타당성은, 증명 관계에 있다는 진술의 진리값이니까. |
| F | F | | T | T | T | T | F | 후건부정 규칙이다. 귀류법을 생각하라. |

이지 ㅋㅋㅋ

핵심은 형식 논리 (formal logic)은 형식 언어 (formal language)야. 논리 언어야. 형식 논리 언어. 그리고 여기에서는 모호함 (Amongus; 두가지 이상으로 해석될 여지)이 없어야 해. **단 하나의 뜻으로 명확히 해석**된다는거야. 그래, 속뜻같은게 사라지고, 의미론적으로 동등함은, 진술의 진리값의 동등성과 같아져.

그렇기에 수학적 연언은 포함적-or 이고, 수학적 가언은 모종의 인과가 생략될수 있지.

예를들어, "선하다는 맥락이라면 그것은 선하다"는 말은, 그러한 맥락이 중요해.

그러나, 형식 언어는 그런 맥락은 싹다 무시해버리는 점이 big shock지.
그래서, DLPFC가 고장난 놈들도 형식 논리는 쉬워. 계산이라는거야.

이미 독자 여러분은 명제논리를 마스터한거야. 이 다음은 술어논리야. 그 전에, 자연어적 이해을 돕기 위해 만족관계부터 콰인식 아이디어로 빌드업 해보도록 할께.

지금까지그 이해하기 어려웠어도 괜찮아. 나중에 **형식 언어의 고정성**이라는 내가 정리한 내용을 이해할 레벨이 되기 전까지는 그냥, 명제를 평가하는 방법에 있어서, interpretation, 즉 진리값배정을 한다고 생각하고 읽어야해. 그것이 명제논리의 의미론이야.

자, 그럼 나중에 2편에서 만나기로 하자고! valete amici!

## (요즘 선행하는 중2도 할수있는 이과를 위한) 논리학 ; 이과에게 인문의 길을 열어주다. (고2 수준의 수학에 대한 논술로, HOL너머까지 가는 뇌절이자 급발진, 개념의 폭주. 머리 터지는 퍼즐 좋아한다면 사지 않을 이유가 없다!) - 2편

안녕! 난 저자야, 다시 반나서 반갑네. 저번시간에 우리는 명제와 집합 단원을 공식화하고, 람다 함수(익명 함수)에 대해 다뤘었지

이번에는, 본격적으로, 함수에 대한 이야기를 시작할테니 따라와봐!

먼저, 고1 명제와 집합 단원에서, 함수는 정의역에서 치역으로 가는대응이라 했고, f : X ↦ Y라고 했어.
그리고 집합은 조건 제시법으로 표시되고, ℕ = {x | x는 자연수} 식으로 표기 가능하고, ℤ = {x | abs(x) ∈ ℕ}, ℚ = {y | y = a/b, a ∈ ℤ, b ∈ ℤ, b ≠ 0} 식으로 쓸수 있다고 했지?

그러면, 함수의 집합도 충분히 적을수 있어.

Func(X, Y) = {f | f : X ↦ Y}

로.

사실 저게 뭔지 이해 돼도 어캐쓰이는지 감이 안올꺼야. 그치?

*작성중*