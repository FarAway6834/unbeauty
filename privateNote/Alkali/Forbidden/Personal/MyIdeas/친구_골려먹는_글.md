먼저 고2 확률과 통계에서 확률변수와 확률분포 배웠지? 지금부터는, 수학적인 명제는 죄다 사건취급할거야. 결과가 정해진게 아닌 우연명제가 아니고서야 어케 사건이냐고? Kolmogorov공리는 그런거 신경 안쓰니까.
근데, 명제는 확률분포가, X = 1일때 P고 X = 0일때 P가 아닐때, P(X = 1 - x) = 1 - P(X = x)이고, 정수인 분포를 만들꺼고, 이러한 확률분포의 치역을 "진리값"이라고 할께. 명제에서 우리가 참•거짓을 평가할때, 기본적인 사건, 가령 "나는 17살이다"는 수학 밖이니까, 마음대로 평가할수 있기에, 값을 배정 가능한데, 이를 "진리값배정"이라 할께, 진리값배정이 자유로우니, 명제를 사건으로 보면 항상 독립이야.

미리 논리를 전개하지 앞서 말해보자.

$ \begin{cases} x, & p, \ y, & ¬p \end{cases} = P(p)x + (1-P(p))y = P(p)(x - y) + y $

이지. 이 조건문은, 너가 공식을 스스로 유도하는 고수가 아니라 중수라면 이해하기 어려울테니, 유도나 하고 와서 이해하는게 나아.

고2의 1학기에 확통에서 사건의 종속과 독립을 배웠으니, 1등급 학생이라면 쉬울것임을 확신해.

P("it's too easy to you") = 1이라고 ㅋㅋㅋ 1등급이 얼마나 힘든데 ㅋㅋ

[x := y]가 변수 x를 y로 치환하는 대입일때,

(λx. t)(v) = t [x := v]라고 하면, 이건 함수처럼 동작하지?

근데, 고1, 2학기의 첫단원에서 배운 집합과 명제 단원에서, 함수는 집합과 집합의 대응이라 했으니 함수는 아냐.

이건 람다대수야.

중학교 정보시간과 고1 정보시간에는 python을 배워. 알지?

```python
def temp(x):
    # some code
    return y
```
여기에서, y = 2 * x같은걸 적으면 프로그래밍적 함수인 서브루틴이 아닌 수학적 함수겠지?

근데 저런 일변수함수는 사실

```python
temp = lambda x : y
```

이런식으로 작성 가능하지.

만약 독자 여러분이 "잠시만, 그리스 문자 λ의 스펠링이 정확이 lambda잖아?"라고 생각했다면 정답이지.

(λx. y) 와 (lambda x : y)는 그 입출력에서 타입만 다르고 동작이 동일하니까, 동형이라고 보면 돼.

동형이라고 말했다지만 어찌피 HoTT에서는 같게볼 터이니 같다고 생각해도 좋아. 실제로 같진 않아도 사실상 같으니까.

그러면, 중학교 고등학교 정보시간에 배운 제귀함수는 다음과 같이 응용할수 있어.

먼저, 인지적 부하가 개빡셀테니, 오늘은 여기까지만 봐야함.

Y := λf. (λx. f(x(x)))(λx. f(x(x)))

ㅋㅋㅋ 아찔하지? 대입해보자.

Yf = (λx. f(x(x)))(λx. f(x(x)))

아직도 아찔해? 정답이다 연금술사!

(λx. f(x(x)))(λx. f(x(x)))
 = f((λx. f(x(x)))((λx. f(x(x)))))

봤지? 못봤나? 하긴 "(λx. f(x(x)))(λx. f(x(x)))"가 겁나 복잡하잖아. G := (λx. f(x(x)))라 하면, 무려 G(G)거든 X := G(G)에서,

X = f(X)라는거야. 궁금하면 직접 아까전에 제시한거랑 문자열을 비교하던가.

f := Y(λf.λx.y) 같은 경우에, g := (λf.λx.y)로 놓으면,

답
 = f(v)
 = (Y(g))(v)
 = ((λx. g(x(x)))(λx. g(x(x))))(v)
 = g((λx. g(x(x)))(λx. g(x(x))))(v)

인데, g(X)(v) = y [x := v] [f := X] 이므로,

답 = y [x := v] [f := (λx. g(x(x)))(λx. g(x(x)))] 이지.

수열의 귀납적 정의 알지?

펙토리얼을 수열로 나타내는 점화식을 작성해보자고.

n! = (n-1)! × n (단. 0! = 1)

귀납법은 제귀적인 연역이기에, 이건 사실상 제귀적 정의지.

Γ(n) = (n-1)!일때,

Γ := YλΓ.λn. P(n = 1)(1 - nΓ(n)) + nΓ(n)

인게 그 의미겠지.

사실은 아니 ㅋ 사실은 실행이 안되면, 정의되지 않으니 아니야 ㅋ 저걸 실행 가능하게 하려면, 조건문 공식을 람다대수의 언어수준에서 공리화해야하는데, 그건 내가 고1때 만든 프로그래밍언어 Unbeauty의 동작 방식이야, 물론 중요하진 않아.

근데 이로써 알아야하는건, 너는 이제부터 람다대수를 존나 연습해서, 함수에 함수를 넣는게 부자연스럽지 않은 인간이 되야해. 수->수 의 집합 대응을 벗어나는거야.

그래야지, 함수의 타입의 simple-type인 경우를 이해할수 있어.

만약 당신이 공학도라 하더라도 Haskell의 HM타입 처리를 물어봤을때 대답 못하면, 나같으면 컴공쩍로 천재인 사람은 아닐것같다고 느껴. 물론, 천재일수 있지만, 이론전산정도는 알아야 한다고 보는거지.

이제 술어의 레벨로 넘어가보자.

참고로, 표준 ZFC에서는 이걸 술어라 하면 안되지만, topos(논리를 포함한 대수)적인 아이디어를 가지고 확률을 구하는 함수 P를 동형사상으로서 작동시킨거니까, 별 상관 없어. 어짜피, 이렇게 이해하는게 대한민국 학생 친화적이지.

Φ(x, y) = P("x and y") = P(x)P(y)

이야. 상호 독립일때 사건을 연언시 값이야.

Φ(x) = P("not x") = 1 - P(x)

이야. 여사건의 공식이지. 부정의 값이고.

그러면 부정논리곱 NAND를 이용하여 모든 명제논리의 논리적 결합사를 유도할수 있어!

이것도 못하면 좋은 프로그래머는 아니겠고, 과학도라면 수학도는 못하는거겠지

사실 에초에 이 글이 존나 폭주하는 글이라서 이해 못하는게 정상이야, 단지, 지능이 높은데 생각하기를 포기한다면의 케이스를 가정한다는거야.

왜 NAND가 not x or not y가 되는지는 그 쌍대성때문에 당연한 구조이긴 한데, 이는 명제와 집합 단원에서 이미 드모르강의 법칙을 배웠을테니, 너가 **교과서만 할줄 안다면** 분명히 돼. 안그러고 1등급 붙으면 그건 걍 범부고.

CICERO는 고대 로마의 집적관이자 절충주의 (중용) 철학자 • 논리학자로, 아리스토텔레스의 오르가논의 정언논리를 수용했고, 스토아 학파의 크리시포스가 탐구한 결론을 다음과 같이 내렸지.

각각 고대 그리스어 중 고전 그리스어라고 불리는, 쉽게말해 핼라어인 코이네 그리스어와, 고대 로마의 고전 라틴어, 영어, 한국어로 적을께. 라틴어 버전은 크게 어렵지 않으니 너도 시도해 봐!

(코이네 그리스어 버전 ; 크리시포스의 버전은 소실되었기에, GPT의 작문을 넣는다)
ἐὰν X ὑφίσταται, τότε A γίγνεται·
τοῦτο δέ ἐστιν ὃ οὐ X ἢ B.

(라틴어 버전 ; 실제로 CICERO가 이렇게 말했는지 기억이 안나는데, 내가 저 문장을 보고 이해했기 때문이다. 고대에는 쉼표나 말줄임표가 없었고 틸다도 없었으므로, 이건 걍 CICERO가 한말의 어절만 안틀리고 배낀 행위다, 이해했으니까.)

SI ~, ERGO ⋯ . HOC EST QUOD, NON ~ VEL ⋯ .

(베드런트 러셀과 화이트해드의 Principia Mathamatica에서 정의된 논리곱 기호는 사실 "VEL"에서 유래된거고, 논리합이 쐐기곱 기호를 쓰는건 그 쌍대이기 때문이야, 걍 아래 영어 버전으로 이해해봐)

(영어 버전 ; 이건 내가 영작한거야, 나는 영어를 잘 못하니까, 주의!)

"If ~, than ⋯. this is what, not ~ or ⋯"