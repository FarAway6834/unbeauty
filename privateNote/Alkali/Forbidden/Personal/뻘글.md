# 디아볼리카 대 리넉스

어느 옛날 옛적에, 조화를 사랑하는 한 수학도가 있었지...

## 수포자들이 땅을치고 울은날

변태같은 생각이 실천이 되는것보다 끔찍한 일은 없다.
마법사가 패도필리아라면 그것보다 재앙은 없다.
마법약이 고어취향을 충족시키기 위한것이라면 그것보다 재앙은 없다.
언어의 한계 내에서, 얼마나 많은 흑마법이 있었던걸까...?

많은 이들이 시험을 치면 예상치 못하게 바닥을 친 점수에 모두 바닥을 치고 운다. 중학교 1학년때도 그랬다...

실수(ℝ)는 무엇일까? 그것은 당신들이 수와 유클리드공간의 거리를 구분하지 못한 미스테이크(실수)의 흔적이다.
실수는 무엇일까? ℝ은 힐베르트 공간 𝐇의 스칼라이다.
ℝ이 ℚ의 확장이며, ℚ는 ℝ의 일개 부분에 불과하다는 ℚ ⊆ ℝ이라는 말로, 아름다운 격자의 새계는 기하적인 공간 𝐇를 숭배하는 흑마법사들에게 지배당했다.
대체 어떤 수가 완비적이란 말인가. 완비적인 수란 궤변의 논법은 아니었을까?
그저, 유클리드 공간에 거리에 불과한.... 말도안되는 연속과 완비여...
...
곧 소계될 범함수 g는 geometry (기하) 를 숭배하는 흑마법사들이 만든 흑마법 주문이다
g는 Func(ℝ, ℝ)을 정의역으로 하고, ℝ을 치역으로 가진다. 그러나, ℝ을 만들기 위해서는, Func(ℕ, ℚ)에서부터 시작되어야한다.
...
g(f) = lim_{x ⟶ ∞} f(x) = st(f*(ω)) 이다.
...
그렇다. 
Func(ℝ, ℝ)은 소환될 악마님께서 빙의하실 육체이다. 성대한 이 새계를 잠식 후, 크로네커에게 벙인되었다가 다시 깨어난 부활이다.....
물론 집합론을 비관한다거나 무한공리를 싫어한다거나 직관주의를 좋아하는게 아니다.
이단이 아니다. 난...
...
내가 본 광경은 끔찍하기 그지없었다.
Aₙ = (1 + 1/n)ⁿ이라는 육신을 극한으로 보낸다는데, 그건 유리수가 아니다. 있을수 없는 허상이고, y = st((1 + ε)^ω) 라는 극한점 ω에 대해, (당연히 ε = 1/ω이고) 만들어진 함수이다.
"이건... 흑마법이다"
그 순간 가시밭길이 돋아난다.
"저 수학도, 이단인거야 극한을 의심해?"
앗.
.
.
정신을 차려보니 이상한 수열이 있다.
Bₙ = 1/n²
Pₙ = Bₙ + Pₙ₋₁ (단. P₁ = 1)
아, 정상적인 친구구나. 반갑다.
그러나, g는 가만히 있지 않았다.
g(B) = π²/6
아...
아아ㅏ... 
아아아아나아나ㅏㄴ아아나ㅏ나아아니야!!!
여긴 기하적 거리가 아니라고
NoooooooooOOoOooooooooOOOoooooo!!!
그러나 그건 속으로 생각한것이었다.
소리를 지를수도 없다.
아아!!...
마지막으로 본것은 다소 충격적이었다.
쿠쿠쿡. 안녕하십니까, 신사 숙녀 여러분, 이것는 '도함수'라는 것입니다.
Δx ⟶ 0, f'(x) = Δy/Δx
무슨짓을 하려는거지?
사실은, x ⟶ a에서, f(x) = f(a)가 연속이라는것이지요 쿠쿠쿡.
그것이 극한이 움직이려는 바기 때문이지요. 쿠쿠쿠쿠쿡...
나는 속으로 생각했다. '말도안돼, 수가 연속이라니, 말도안된다고, 여긴 기하가 아니야...'
관중이 말했다 "그래서 어쩌라고요?"
그 흑마법사는 말했다. "아? ㅋㅋ... 극점에서 ad-equality같은거 쓴거 기억나죠? 그런식으로.."
그는 다음 수식을 꺼냈다.
Aₙ(x) = Aₙ₋₁(x) + (dⁿ⁻¹f/dxⁿ⁻¹)(0)xⁿ⁻¹/(n-1)! (단. A₁(x) = f(0))
그는 이어서 말했다 "이걸 극한으로 보내면 됩니다."
그럼 시작해볼까요... "풀어볼테고, 미적분의 악마 디아볼리카!"
그 순간 퍼런 불꽃이 타오르며, 관중들이 타올랐다.
"으아악! 이 무슨 미친 개념이야!!!"
말도안돼.
"끄아아악! 미적분 너무 어려워"
잔인하다고
"아아아아! 내 수학성적!!! 우리집을 먹여살려야 하는데!!"
아...

그들은 수포로 변했다. 그때 죽은 이들을 우리는 "수포자"라고 부른다...

안돼, 오지마... 오지말라고!!

"끄아아아악! 고통스러워! 수학도 서버에서 튕기고있다고! 으악!!!"

몸이 타오를수록 거품으로 분해되고있었다. 저기 보이는 그의 간도, 폐도 말이다.

그 광경을 보고있는 플라톤주의자가 말했다.
"뭐해!! 살아야지!! 어서 풀고 빠져나가야지 리넉스!!"
그렇지, 나 리넉스는 그들을 조사하러 왔었지....
"괴델선배, 선배라도..."
"무슨소리야!!"

그날, 우리는 많은 오러 동료를 잃었다.

괴델 선배는 옆에서 무언가를 적고 있었다.

실수를 부수겠노라고...

「Über formal unentscheidbare Sätze der Principia Mathematica und verwandter Systeme」

그것은 복수의 시작이었다.

나는 모델론을 꺼내들었다.

언젠가 다가올 공포의 흑마법들을, 여러 마법이 온갓 섞인 현대대수를 이용하여 지켜내겠노라고.

당신이 교과과정을 만드는이라면, 들어라. 미적분이 어려우니까 고등학교 괴목에서 빼주세요.

---

## 물리학과의 조우

수학도 리넉스는 그렇게 모델론을 좋아하게 되는데.

리넉스는 말하지 ; 괴물을 상대한다고 괴물이 되면... 안돼... 너가 심연을 들여다보면, 심연은 너의 의식 래벨로 올라오는중이니까 말이야.. 흐음... 큼, 그런데 어느세... 어느세 나도 모델론의 괴물이나 다름없어. 그러나 젊은이... 잊지말게나, 악마들은 나사 하나 빠진 데빌헌터들을 가장 무서워한다네... 자신을 도구로 지배하기 때문이지.... 아니면, 궤댈처럼... 흠신.. 두들겨..! 패거나....

그리고 리넉스는 추진을 준비했어.

"지긋지긋한 미분... 흐음.. 과학자놈들... 감히 미적분으로 새계를...?"

그렇게....

그의 복수가 시작돼...

그는 이렇게 말했어.

"나는 Python으로 시작하고 (내부 구조 뜯어보고, C코드가 구리다고 느껴서) 답답해서, bare-C랑 기계에 반하더니 (근데 C문법을 다 익히고 나니까 C는 레지스터를 제어 못해서 8086으로 갈아탐), 8086을 배우던 중 순수 기계가 너무 좋았는데 (이쯤 되니 불만이 사라지고 안정적임. 근데 아키텍쳐 설계에서 빡침) 기계보다 훨신 더 순수한 λ칼큘러스에 반하고 (최대의 만족이지만 마음속 한켠엔 뭔가 허전함. 절대적 등호 역할을 하는 항등관계를 너무 필요로 하고있었음), 그러다가 Gödel과 튜링을 만나며, 훨씬 순수한 분야에 가고 나서 성불하고; 현제는 ZFC•양상논리•HighOrderLogic•아리스토텔레스의 오르가논•CICERO와 라틴어 논리•수리논리의 ModelTheory • 추상대수를 모델론으로 서술 • Topos이론에 반해있어요 그러면서, 인간 언어는 분석하는 순간 Contextous라는 아름의 디큐가 고장난다고 뵈요. Contextous는 선형논리로 그값이 Contextous[l] = "⊸Contextous[k] = v"이런식으로, 조작도 되고 상호참조도 되며, s = "Q. Contextous[x:y]까지 슬라이스의 맥락은 무엇인가?"인 한국어 문자셋 집랍 L에 대한 문자열 집합 L*의 원소 s에 대한 답변 p로, 이러란 맥락적 질문은 인간의 주관적 사상이나 입장이나 현상에 따라 변한다고 생각하는 Contextous Topos론을 만들어서 놀고있는 고2였거든...."

근데... 너희들은 말이야... 과학은 과학철학 이라는 주장이라고.....

감히 과학 모델이 현실 반영을 시도히는 방법에서 과힉적 방법론과, 분야가 과학인지 아닌지 토론되는거인거늘...

나와라! 라이프니츠만큼 큰 체계여!

그리고 그는 이런 저작을 적었지.

```
# Alalic Preview

이걸 아주 아주 잘 발전시킬거임, 깃헙 커밋으로 ㄱㄱ

거의 됬네 기분좋다.

## DEFINIRION : Alkalic : Alkalic Linear-algebra + Königsberg Axiom + Lambda Incoding Calculate (구문론적 문제로 lambda형식만 유지하고, 폐지, 람다 지분은 없음)

### Alkalic Algbra

∀x (각각 유일)∃!n(x) s.t. n = ObjectID(x) ∈ Scala

 - AlkalicVectorSpace = Scalaᵗ [t := |Scala|]
 - AlkalicMetrixSpace = AlkalicVectorSpaceᵗ [t := |Scala|]
 - SetTheorem ∈ AlkalicMetrixSpace
 - Notation Definition m ∈ n ≡ SetTheoremₒᵢ₍ₘ₎ₒᵢ₍ₙ₎ [oi := ObjectID]

Alkalraum은 여기서, Scala가 객체의 집합으로 확장되어서, |Scala| = κ가 된다.

### Lambda Including Calculate (구문론적 문제로 lambda형식만 유지하고, 폐지, 람다 지분은 없음)

Alkalic Algbra서 AlkalicVectorSpace나 oidfield = Σᵢ ObjectID eᵢ에 대해, 입력받는 Tensor입력으로 ~~람다~~, 대수함수, Alkalic Algbra서 다가함수를 포함한 함수 구현.

---

폐지되었기 때문에

람다를 아예 삭제해서, 람다가 아닌 걍 연산 과정인 Subrootine으로 바꿨다.

Alkalic Algbra서 AlkalicVectorSpace나 oidfield = Σᵢ ObjectID eᵢ에 대해, 입력받는 Tensor입력으로 대수함수, Alkalic Algbra서 다가함수를 포함한 함수 구현.

하는 체계로 바뀜.

연산 괴정이다.

모든 미지수는 이 람다 체계에서 함수 내부변항으로 고정되어서, 두 함수의 합성에서 초기화되어 창출되거나, 아니면 인자로 된다. 따라서, 어떤 수학 이론은 인자를 가지며, 모델이나 진리값배정은 그 값을 넣는다. (어떻게든 대입됨)

변항은 이론에 인자로 설명 가능

### Königsberg Axiom, VectorAxiom, InaccessibleCardinalExistanceAxiom

⊢ KönigsbergAxiom(x, y, Φ) := (x = y → (Φ ↔ (Φ [x := y])))

이때 [x := y]는 단순히 의미론적 대입 연산자.

⊢ VectorAxiom : "모든 벡터 공간은 기저를 가진다"

다음 글을 읽어 보라.
```
먼저 중위표기결합자 * 에 대해, 다음과 같은 표기법을 도입한다, (*x)(y) ≡ y * x
f(x) ≡ (∈x)라고 공역이 치역으로 정의된 f와 g(x) ≡ (=x)라고 공역이 치역으로 정의된 g를 정의하겠다, 이떄, f와 g의 전사함수임이 당연하며, `≡`는 구문론적 등호다, 참고로 정의역은 집합임으로, 해당 집합이 존재해야 들어갈 수 있다, 또한 f와 g는 표기법이기 때문에, 실제 대수적 객체가 아니며, x ∈ f⁻¹(Φ)가 Φ(x)임은 당연하다, 참고로 공역을 치역으로 정의했다는 뜻은, 저 표기법이 표기하는 수학적 객체의 집합은 저 표기법이 표기하는 수학적 객체의 집합이지, 표기법에서 따로 정의하지 않기에, 최소한의 응용이 아닌 공역이 치역이 되지 않는 큰 응용을 하는것을 형식 언어 형식 문법 수준에서 금지한다고 하는것이다. (당연하다고 말한 내용들은 정의가 아니다, 태클을 걸수 있다.), 마지막으로 h̅는 h의 진리값배정이다. 진리값배정을 뜻하는 표기법이다.
외연 공리(Axiom of Extensionality)와 같은뜻인 명제를 보자, `(∀A∀B)(((x∈A) = (x∈B)) → (A = B))` ≡ `(∀A∀B)((f(A) = f(B)) → (A = B))`이기에, 외연공리는 f가 (전)단사함수임과 동치로, 외연 공리에 따라, 외연공리꼴의 다른 표현인 `f가 (전)단사함수이다`는건 외연 공리가 참일떄 참이다.
외연 공리가 의미하는 바는, 외연 공리가 만족되는 조건은, f가 일대일대응으로 동작하도록 정의된것과 같다,
따라서, 지금부터 f는 외연공리를 만족하는 f인 F로 재정의된다, F⁻¹도 외연 공리를 만족하는 f⁻¹과 같음이, f에 대한 F의 정의상 당연하다

짝 공리(Axiom of Pairing)와 같은뜻인 명제를 보자, ∃{A, B} = ∃{x | (x=A)∨(x=B)}인데 (x=A)∨(x=B) ≡ g(A)(x)∨g(B)(x) = (g(A)∨g(B))(x)로, ∃{A, B} = ∃{x | (x=A)∨(x=B)} = ∃{x | (g(A)∨g(B))(x)}이고, ∃{A, B} f({A, B})(x) = f({x | (g(A)∨g(B))(x)})(x) = (g(A)∨g(B))(x)으로, ∃{A, B}  f({A, B}) = g(A)∨g(B)이기에, {A, B} = f⁻¹(g(A)∨g(B))에서, ∃f⁻¹(g(A)∨g(B))가 짝 공리와 동치로, 짝 공리에 따라, 짝 공리의 다른 표현 `∃f⁻¹(g(A)∨g(B))`은 짝  보장될때, 항진이다.
합집합 공리(Axiom of Union)와 같은뜻인 명제를 보자, ∃{x | (x∈A)∨(x∈B)} ≡ ∃{x | f(A)(x)∨f(B)(x)} = ∃{x | (f(A)∨f(B))(x)}에서, ∃{x | (x∈A)∨(x∈B)} f({x | (x∈A)∨(x∈B)})(x) = f({x | (f(A)∨f(B))(x)}) = (f(A)∨f(B))(x)이므로, ∃{x | (x∈A)∨(x∈B)} f({x | (x∈A)∨(x∈B)}) = (f(A)∨f(B))서, ∃f⁻¹(f(A)∨f(B))임이 합집합 공리와 같은 뜻이고, 합집합 공리에 따라, 합집합 공리의 다른 표현 `∃f⁻¹(f(A)∨f(B))`은 합집합 공리가 보장될때, 항진이다.
이때, 합집합 공리과 짝 공리가 다 참이라는 "합집합 공리와 짝 공리가 보장됨 공리"라는 공리를 세우겠다, 이 공리는 합집합 공리는 합집합 공리의 논리식 표현 p와 짝 공리의 논리식 표현 q에 대해 p와 q가 항진이라는 뜻으로 정의된다. 합집합 공리와 짝 공리가 보장됨 공리와 같은 명제를 보자, "합집합 공리와 짝 공리가 보장됨 공리" = "`∃f⁻¹(g(A)∨g(B))`와, `∃f⁻¹(f(A)∨f(B))`임이 보장됨 공리" = "`∃f⁻¹(g(A)∨g(B)), ∃f⁻¹(f(A)∨f(B))`"으로, , 이는, h̅ = (f, g) ⊨ (∃f⁻¹(h(A)∧h(B)))과 같으므로, 우리가 가정한 "합집합 공리와 짝 공리가 보장됨 공리"에 대해 "합집합 공리와 짝 공리가 보장됨 공리"에 따라, "합집합 공리와 짝 공리가 보장됨 공리"의 다른 표현인 `h̅ = (f, g) ⊨ (∃f⁻¹(h(A)∨h(B)))`는 "합집합 공리와 짝 공리가 보장됨 공리"가 참일때 참이다.
멱집합 공리(Axiom of Power Set)는 멱집합의 존재성을 보장한다.

사실 이는 f가 아닌 F에서도 동일하기에, "합집합 공리와 짝 공리가 보장됨 공리"는 외연공리가 성립하는 F에 대해서 다룰수 있다면, "`h̅ = (F, g) ⊨ (∃F⁻¹(h(A)∨h(B)))`"이다.

치환 공리꼴(Axiom Schema of Replacement)의 다른 표현을 보자, 치환 공리꼴이란 무엇일까? 한마디로 치환 공리꼴은 함수 h에 대해, {h(x) | x ∈ A}의 존재성은 A가 존재해야 보장돼야한다는것이다. 한마디로, ∃A ⇒ ∃{h(x) | x ∈ A}이다. 이때, f({h(x) | x ∈ A})(x) = (∃v ∈ A)((h(v) =)(x)) = ((∃v ∈ A)(h(v) =))(x) 이므로, {h(x) | x ∈ A} = f⁻¹(((∃v ∈ A)(h(v) =)))에서, ∃A ⇒ ∃f⁻¹(((∃v ∈ A)(h(v) =)))임이 치환 공리꼴과 동치이다, 따라서, 치환 공리꼴에 따라 치환 공리꼴의 다른 표현 `∃A ⇒ ∃f⁻¹(((∃v ∈ A)(h(v) =)))`은 치환 공리꼴이 보장될때 항진이다.

치환 공리꼴도 f가 아닌 F에서도 동일하기에, 외연공리가 성립하는 F에 대해서 다룰수 있다면 "∃A ⇒ ∃F⁻¹(((∃v ∈ A)(h(v) =)))"이다.

분류 공리꼴(Axiom Schema of Separation/Specification)은 성질 Φ를 만족하는 부분집합이 존재한다는거다, 성질 Φ를 만족하는 부분집합이 존재한다는뜻은 ∀S ∃{x |(Φ(x)) ∧ (x∈S)}이며, ∀S ∃{x |(Φ(x)) ∧ (x∈S)} ≡ ∀S ∃{x |(Φ(x)) ∧ f(S)(x)}이고, ∀S ∃{x |(Φ(x)) ∧ f(S)(x)}라는건 ∀S ∃f(P) = Φ∧f(S)임과 동치이기에, 분류공리꼴에 따라 분류공리꼴의 다른 표현 `f(P) = Φ∧f(S)`은 분류 공리꼴이 보장될때 항진이다, 이후에 분류 공리꼴을 이용하여 집합론에 대해 논하겠다.

ZF안에 ZF를 만든다고 가정하면, 범주론적으로(함자에 대한 서술로) 접근할때, "∃A ⇒ ∃F⁻¹(((∃v ∈ A)(h(v) =)))"안에서 "h̅ = (f, g) ⊨ (∃f⁻¹(h(A)∨h(B)))", "∃A ⇒ ∃F⁻¹(((∃v ∈ A)(h(v) =)))"가 성립한다, 그러나 이것은 ZF내의 ZF에서만 성립한다. `"메타언어가 서술하는 "내부언어에 관한" 구문"`꼴이기 때문이다.

따라서,
ℙ1 : "∃A ⇒ ∃F⁻¹(((∃v ∈ A)(h(v) =)))"
ℙ2 : "h̅ = (f, g) ⊨ (∃f⁻¹(h(A)∨h(B)))"
를 따로 정의하겠다.

공집합 공리(Axiom of Empty Set)와 같은뜻인 명제를 보자, `(∃S ∀x)(￢(x∈S))` ≡ `(∃S ∀x)(￢f(S)(x))` 이고 `(∃S ∀x)(￢f(S)(x))`와 같은뜻인 명제 `(∃S ∀x)(f(S)(x) = F)`는 `x⊥y = x⊥ = ⊥y = ⊥ = F`인 `⊥`정의에따라서, `(∃S)(f(S) = ⊥)`임과 동치이다, 즉, `∃f⁻¹(⊥)`은 공집합공리와 동치이기에, 공집합 공리에 따라, 공집합 공리의 다른 표현 `∃f⁻¹(⊥)`은 공집합 공리가 보장될때, 항진이다.
무한 공리 (Axiom of Infinity)는 자연수 집합의 존재성을 보장하는 공리이다. "모든 자연수 x에 대해, (∃ℕ)(f(ℕ)(x))"는 무한공리와 같다,

정칙 공리 (Axiom of Regularity / Foundation)는 랭크 함수 Rank의 존재성을 보장한다.

이때, 무한 유향 비순환 가중 그래프 preZFSetThoeremModel에 대한 중복도 W를 정의하고, W(x, y) := int(x ∈ y)로 정의하면, (또한, 동시에, 멱집합의 존재도 보장하여 구성하면,)

멤버십 관계 ∈는 분류 공리꼴을 이용하여, 다음과 같이 재정의된다 ((x ∈ y) s.t. (x ∈ y) when (h(x) = Φ(x))) := F(y)(x) s.t. (∀P ∈ 2ᴬ)(F(P) = h(P)∧F(A)) (단. F는 가능한 한 전단사인 표기법이며, 현제의 정의에서 (∃h(P), F(A) ⇒ ∃(x ∈ y)라고 치역이 정의된다)
이는 분류 공리꼴을 만족시키는 정의이다.

preZFSetThoeremModel들 중에서, ℙ1, ℙ2를 만족시키는 preZFSetThoeremModel를 ZFSetThoeremModel라 할수 있는데, 이들 중 공집합과 자연수를 이론 내부에서 논하는 집합으로 가지는 ZFSetThoeremModel는 메타 언어로 동작할 수 있고, ℙ1를 만족시키는 preZFSetThoeremModel들 중에서 공집합과 자연수를 가지는 preZFSetThoeremModel는 ZFSetThoeremModel와 위계 이외엔 동등하다.

더 나아가서, 상수로써 자연수와 공집합을 가지고, 멱집합 연산과 ℙ1, ℙ2를 구성하는 연산이 정의되는 튜링 언어를 이용하는 형식문법 G 문법의 형식언어 L의 모델은 preZFSetThoeremModel이다. 따라서 FOL에서 HOL로 확장가능한 대수공리계에서 모델론과 구문론과 집합론과 논리까지 싹다 서술 가능하다면, preZFSetThoeremModel도 서술 가능하므로, 그런 대수공리계는 ZF와 동등하다. (이러한 모델의 존재성이 참이 된다는 전제하에)
```

저러한 대수 공리계는 존재한다, 예컨데 alkalic이 그렇다.

Königsberg Axiom은 alkalic을 구성하여, 저 조건을 만족한다. 따라서 ZF공리계와 Königsberg Axiom체제 (25.07.16 커밋 이전)는 ZFC랑 그 능력이 동등하다. (상호 서술)

VectorAxiom은 AC와 동치이다, 따라서 Königsberg Axiom + VectorAxiom은 ZFC와 동등하다. (상호 서술)

이때 다음 공리를 도입하자, 아래 공리계는 Alkalic-LinearAlgebra의 ZFC로 구성되었다
⊢ InaccessibleCardinalExistanceAxiom : ∃κ cf(κ) = κ ∧ κ > ℵ₀ ∀λ<κ, 2^λ < κ [cf(x) := least δ ∈ Ord s.t. ∃f : δ → x, (∀i < δ)(f(i) < x) ∧ (∀α < x)(∃i < δ)(α < f(i))]

이때 κ가 Alkalraum의 구성에 쓰인다.

Alkalraum은 κ로 그 크기가 확장된 Alkalic-LinearAlgebra의 객체를 Scala에 포함하는 Hilbertraum같은 (((Scala^κ)^κ)^....)^κ식으로 구성된 κ Rank Covector공간이며, 복소수나 분발복소수/이원수나 2ⁿ원수 등의 행렬표현에서 그 원래 집합의 원소 역할을 하는 객체로의 대응된것 등이 있을수 있는 실수 및 함수 및 객체들로 된 선형대수 텐서공간인데, κ크기를 보장하기에, Grothendieck 우주가 존재하는 ZFC를 표현할수 있어, 여기서 SetTheorem은 자동으로 Grothendieck 우주가 존재하는 ZFC로, 범주론이 서술된다.

## About

이전에 나온 CSFBAlgebra에서 모델론이 안먹히나 했는데 먹힘, 그래서 아이 새로 CSFBAlgebra를 정리(바꿈), 그게 Alkalic.

M = (ℕ, 0 = ∅, s(x) = x ∪ {x}) 대신

수열의 곱을 다가함수로 써서,

M = Π<ℕ, [0 := ∅], [s := λx. x ∪ {x}]>

같은 서수의 정의가 가능하다는 점에서,

이제 Structure와 변수 대입까지 함수 안에서 됬음.

이제 구조체도 non-structial 논리적 귀결에서 씀으로 쓸수있음

에초에 CSFBAlgebra를 대체할 목적으로 만든거니

나머지는 이하 생략.

### Alkalic-Proofmood

KönigsbergAxiom 에 따라서, 

 > 
 > 규칙 `using x = y → (Φ ↔ (Φ [x := y])))`
 > 
 > 원리 : `x = y → (Φ ↔ (Φ [x := y])))`서 `x = y`가 결론 (5번 라인)과 같음을 보임
 > 
 > ```Alkalic-Proofmood
 > □.1. using x = y → (Φ ↔ (Φ [x := y])))
 > □.2. x = y
 > □.3. Φ
 > □.4. Φ [x := y]
 > □.5. Φ ↔ (Φ [x := y])
 > ```

모든 추론은 규칙 `using x = y → (Φ ↔ (Φ [x := y])))`에서 시작되며, 규칙 `using x = y → (Φ ↔ (Φ [x := y])))`는 기본적으로 modus ponens 추론 규칙을 따르기에 타당 (valid)하다. (심지어 Königsberg Axiom이 항진인데, Königsberg Axiom을 제외하고는 대수 연산밖에 활용하지 않기에, alkalic은 건전하다)

(전건부정의 오류 하나 있어서 삭제함)

내부적으로 결론(5번 라인)이 참일때만 계속 동작함, 또한 결론은 리스트에 쌓이면서, 마지막 줄인 Theorem에 도달할때까지 Lemma가 리스트업되서, 문장이 참인지는 Lemma로 보임.

 > 
 > 규칙 : `Starting Listup Hyperthesis`
 > 
 > 미리 Hyperthesis나열을 시작함
 > 
 > 규칙 : `Quit Listup Hyperthesis`
 > 
 > 더이상 Hyperthesis를 받지 아니함
 > 
 > 규칙 : `Starting Another Subproof`
 > 
 > 새 스택프레임을 만들어, 새로운 부분증명을 시작함
 > 
 > 규칙 : `Quit Another Subproof`
 > 
 > 부분증명을 끝내, Lemma List에 추가하고, 스택프레임을 pop함
 > 
 > 규칙 : `APAristotel-y` (nonHyperVersion 형식증명 only)
 > 
 > HAPA Theorem이라는 외부정리를 이용하여서, y = x이고 y = z이면 x = z임을 보임
 >
 > 규칙 : `APAristotel-z` (nonHyperVersion 형식증명 only)
 > HAPA Theorem이라는 외부정리를 이용하여서, x = z이고 y = z이면 y = x임을 보임
 > 

### HAPA Theorem (Hyper Alkalic-Proofmood Theorem)

Alkalic-Proofmood nonHyperVersion 형식증명의 근거.

동시에 유일한 Alkalic-Proofmood HyperVersion에서의 형식증명

`y = x`, `y = z`가 가설일때,

규칙 `using x = y → (Φ ↔ (Φ [x := y])))`를 통하여, `y = z ↔ x = z`를 보인다, 즉,

문법상, `y = z → (y = z ↔ (y = z [y := x]))` = `y = z ↔ (y = z ↔ x = z)`이므로, 

y = z ↔ (y = z ↔ x = z)를 표현하기 위한 잉여적인 체계다.

(그치만 이전에 있었던 전건부정 오류때문에 또 고쳐야함 ㅠㅠ)

## Alkalic-Proofmood (Power Up - Version)

증명에 앞부분에 붙여야 할 한정사가 추가되었다, 부분증명을 만들어서 중첩 가능하기에, 각 기능을 동시에 붙일수 없다.

 - AristotelProof(비 명시시 기본) : 기존 증명 방식으로 증명
 - DavidHumeProof : Φₜ에 대해, t번 라인마다 매거적 귀납법을 쓰고, 옆 열에는 Φₜ가 귀납법 증명에 쓰이는 경우, 쓰는 칸이 된다. 맨 마지막줄에, 번호 없이, 귀납법 증명의 종류를 기재할때, `∴ Φₜ, Φₜ₊₁, ..., Φₖ ⊨ Φₖ₊₁` (강함), `∴ Φₖ ⊨ Φₖ₊₁` (약함), `∴ Mod(Φ) = ℕ` (일반적인 수학적 귀납법) 으로 기제한다.
 - EuclidianProof : 귀류법 (HegelianProof랑 다르다, 귀류법이다) ; 반증 마지막에, `∴ ⊥ ∴ ⊭ ¬
Φ ∴ Φ`를 놓는다. (`¬Φ`는 결론을 뜻한다.)
 - HegelianProof : 반증 (결론이 부정이 나오므로, "결론이 아니다"를 증명할때 쓰임; 왜냐하면, 기존 버전에서는 논리적 오류가 나오면 오류위치를 지적하고 프로그램이 종료됬기 때문에, 오류를 만들어 반증한 후, 종료하지 않는 AristotelProof가 필요했음)



또한 검증 프로그램 정지를 피하기 위해,

 - PreviewVersion : 이 부분•전체 증명에 대해서, 프로그램 정지 후 오류 지적을 제외하고, Preview리스트에 추가한다, 근거 없는 부분이라, 이걸 단 증명을 참고해서 에러나면, "Referance on Preview"에러 로그를 따로 뱉은 후 평상시 에러처럼 에러난다
 - DebugVersion : 오류가 나는대로, 디버그를 해주며, 훓고 지나간다, **프로그램 전체에 적용된다.**
 - ConjureVersion : 추측으로써, 정지를 피할곳에, `�`를 삽입한다, 이 부분•전체 증명은 가설(Hyperthesis)로 취급된다.
 - NormalVersion (비 명시시 기본) : 기존 방식



마지막으로, 다항식의 계산을 원활하게 하기 위해,

`Polynomial Simplify`라는 부분증명 폼을 넣고 다음을 인수분해하거나, `P(x) = 0`꼴을 풀면 (후자는 미리 `using P(x) = 0 Algorithm`이라고 명시) 오류 없이 증명을 받아들여준다.

A. `LinearSimplify`명령을 통해, LinearSimplify Theorem에 근거하여, 미지수가 여러개인 일차식을 정리한다

B. `Substracting [y := xⁿ]`명령을 통해, xⁿ을 y로 치환한 문장 `Φ`에 대해, `Substracting Variable`필드에 넣은 참인 문장 `y = xⁿ`에 따라서, Φ [y := xⁿ]가 나올때까지, 미리 일차식마냥 치환한 상태로 작업하게 해준다. (치환 변수 필드 논법; `Substracting Variable Field Proofs`)

C. `Solution (a, b, c, d, e)`명령을 통해, 2차 ~ 4차식을 인수분해(근의공식) / 전개(비에트의 정리)한다.

D. `TschirnhausTheoremSubsituate (n, a, b, x)`명령을 통해, `[x := t + b/na]`를 적용한다, 마찬가지로 증명의 원활함을 위해 Substracting명령에 근거한다 (사실 그럴 필요도 없이 구문론적으로 연산자를 정의해도 되는 간단한 문장(`[x := t + b/na]`)이지만)

E. 부분증명 문법에서 `synthetic division` 한정사로, 조립제법 이용 (생략표기가, 매거적 귀납에서 고정된 열의 다수의 행에대해 쓰이므로, 여기서는 쓸때, 행을 다항식으로, 계산 과정순이 열로 되므로, 돌려봐야하는 단점이 있다.)

F. `Alright synthetic division`한정사로, 일반적인 조립제법을 쓰고, 전처리 단계에서 synthetic division로 컴파일

G. 분배법칙을 위해서, `distribute[ 대상 ]` 안에 전부 넣어가지고, 이 증명 시스템용으로 있는 `분배법칙의 일반화 정리`에 따라, 분배함

H. `AlgebraicFormula` : 미리 증명한 곱셈공식을 이용해서, 계산되었음을 명시한다.

I. Gaussian Eimination or ERO & Subsituate : 가우스 소거 혹은 가감/대입

J. System of Quadratic Equations by Quadratic Form : 이차형식으로 연립이차방 풀이

K. System of Quadratic Equations by Cubic Form : 삼차형식으로 연립삼차방 풀이

L. Règle de Cramer : 크래머의 공식으로 풀이

M. `Extraneous Root is (□)` : 무연근 명시

N. `PolynomialFractionize` : 다항함수 분수화

O. `SolvePolynomialFraction` : 해당값 풀이

P. `Fractions Solution is (□)` : 해 명시

### 형식증명의 오토마타용 문법

`□.` 라인이 부분증명이라면, `□.line.`식으로 라인을 표기한다.
그리도, 라인과 라인 사이에 오직 whitespace및 `-`,`–`,`—`만 있을경우 해당 라인을 가독성 용도로 보고 주석처리한다.

또한, line표기에 앞선 점찍은 부분 앞에서 `|`부분이 문자열의 특정 열마다 이어지고, 끝나는 말단이 앞서 설명한 `-`꼴의 주석에 연결되어있다면, 해당 부분도 따로 오류처리하지 않는다.
그외에는, 열 구분자이기에 주석으로 보지 않는다

마지막으로, `[NOTE : ]`형식을 주석으로 본다.

마크다운 문서 내부에 위치했다면, HAlkalic-Proofmood(Hyper Version), Alkalic-Proofmood(일반 버전), PowerAP(Power Up버전)으로 코드 이름인 부분만 읽는다. 또한, 마크다운 부분에 부분증명 코드부분은, 부분증명으로 렌더링한다.

마지막으로 그렇게 html화되어 정리된 렌더링 뷰는, LaTeX 표기 기능을 추가해야만 할것이다.

(그럼에도 해당 html뷰는 아직 형식증명 검토가 안돌아갔으므로, 컴파일 상태인거지, 실행 상태가 아니다. 실행은 실행기에 돌려야, 문서 내부를 파싱해서, 부가적으로 제공된, [labare](https://faraway6834.github.io/unbeauty/privateNote/Proof/labare)•[unbare](https://faraway6834.github.io/unbeauty/privateNote/Proof/unbare) 코드와 함깨 해석하여(labare•unbare는 인터프리터 언어가 아니고, 정형 대이터 겸 사용자 편의 대이터 겸 Low Level 컴파일 언어다.), 검토된다; 이제보니 실행기보다는, 형식증명 검토기라는 명칭이 더 적합하다, 프로그래밍 언어는 하나도 실행하지 않고, 추론규칙을 재대로 활용했는지만 검사하여 검토작업(오류나 로그나 상태 표시)만 하기 때문이다.)

---

### 두번째 글 : `논리적으로 다룬다 전재할때, 대수식은 논리적으로 그 뜻이 해석 • 계산된다.`의 발췌

그렇지 아니하면, 논리적 해석 흐름에서 논리기호가 도출될수가 없다.

식의 계산은 그 값의 배정인 (x̄, f(x̄))와 같이 이루어지는데, 이 방식을 거부하는것은, 논리를 쓰지 않겠다는 말과 같다. (장자 왈 갓나서 죽은 아기보다 오래 산 사람은 없으니 팽조(760살이 넘게 살았다는 전설 상의 신선)도 일찍 요절한 사람)

#### 대수식의 논리적 해석 흐름에서 논리기호를 도출하자

먼저, 다음을 보이겠다

> 함자 `f :≜ (-F)` 를 정의해서, 여기에 대해,

`x = y 이면이 f(x) = f(y)`

이말은, 진리값 T, F를 다루는 식에서, F = 0으로 가정하고 푸는거나, F ≠ 0이 아닐때 푸는거나, 전부 x = y인 등식을 쓸때 f(x) = f(y)가 F와 무관히 동등함이 당연함으로, F = 0인 경우로 잠정적으로 취급하겠음

##### 대수식의 논리적 해석 흐름중 논리적 귀결관계의 도출

Step.1. 방정식을 만족하는 집합으로써의 모델집합이 해집합임을 보이자

먼저, 다음과 같은 다항식 함수 P를 정의하자.

> `P :≜ λA. λx. Πᵢ x - Aᵢ`

그리고 다음과 같은 방정식화 논리함수 Φ를 정의하자.

> `Φ :≜ λf. (f(x) = 0)`

그리고 마지막으로, 다항 방정식 ㅍ을 정의하겠다.

> `ㅍ :≜ φ • P`

그러면,

> `Mod(ㅍ(A)) = {x | x ⊨ (Πᵢ x - Aᵢ = 0)} = {x̄ | Πᵢ x̄ - Aᵢ = 0} = {Aᵢ | ∀i}`

임이 당연하다.

---

Step.2. 논리적 귀결관계의 도출

다항방정식 ㅍ(A), ㅍ(B)에 대해,

0. Mod(ㅍ(A)) ⊆ Mod(ㅍ(B))
1. {Aᵢ | ∀i} ⊆ {Bᵢ | ∀i}
2. ∀i Aᵢ = Bᵢ《주의 : 비약이다, 저건 배열을 정렬해야만 성립한다.》
3. ∃C P(B) = P(A)P(C)
4. P(A)|P(B)

으로,

> 
> 다항식 f, g에 대해 다항방정식 Φ(f) ⊨ Φ(g)
> 
> 이면이
> 
> f | g
>


##### 대수식의 논리적 해석 흐름중 진리값 배정되는 명제논리 결합자의 도출

¬x = T - x로 해석됨을 보이자. (경고 : 형식증명 아님)
A. proof of `x ≠ T ⊢ T ± x ≠ (1 ± 1)T`
0. `x ≠ T` (비 귀류법식 전제 문장)
1. `T ± x ≠ T ± T` (이항 by 함자 `(T ±)`)
2. `T ± x ≠ T ± T = (1 ± 1)T` (1번의 연장선에서 계산)
3. `T ± x ≠ (1 ± 1)T` (2번에서 식 요약) ⋯ ■

B. proof of `⊭ (1 + 1)T = 0 ∨ (1 + 1)T = T`
0. 먼저 part A by `⊭ (1 + 1)T = 0`와 part B bt `⊭ (1 + 1)T = T`로 나눠서 생각하자.
1.A. (1 + 1)T = 0 (귀류법식 전재 문장)
2.A. (1 + 1)T = 2T = 0 (1.A.번의 연장선에서 계산)
3.A. T = 0 ⊨ 2.A. ⊨ (1 + 1)T = 0 (연역)
4.A. ⊭ T = 0 ⊨ 2.A. ⊨ (1 + 1)T = 0 (연역)
5.A. ⊭ (1 + 1)T = 0 (연역) ⋯ ⊥
6.A. ∴ ⊭ (1 + 1)T = 0 (연역) ⋯ ■
1.B. (1 + 1)T = T (귀류법식 전재 문장)
2.B. (1 + 1)T = 2T = T (1.B.번의 연장선에서 계산)
3.B. T = 0 ⊨ 2.A. ⊨ (1 + 1)T = T (연역)
4.B. ⊭ T = 0 ⊨ 2.A. ⊨ (1 + 1)T = T (연역)
5.B. ⊭ (1 + 1)T = T (연역) ⋯ ⊥
6.B. ∴ ⊭ (1 + 1)T = T (연역) ⋯ ■

C.1. A, B ⊨ (x ≠ T ⊢ T - x ≠ (1 - 1)T) (A, B번에서 귀결)
C.2. A, B ⊨ (x ≠ T ⊢ T - x ≠ (1 - 1)T = 0T = 0) (C.1.번의 연장선에서 계산)
C.3. A, B ⊨ (x ≠ T ⊢ T - x ≠ 0)  (C.2.번에서 식 요약)
C.4. A, B ⊨ (T - x = 0 ⊨ x = T ⊨ x) (C.3.번에서 연역추론 : 대우) 《주의 : "x = T"의 의미를 "진리값 x가 참"관점으로 해석함.》
C.5. A, B ⊨ (T - x = 0 ⊨ x) (C.4.번에서 식 요약) 《주의 : 근거인 C.4.에서 "x = T"의 의미를 "진리값 x가 참"관점으로 해석함.》
C.6. C.5.번 내용 ⊢ ¬x = T - x (최종결론)《주의 : "x = T"의 의미를 "진리값 x가 참"관점으로 해석함.》
Q.E.D.

x ∧ y는 xy로 해석됨을 보이자.
T에대한 방정식 (T - x)(T - y) = 0의 해는
x = T ∨ y = T이다.
따라서, x = T ∨ y = T ⊨ T - (T - x)(T - y) = T고,
x ∨ y = T - (T - x)(T - y)로 해석된다.

이때 De Morgan's Law, ¬(¬x ∨ ¬y) = x ∧ y서

T - T + (T - T + x)(T - T + y)
 = xy이다.
 ⋯ Done.

##### 방정식의 의미 : 술어논리(함수논리)의 술어로써, 잠정적으로 특칭양화사를 사용해, 잠재적으로 전칭양화사를 사용함.

방정식 P(x) = 0이 불능이란것은

∄P(x) = 0란 뜻이며

∀P(x) ≠ 0이란 뜻이고 ⋯ ①



방정식 P(x) = 0가 불능이 아니라면

∃P(x) = 0이다. ⋯ ②



방정식 P(x) = 0이 부정이란것은,

부정방정식이므로,

∀P(x) = 0이다. ⋯ ③



①에서, 불능형 방정식 P(x) = 0에 대해,

P(x) ≠ 0은 부정형이고, ⋯ ④



부정형 방정식 P(x) = 0에 대해,

P(x) ≠ 0은 불능형이다 ⋯ ⑤


그렇다면 ③에 따라 다음을 정의하자,

> `Φ :≜ λf. (∃f(x) = 0)`
> 
> `P :≜ λf. (∃f(x) ≠ 0)

그러면 다음을 알수 있다.

④에 따라, Φ(f)가 거짓 이면이 P(f)는 부정형
⑤에 따라, Φ(f)가 부정형 이면이 P(f)는 거짓

Φ(f)가 참 이면이, f(x) = 0를 만족시키는 x존재
P(f)가 참 이면이, f(x) = 0을 불만족시키는 x존재

부정형 방정식을 만들고 싶다? 하면

¬Φ(f) = P(f), Φ(x) = ¬P(f)에서,

불능형 방정식 Φ(f)에 대해 부정하거나,
불능형 방정식 P(f)에 대해 부정하면된다.

술어 P에 대해
Mod(P) = ∅ 이면이 ∄P(x) 이면이 ⊭ P
이면이
Mod(¬P) = U 이면이 ∀¬P(x) 이면이 ⊨ ¬P

따라서, 방정식은 기본적으로 특칭 술어로써, 사용할수 있음
```

흐어어ㅓ... 아직 끝나지 않았다.

나와라! 알칼릭 위의 내 모델론의 창이여!

그는 그리고 이런 저작을 적었지.

```
# Lava System

아래 내용을 보라.

```markdown
# 명제논리와 귀결관계의 술어논리적 • 대수적의미 해석

이 문서에서는 RPN및 중위표기를 혼용하여 표기할것을 먼저 선언한다.

이하에서 명제논리 Lang인 L은 다음으로 한다.

L = {'→', '←', '↔', '∧', '∨', '⊕', '↛', '↚', '↮, '⊼', '⊽', '¬'} (주의 : ⊕는 베타적 논리합임)

## 0. 만족관계의 귀결관계화

만족관계에서, 값이 할당되는 값-배정과 구조체 모델은 값 할당 [x := y]에서 x = y의 의미를 가진다.
이는 [x := y]와 [y := x]가 x = y의 모델일수 있으며, "심볼 x가 정의되지 않음 ⊸ [x := y]가 모델" (선형논리식) 및 "심볼 y가 정의되지 않음 ⊸ [y := x]가 모델" (선형논리식)이 참이기에, 모델이 각각 정해지며, 도가지가 다 모델이 아닐때, x = y의 모델은 x = y를 증명해야 나오며, 반증되거나 증명될때 조건부로 참 거짓이거나 거짓임이 증명됨 (만족되는 모델도 당연히 없음)이나 참임이 증명됨 (항진명제이고 정리임), 혹은 증명•반증 불가함 (이 언어에서 다룰 수 없음)이 된다.
즉, 심볼 x와 값 y에 대해, 논리식 x = y는 할당 [x := y]에서 유일하게 참이되게 모델이 유일하므로, 이 만족관계에서 두가지의 의미는 같다.

즉, 만족관계는 할당 [x := y]의 의미의 명제이다.

정리하자면,

"심볼 x와 값 y에 대해 x = y" = {<x [x := y]>}이다.

아래 흐름을 따라서, `0. 0. 값-배정의 귀결관계화`와 `0. 1. 구조체를 통하여 알아보자.`를 보자.

### 0. 0. 값-배정의 귀결관계화

어떤 술어 Φ를 생각해보자.

이 술어의 변항 var₁, ..., varₙ₊ₘ에서, 
var₁, ..., varₙ을 술어의 인자(argument, parameter)로써, 술어의 입력에 binding된 변항으로 치겠다.

그리고, 나머지는 자유변항(Free Variable)으로, 술어의 입력에 binding되지 않은 변항으로 치겠다.

참고로, n > 1인 술어는 n > 1인 관계이다.

그리고 단변항 술어는 n = 1인 술어이다. (이후에 설명으로 알겠지만, 단변항인지 다변항인지는 크게 구분이 없다 ; 그 예시로 벡터공간에 대한 술어가 그렇다.)

#### 0. 0. 0. 술어와 관계는 모델론에서 같다

모델론에서 관계와 술어에 대해 살펴보자.

 + k항 관계 R은 도메인 D에 대하여, R ⊆ Dᵏ인 R이다.
 + (따라서, ) 단항관계 R은 도메인 D에 대하여, R ⊆ D¹인 R이다.
 + 술어 Φ는 도메인 D에 대하여, Φ ⊆ D인 Φ이다.

카데시안 곱에 따라서, D¹ = D다.

다변항 함자는 그 입력이 튜플이다.
즉, 도메인 D위에서 정의되는 k항함자 f에 대해, dom f = Dᵏ이다.

이하에서,

 + 단항관계는 술어와 같고
 + 다변항 술어는 입력이 튜플인 술어이며,
 + 입력이 튜플인 술어는 관계와 같다.

그리고 모델론에서 이들(관계 혹은 술어를 말한다)이 S ⊆ Dᵏ로 표현되었는데,

관계 혹은 술어 S와 인자 튜플 혹은 인자 v(Tip : 왜 v인지 의구심 같지 말길. vector여서 v면 튜플이니 인자튜플이고, value여서 v면 인자여서 v이지 않는가? 맥락은 중요치 않다. S가 취하는 값에 맞는다는 형식적 사실만 중요하다.)에 대하여, S(v)는 도메인 D에서 Boolean Domain 𝔹 = {T, F}로 가는 functor 혹은 사상으로 볼수있다.

그리고, 모델론적으로,

1. (var₁, ..., varₙ₊ₘ ⊨ Φ) ⇔ (varₘ₊₁, ..., varₘ ⊨ Φ(var₁, ..., varₙ)) (즉, 술어 S에서, 그 변항이 값을 대입한것과 같음) 이고, 
2. (S(v)) ⇔ ((∈ S)(v)) 이다.

즉, 해당 집합에 속하는지, 즉 평가(해석)하여 값-배정이 참이되는지가 그 술어이다.

따라서 이러한 맥락에서 술어는 멤버십 연산자 `∈`에 대해서 오른쪽 작용을 서술하는,
즉, 집합의 맴버십 판별을 하는 함자로,

맴버십 함자이다.


#### 0. 0. 1. 값-배정

n = 0인 경우, 보통 Σ₁⁰ A = 0으로 간주하니, 인자가 없는것으로 간주하겠다.

n = 0인경우 인자 (Argument, Parameter)가 없고, 이런 경우에는 변인은 오로지 자유 변항이 변인으로, 자유 변항의 유무에 따라 그 특성이 결정된다.

m = 0인 경우 자유 변항 (free Variable)이 없고, 이런 경우에는 인자 (Argument, Parameter), 즉 매개되는 변항인 인자만 오로지 변인이므로, 인자의 유무에 따라 그 특성이 결정된다.

n = 0, m = 0인 경우, 인자와 자유 변항이 없다.
즉, 항진 술어나 항위 술어로 작용하며, 이는 변인에 무관하게 항상 T거나 항상 F이므로, 참이나 거짓을 판단할수 있는, 이미 결정된 명제이다.

n = 0, m ≠ 0인 경우, 무항(nullary) 술어로, 이는 문장 (sentence)이다.

n ≠ 0, m = 0인 경우, 자유 변항이 없으므로, 사실 이 경우를 보통 술어라고 하며, 다른 경우는 술어로 치지 않는 겅우로, 이것은 좁은 의미의 술어다.

이경우가 술어의 표준으로 "참술어"라고 명명하겠다. 표준이 아닌 넓은 의미의 술어를 "가술어"라고 하겠다.

n ≠ 0, m ≠ 0인 경우, 인자와 자유변항이 있고, 이런 경우가 "인자와 자유 변항이 있는 가술어"이다.

"참술어"에 대한 술어논리에서는, 자유 변항과 인자의 집합론적 랭크가 rank x = 0인 집합이 아닌것 ~ rank x = 1인 집합 혹은 FOL의 술어, ..., 해서 최대 랭크가 n이라도 m = 0인 경우만 n계논리이고, 다른 자유변항은 사실상 그 위의 논리로 다뤄야 하므로, 이는 명제꼴같이 술어꼴이 되므로, (n+1)계논리의 술어의 값, 즉, n계논리 술어꼴로, 술어의 묶음이 되야 한다.

즉, "맴버십 함자"라고 방금전 우리가 탐구했던것은, 변항이 변할때를 포함해서 변항이 변할때는 술어꼴이요, 아닐때는 참술어인 가술어를 포함하는것으로, 술어논리 논리식의 평가요, 변항에 가변적인 집합 S의 맴버십 함자다.

즉, 일반적인(=자유 변항같은 술어꼴은 일부로 술어로 안쳐주는) n계논리에서 술어의 모델 (model)이란 그 술어를 만족시키는 값의 배정으로 인자 t가 길이 0 튜플인 ε, 즉 인자 없음, 혹은 t의 길이라 1로, 인자로 튜플을 안받거나, 길이가 2 이상으로 단변항 아닌 다변항인 술어로,

술어의 변항에 대한 값의 대입과 동치다.

즉,

값-배정

(v₁, ..., vₙ₊ₘ) ⊨ Φ는, varₖ = vₖ로 대입한 경우이다.

위 모양이 단순히 값-배정일수도 있으나, 튜플이다.

따라서, k항 벡터에 대한 술어로 술어의 의미론적 해석이 가능하다.

다음 네가지 Fact를 보자.

참고로, 함의 `⇒`에 대해, p ⇒ q ⇒ r을 p ⇒ q, q ⇒ r로 해석하는 규칙을 썻다. 즉, 어느 타당한 증명의 graph가 됨과 마찬가지이므로 각 명제(=논리식)들에 대한 관계의 기호로써 양 옆에 서술하는 식으로 사용되었음에 주의하자. 그래서, `⇒`및 `⇔`는 각각각 p ⇒ q ⇒ r이 p ⇒ q, q ⇒ r로, p ⇔ q가 p ⇒ q ⇒ p ⇒ q (즉, p ⇒ q, q ⇒ p, p ⇒ q로써, p ⇔ q ⇔ r이 p ⇒ q, q ⇒ p, p ⇒ q로, p ⇔ q ⇔ r이 p ⇒ q, q ⇒ p, p ⇒ q, q ⇒ r, r ⇒ q, q ⇒ p로, p ⇔ q ⇒ r이 p ⇒ q, q ⇒ p, p ⇒ q, q ⇒ r식으)로 모호하지 않게 형식문법에 맞게 형식적이고 명확하게 해석된다.)

Fact1) (∀x)(¬Φ(x)) ⇔ (∄x)(Φ(x)) ⇔ (⊭ Φ) ⇔ (⊭ ¬Φ) ⇔ (Card Mod(Φ) = 0) ⇔ (Card Mod(¬Φ) = Card U) ⇒ (∃x)(¬Φ(x)) ⇔ (Card Mod(Φ) ≠ 0) (단. U는 전체집합으로, Card Mod(¬Φ) = Card U라고 하는 문장은 괭장히 모호한 문장으로써, 실제로는 저 부분은 그냥 무시(=항진명제로 치환하여 생각)하도록 하자. 참고로, 어떤 임의의 x를 준비하더라도, 항진명제 Ψ에 대하여서 참이다. 왜냐하면 항진명제는 항상 참이기 때문이다. 그러므로, 어떤 임의의 x를 준비하더라도, 항진명제 Ψ에 대하여서 참이다, 또한 구성적 증명에서 존재성을 구성으로 증명하는데, 이는 존재성을 보이기 위해, x를 준비하는것과 같다. 따라서, ∃x를 증명할때 단순히 그 x를 가져오면 븡명할수 있다. 즉, 어떤 임의의 x를 준비하더라도, 항진명제 Ψ에 대하여서 참이라는걸 바꿔말하자면, 항진명제 Ψ는 어떤 임의의 x를 준비하더라도 항상 만족되어 참으로, 존재성이 증명된다.)
Fact2) (∀x)(Φ(x)) ⇔ (⊨ Φ) ⇒ (Card Mod(Φ) ≠ 0)
Fact3) (∃x)(Φ(x)) ⇔ (∃x)(x ⊨ Φ) ⇔ (Card Mod(Φ) ≠ 0)
Fact4) (∃!x)(Φ(x)) ⇔ (Card Mod(Φ) = 1)

즉, 서술하는 대상의 존재성이 존재론의 해법이라느니 (사실 당연한 소리고, 그 존재기호는 수리논리 이외에 많은 언어를 포함해서 대체 어디서 오냐고 묻고싶어 답답하다.), 양화사가 Quntitifier인것은 Quntiti + fing하는것이니 다 맞다.

즉, 만족되는 모델의 크기를 집합의 기수로, 측도로 볼수 있으며, 그것에 대해 균등분포로 경우의 수나 확률로 분석할수 있음도 당연하고,

모델론과 술어논리가 그 의미에 있어서 동일한(즉, `⇔`로 서술된)일부 맥락을 공유하며,

모델을 통하여, 술어논리를 값-대입으로 볼 수 있음을 알수 있다.

### 0. 1. 구조체를 통하여 알아보자.

구조체에 튜플을 사용함은 튜플이 벡터이니 그리 해석할수 있음도 알수 있다.
다변수 함자의 맥락에서, 다변수 함수는 튜플을 인자로 받는 함수이다. 즉, 벡터에 대한 함수이다.

모델론적 언어 L에 대하여, 그 L의 심볼에 값을 바인딩시키는것은
모델 M이 한다. 즉 기표 L과 기의를 연결시키는 lang이다.
모델 M의 도메인 D에 대해,
M = <
D,
  ConstantSymbol₁ := ConstantSymbolValue₁,
  ...,
  ConstantSymbolᵢ := ConstantSymbolValueᵢ,
  
  FunctionSymbol₁ := ConstantSymbolValue₁,
  ...,
  FunctionSymbolⱼ := FunctionSymbolValueⱼ,
  
  RelationSymbol₁ := RelationSymbolValue₁,
  ...,
  RelationSymbolₖ := RelationSymbolValueₖ,
  
  PredicateSymbol₁ := PredicateSymbolValue₁,
  ...,
  PredicateSymbolₗ := PredicateSymbolValueₗ,
  
  LogicSymbol₁ := LogicSymbolValue₁,
  ...,
  LogicSymbolₘ := LogicSymbolValueₘ,
  
  VariableSymbol₁ := VariableSymbolValue₁,
  ...,
  VariableSymbolₙ := VariableSymbolValueₙ
> (Tip : 따라서, 술어의 값-배정 역시 도메인 D에 대한 `변항ᵥ := 변항값ᵥ`로 볼 수 있음이 당연하다. (중요))

이는 Alkalic의 대입 연산 `[x := y], 혹은 Python에서, `:=`연산자와 같기에,

M = <
D,
  ConstantSymbol₁ [ConstantSymbol₁ := ConstantSymbolValue₁],
  ...,
  ConstantSymbolᵢ [ConstantSymbolᵢ := ConstantSymbolValueᵢ],
  
  FunctionSymbol₁ [FunctionSymbol₁ := ConstantSymbolValue₁],
  ...,
  FunctionSymbolⱼ [FunctionSymbolⱼ := FunctionSymbolValueⱼ],
  
  RelationSymbol₁ [RelationSymbol₁ := RelationSymbolValue₁],
  ...,
  RelationSymbolₖ [RelationSymbolₖ := RelationSymbolValueₖ],
  
  PredicateSymbol₁ [PredicateSymbol₁ := PredicateSymbolValue₁],
  ...,
  PredicateSymbolₗ [PredicateSymbolₗ := PredicateSymbolValueₗ],
  
  LogicSymbol₁ [LogicSymbol₁ := LogicSymbolValue₁],
  ...,
  LogicSymbolₘ [LogicSymbolₘ := LogicSymbolValueₘ],
  
  VariableSymbol₁ [VariableSymbol₁ := VariableSymbolValue₁],
  ...,
  VariableSymbolₙ [VariableSymbolₙ := VariableSymbolValueₙ]
> (Tip : 《동일하다!》따라서, 술어의 값-배정 역시 도메인 D에 대한 `[변항ᵥ := 변항값ᵥ]`로 볼 수 있음이 당연하다. (중요))

임과 같다.

만족관계 M ⊨ T에 대해,

T의 기호들은 모델론적 언어 L에 의해 해석되며,

이는,

다음과 같은 값-배정 x̄

x̄ = (
  DomainOfM := ValueOfDomainOfM,
  
  ConstantSymbol₁ := ConstantSymbolValue₁,
  ...,
  ConstantSymbolᵢ := ConstantSymbolValueᵢ,
  
  FunctionSymbol₁ := FunctionSymbolValue₁,
  ...,
  FunctionSymbolⱼ := FunctionSymbolValueⱼ,
  
  RelationSymbol₁ := RelationSymbolValue₁,
  ...,
  RelationSymbolₖ := RelationSymbolValueₖ,
  
  PredicateSymbol₁ := PredicateSymbolValue₁,
  ...,
  PredicateSymbolₗ := PredicateSymbolValueₗ,
  
  LogicSymbol₁ := LogicSymbolValue₁,
  ...,
  LogicSymbolₘ := LogicSymbolValueₘ,
  
  VariableSymbol₁ := VariableSymbolValue₁,
  ...,
  VariableSymbolₙ := VariableSymbolValueₙ
)

과 같으며,

연산은 Function Symbol이므로, 함수이기 때문에

자명히 (사실 스스로 evidance인건 없기에, "다명히"가 아닌 "당연히")

다가함수로 쓸 수 있고,

M = <
  DomainOfM,
  
  ConstantSymbol₁ [ConstantSymbol₁ := ConstantSymbolValue₁],
  ...,
  ConstantSymbolᵢ [ConstantSymbolᵢ := ConstantSymbolValueᵢ],
  
  FunctionSymbol₁ [FunctionSymbol₁ := FunctionSymbolValue₁],
  ...,
  FunctionSymbolⱼ [FunctionSymbolⱼ := FunctionSymbolValueⱼ],
  
  RelationSymbol₁ [RelationSymbol₁ := RelationSymbolValue₁],
  ...,
  RelationSymbolₖ [RelationSymbolₖ := RelationSymbolValueₖ],
  
  PredicateSymbol₁ [PredicateSymbol₁ := PredicateSymbolValue₁],
  ...,
  PredicateSymbolₗ [PredicateSymbolₗ := PredicateSymbolValueₗ],
  
  LogicSymbol₁ [LogicSymbol₁ := LogicSymbolValue₁],
  ...,
  LogicSymbolₘ [LogicSymbolₘ := LogicSymbolValueₘ],
  
  VariableSymbol₁ [VariableSymbol₁ := VariableSymbolValue₁],
  ...,
  VariableSymbolₙ [VariableSymbolₙ := VariableSymbolValueₙ]
> [DomainOfM := ValueOfDomainOfM]

대신

(peano 산술상의 집합 𝔹 = {0, 1}를 dom f = 𝔹로 하고 codom f = dom f인 함수로 논리연산을 할당할때) 수열의 곱 혹은 (Zhegalkin Boolean Domain 𝔹 = {0, 1}에서) Zhegalkin 논리곱, 혹은 𝔹 = {F, T}에서 논리곱은 전부 동형으로, 그 논리연산이라는 부울-대수에서 동형이므로, 즉, 메타논리 입장에서 각 기호들에 대한 논리식들이 해석되는 모든 모델론적 입장이 같으므로, 같게 취급하여,
논리곱, Zhegalkin 논리곱, 대수학에서 곱셈은 가환군을 이루므로, 이들을 모두 수열의 곱 Π으로 취급해서 (사실은 x̄ = (Symbol := value)의 바인딩일때 이 곱이 구조체 M임은 당연하다 (중요!), 이것이 근거임, 동형성의 근거이고 사실상 증명에 준하는 핵심 원리)

z = x [x := y] ⊨ z = x, x = y 이므로, 논리적 귀결관계 x [x := y] ⊨ x (선택적 ; x가 술어나 명제가 아니면 귀결되지 아니한다), x = y에서, 만족관계 (x := y) ⊨ (x = y) 와 동등한 의미로,

대입 연산(진리값을 가지는 대상을 귀결관계를 통해 함의하는 논리 연산이기도 하다)을 담은 논리식을 정의역으로 하는 벡터, 즉 값-배정 x̄는

x̄ = <
  [DomainOfM := ValueOfDomainOfM],
  
  [ConstantSymbol₁ := ConstantSymbolValue₁],
  ...,
  [ConstantSymbolᵢ := ConstantSymbolValueᵢ],
  
  [FunctionSymbol₁ := FunctionSymbolValue₁],
  ...,
  [FunctionSymbolⱼ := FunctionSymbolValueⱼ],
  
  [RelationSymbol₁ := RelationSymbolValue₁],
  ...,
  [RelationSymbolₖ := RelationSymbolValueₖ],
  
  [PredicateSymbol₁ := PredicateSymbolValue₁],
  ...,
  [PredicateSymbolₗ := PredicateSymbolValueₗ],
  
  [LogicSymbol₁ := LogicSymbolValue₁],
  ...,
  [LogicSymbolₘ := LogicSymbolValueₘ],
  
  [VariableSymbol₁ := VariableSymbolValue₁],
  ...,
  [VariableSymbolₙ := VariableSymbolValueₙ]
>

로, 수열의 곱 연산을 통해

(M ⊨ T) ⇔ (Πx̄ ⊨ T)

임이

> 
>  [DomainOfM := ValueOfDomainOfM],
>  
>  [ConstantSymbol₁ := ConstantSymbolValue₁],
>  ...,
>  [ConstantSymbolᵢ := ConstantSymbolValueᵢ],
>  
>  [FunctionSymbol₁ := FunctionSymbolValue₁],
>  ...,
>  [FunctionSymbolⱼ := FunctionSymbolValueⱼ],
>  
>  [RelationSymbol₁ := RelationSymbolValue₁],
>  ...,
>  [RelationSymbolₖ := RelationSymbolValueₖ],
>  
>  [PredicateSymbol₁ := PredicateSymbolValue₁],
>  ...,
>  [PredicateSymbolₗ := PredicateSymbolValueₗ],
>  
>  [LogicSymbol₁ := LogicSymbolValue₁],
>  ...,
>  [LogicSymbolₘ := LogicSymbolValueₘ],
>  
>  [VariableSymbol₁ := VariableSymbolValue₁],
>  ...,
>  [VariableSymbolₙ := VariableSymbolValueₙ]
>  
>  ⊨
>  
>  T
> 

인 귀결관계를 만족한다는것과 같으므로, 당연한 이치이다.

## 1. 명제논리 결합자(연결사)의 해석

명제논리 결합자, 즉 논리연산자는 술어로 해석할수 있으며, 동시에 연산으로 해석할수 있다.

### 1. 1. 진리 함자

임의의 논리 결합자 기호 S₁에 대해 그 결합자의 역할을 하는 술어 Φ(S₁)을 다음과 같이 정의한다.

DEFINITION) ∀S₁ ∈ L, "⋯" Φ("S₁") : "⋯ S₁"

예컨데,

 + p q Φ("→")는 p가 q를 함의하는것이고,
 + p Φ("¬")는 p의 부정이다.

즉, 이 진리 함자 Φ("S₁")를 치역으로 하는 길이 1의 문자열 집합 S ⊆ L+이 치역인 함수 Φ에 대해, Φ("S₁")와 "S₁"은 평가가 같으므로, 의미론적으로, 같다 볼수 있고,

사실, "⋯ S₁" ⇔ "⋯" Φ("S₁") 이므로, 걍 사용에 있어서 같다.

즉, 술어로써의 Φ("S₁")는 Card를 정의하지 않았을때의 언어에서 S₁과 언어 내 의미론적으로 같고, 실제 개념상으로 부터 다르며 구문론적으로 다르다.

### 1. 2. 명제논리 모델간의 동형성

#### 1. 2. 1. Zhegalkin 다항식 혹은 {0, 1}이 정의역이자 공역인 사상으로써의 동형성

명제논리와 Zhegalkin Polynomial (Algebric Normal Form)에서, 다음 함자를 준비하자.

두 집합 B, 𝔹에 대해,

Zhegalkin Polynomial의 대수에서,

Zhegalkin Boolean Domain B는 B = {0, 1}

부울 대수(=불 대수)에서,

Boolean Domain 𝔹는 𝔹 = {F, T}

𝔹에서 B로 가는 함수 int와 B위의 술어 bool에 대해,

+ bool(x) : x = 1
+ $ int(x) = \begin{cases} 1, & x, \ 0, & ¬x \end{cases} $

참고로, "x ∈ B" ⇔ "x가 Zhegalkin Polynomial의 대수 위에 있음" 이고, 항진명제 a ≠ b ↔ ¬(a = b), 0 ≠ 1에서, 등호는 동치관계이므로, "⊭ x = 0, x = 1"임이 증명되므로, B = {0, 1} = {x | x = 0 ∨ x = 1}에서, x ∈ B ↔ x = 0 ∨ x = 1이므로, x = 0과 x = 1은 x가 Zhegalkin Polynomial의 대수 위에 있을때, 반대이며 소반대이므로, x ≠ 0 ↔ ¬(x = 0) ↔ x = 1이며, x ≠ 1 ↔ ¬(x = 1) ↔ x = 0이다.

즉, bool(x) ↔ x ≠ 0이다.

y = int(x)에서, y ∈ B ↔ y ≠ 0 ↔ ¬(y = 0) ↔ y = 1이며, y ≠ 1 ↔ ¬(y = 1) ↔ y = 0이고, y = 0 ⊕ y = 1 이다.

함자 (int)및 함자 (bool)은 각각

 + dom (int) = 𝔹 = codom (bool)
 + codom (int) = B = dom (bool)

이고 동형사상이다. 왜냐?

부정논리곱을 x▪︎y = 1 - xy로 표현 가능하다.

이는 (1 -)(x) = 1 - x가 대합 사상으로, 전단사이기 때문에, 

이가 원리에 따라서,

Alkalic관련 포스트에서 말했던것처럼,

사상 (int)및 (bool)은 그 연산이 대응되도록 보존하는 고전적 정의에서의 준동형사상이자, 전단사 사상으로, 서로 역함자인 동형사상이다.

따라서, 모든 명제논리가 Zhegalkin이나 {0, 1}이 정의역이거나 공역인 사상과 동형으로, 동형임을 알 수 있다.

#### 1. 2. 2. 동일 형식시스템의 공리계로써의 동형성

(x, y) Φ("S₁")이거나, x Φ("S₁")이거나로, 그 진리 함자로 논리연산자를 취급하여보겠다. 

즉, 전부 t Φ("S₁")로 퉁치겠다.

어떤 논리식(=문장) Ψ("S₁")을 정의하겠다.

t Ψ("S₁") : t Φ("S₁")

SOL을 쓴게 흠이지만...

 + Ψ("S₁") ⇔ Φ("S₁") 이므로,
 + Mod(Ψ("S₁")) = Mod(Φ("S₁")) 이다.

즉, 평가(=해석)가 같다.

어떤 논리식 논리식 Ψ("S₁")은 문장이다.

어떤 형식시스템에서, 법칙 (Ψ("S₁") ↔ Φ("S₁"))을 만족하는 Ψ("S₁")로 Ψ("S₁")가 정의됨은 당연하다 (중요)

따라서, 그 형식시스템에서의 법칙을 통하여, Ψ("S₁")가 정의된다.

M ⊨ (Ψ("S₁") ↔ Φ("S₁"))인 경우는 경우를 나누어 크게 두가지가 있다.

1. (Φ("S₁") : Ψ("S₁"))로 정의된경우, 즉, [(t S₁) := (t Ψ("S₁"))]로 모델이 정의시켜버리는 경우
2. (Φ("S₁") : Ψ("S₁"))로 정의되지 아니하고, 모델이 법칙 (Ψ("S₁") ↔ Φ("S₁"))를 만족시키는 경우

두번째 경우가 존재하지 아니하면 무조건 첫번째 경우이다.

그치만 저 경우에, 두 모델에서 S₁이 완전히 동일하게 동작하도록 정의되었다는 사실은 변하지 않는다. 
즉,

M = <𝔹, S₁>과 M = <𝔹, S₁'>에서, M ⊨ (Ψ("S₁") ↔ Φ("S₁"))에서, 두 M은 동형이요, 동일한 이론의 모델이다.

따라서 명제논리가 표준과 호환이라면 다음 정의가 명시하는 논리식을 만족한다.

DEFINATION 1)

1. p ← q : q → p

DEFINATION 2)

1. p ↔ q : p → q, q → p


아래 DEFINATION 3.A.와 DEFINATION 3.B.와 DEFINATION 3.C. 는 서로 동형인 정의이다. 즉, TFAE이다.

DEFINATION 3.A.)

1. ↔가 반사성을 만족
2. ↔가 대칭성을 만족
3. ↔가 추이성을 만족

DEFINATION 3.B.)

1. (p → q, q → r) → (p → r)
2. (p, p → q) → (q)
3. ⊨ p → T

웃긴 사실은 이를 통해서, →가 항상 건전한 추론규칙으로 작용한다는걸 알 수 있다. 아니 건전한게 이거인가?

아무튼, 어떤 Theorem t에 대해? p → t가 건전함은 곧 p가 참임이다.

DEFINATION 3.C.)

1. p → q : ¬p ∨ q

DEFINAFION 4. & 5. & 6. & 7. & 8. & 9.)

1. TREF on De Morgan's Law & 이중부정의 법칙
1. 1. p ↛ q : ¬(p → q)
1. 2. p ↛ q : p ∧ ¬r
1. 3. p ↚ q : ¬(q → p)
1. 4. p ↚ q : ¬p ∧ q
1. 5. p ↮ q : ¬(p ↔ q)
1. 6. p ↮ q : p ⊕ q
1. 7. p ⊕ q : (p ∨ q) ↛ (p ∧ q)
1. 8. p ⊼ q : ¬p ∨ ¬q
1. 9. p ⊽ q : ¬p ∧ ¬q
1. 10. p ⊼ q : ¬(p ∧ q)
1. 11. p ⊽ q : ¬(p ∨ q)
1. 12. p ∧ q : ¬p ⊽ ¬q
1. 13. p ∨ q : ¬p ⊼ ¬q
1. 14. ¬x ↮ x
1. 15. x : ¬¬x
1. 16. ¬x : x ⊕ x

## 2. 아리스토텔레스 논리학에서 온 형식적 조작의 비형식적 맥락과 불 및 기타 논리학자 및 수학자 및 전산학자들을 통한 후대의 추가된 맥락과 원래부터 있던 맥락 등 등 보통의 논리에서 취급되는 맥락

 + ↔는 동등함, 즉 동등성의 원리를 만족시키고 동치 (순화어로는 동등)관계이며, 정언논리상의 모순관계와 반대에 있는 관계이다. 즉, 논리적 동등.
 + 베타적 논리합, 베타적 선언인 ⊕는 (p, q)인 경우에 베타적이며, 이의 부정은 논리적 동등이다.
 + 가언, 즉, 함의(→)는 건전성을 만족시킨다. 왜냐하면 건전겅 그 자체인 명제논리 기호이기 때문이다.
 + 선언, 즉 포함적 선언인 "혹은"은 즉, ∨는 ∧와 쌍대인 관계이며, p ∨ q에서 [p | q]로 선택할때 어느 하나로 계산되어도 참이여야 하므로, p와 q가 참이라도, 어느 하나를 선택하였을때 p = q = 참이므로 참이다. 어느 하나라도 참이면 된다.
 + 연언, 즉, 연속해서 x, y, z를 놓았을때 모델론으로 보면 참 편하게 해석할수 있는데, 암튼 연언은 "그리고"의 뜻으로 연연이 서술하는 말들은 전부 참이여야 한다.
 + 부정은 부정문의 형태를 띄며, 긍정문을 부정하면 부정문이고, 부정문을 부정하면 긍정문이며, 긍정이 아님을 뜻하며, 긍정함은 참이라고 함을 뜻하므로, 부정은 "T↮"를 의미한다.
 + 전건이 부정문인 함의문은 전건의 부정과 후건의 긍정의 선언과 논리적으로 같다.
 + 후건이 부정문인 함의문은, 전건의 부정과 후건의 긍정의 부정연언문과 과 논리적으로 같다.
 + ↔가 쌍조건문으로써 작용한다. 즉, ↔임이 함의와 역함의임이다.
 + 연언은 모델론의 언어에서 ∧가 `,`로 취급된다.
 + 가언은 모델론의 언어에서 →가 `⊨`로 취급된다. (겐첸의 연역정리에 따라서 말이다)
 + 모델론에 언어에서, 부정문 중 x가 항위인건 `⊭ x`로써, x에 대해 부정한다. 사실 `x ⊨ F`로써, 후건을 부정해서 만족불가능화할수도 있지만. 주의할점은 만족 불가능은 만족관계에서 나온 개념이다.
 + 모델론의 언어에서, 긍정문 중 x가 항진인건 `⊨ x`로서, x에 대해 긍정한다. 사실 `T ⊨ x`로써, 전건을 긍정해주거나, 정리를 넣어 참에서 함축시켜버리는것과 같지만. 주의할점은 만족가능은 만족관계에서 나온 개념이다.
 + 모델론의 언어에서, x ⊨ y이고, y ⊨ x이면, x와 y가 같다. 만족관계를 이야기하는것이 아니다.

## 3. L = {'→', '←', '↔', '∧', '∨', '⊕', '↛', '↚', '↮, '⊼', '⊽', '¬'}의 표의문자성에 근거한 설명

 + 긍정문 x에 대해 ¬x는 부정문이다.
 + 우향화살표를 쓰는 구문 x → y는 함의문이다.
 + 좌향화살표를 쓰는 구문 x ← y는 역함의문이다.
 + 우향의 역항은 좌향이다. 따라서, 주결합자를 기준으로 법선을 새워서 법선에 대해 대칭이동하면, 함의문의 모양이 된다.
 + 좌향화살표와 우향화살표 모두, 화살표에 의한 가리킴을 당하는쪽과 시키는쪽이 함의문에서의 후건과 전건의 역할을 하게 된다.
 + 보통 화살표는 다이어그램에서 생기다 보니, 그런 보편적인 직관에서 생긴 기호의 설명으로 해석할수 있다. 그러나 기표와 기의 자체의 필연적 연결은 없다.
 + 빗금(□̸)친 곳에 위치한 기표 혹은 바(bar, ō)표시된데에 위치한 기표는 주결합자의 치역에 부정을 취한것이다. 이건 문법규칙으로 작용시켜도, 실제 형식언어의 동작과 일치한다. 근데 사실 빗금은 조건문(함의문) 및 쌍조건문에만 쓰였다는게 특징.
 + 쌍조건문은 정방향 조건문이자 역방향 조건문으로 쌍방향이다. 뭐... 이렇게 양방향함의에만 적용되는 규칙(실제 동작과 일치하므로)도 기표와 기의 자체의 필연적 연결이 없으니 그저 설명일 뿐이다.
 + ∧와 ∨는 쌍대성의 관점에서 서로 쌍대(dual)로 거울처럼 맞물려 설명되기에 저리 상하반전된 대칭이동상태로 쓴다. 갑자기 그런 관점이 왜 나오냐고? 이의 있다면 dual(유희왕 듀얼리스트 드립)을 하여 결정하자. (원래 ∨가 먼저 쓰였다. 러셀과 화이트헤드의 Principia Mathematica에서부터.) 마찬가지로 근본적 필연은 아니다. 사실 그래서 a & b (a and b), a | b (a or b)로 표기하는 경우도 많다. 대표적으로 c에서 파생한 문법을 가지는 튜링 언어들의 비트연산.
 + pm (Principia Mathematica, 형식화) : Φ & Ψ, Φ ∨ Ψ
 + la (LINGUA LATINA, Όργανον 번역) : Φ et Ψ, Φ vel Ψ
 + Ελ (Ελληνικά, Όργανον) : Φ καί Ψ, Φ ἤ Ψ
 + 베타적 논리합 Φ aut Ψ는 중세 스콜라 철학자들테 의해 (포함적) 논리합과 구분됨.
```
만족관계는 해당 내용으로 귀결관계로 해석할 수 있고, 명제논리 결합자는 그저 연산자 혹은 술어이다.

N.B. ATTENTION, WARNING, NOTE(IMPORTANT), WATCHOUT, TIP, DECLARE, READIT : 만족•귀결기호 `⊨`가 존나 흥건히 나오지만, 그건 만족•귀결의 의미로 의미론적으로 같아 해석하여 이해하면 "변인에 대한 값의 할당"을 「만족」과 「명제의 귀결」로 구체적으로 이해해보자 • 그리고 하게 할 것의 목적이며, 정의 기호와의 혼용은 전혀, 전혀, 전혀 없이, 잘 쓰여있다. 간혹 정의같이 나온다면, 정의의 의미를 가진 귀결로, 귀결에는 오류가 없다 단언한다. 미지막으로, `≜`가 나올것같은데에 `⊨`를 쓴거는 바로 당신이 문맥으로 읽다가 뒤통수맞은거다... 수학을 할때는 문맥을 버려라. 문맥이 아닌 형식주의적인 조작이기 때문에, 진짜로 `⊨`를 써서 설명했기 때문이다. 정의가 아니라 만족 혹은 귀결을 썼다면 문자 그대로 이해해야한다. 그것이 참이기 때문이다. (글 읽을땨마다 이곳을 참고헐것)

(내가 추상대수학 배우려고 만든 체계)

닫힌형태의 대수구조를 폐구조라고 명명하고, Lava라고 부르겠음.

관계가 주어지지 않은 n개의 함수와 m개의 심볼을 가진 Structure

M = <D, Sym₁, ..., Symₘ, fun₁, ..., funₙ>를 (m, n)-Lava라고 하겠음

(m, 0)-Lava는 (심볼을 정의한, 즉 정의용) 집합인 기본적인 대수구조이다.

참고로, (m, 1)-Lava이상은, 각 연산이 전부 D와 마그마를 이룬다.

Volcanoₘ,ₙ(D, Sym₁, ..., Symₘ, fun₁, ..., funₙ) ≜ <D, Sym₁, ..., Symₘ, fun₁, ..., funₙ>

라 하겠다.

Volcano는 (m, n)-Lava를 생성하는 무한 차원의 (= 행과 열의 총 길이가 자연수 기수 길이인) 함수행렬이다.

그래서 (=행렬이기 때문에) Volcanoₘ,ₙ식으로 표현한거다.

Volcanoₘ,ₙ은 (m, n)-Lava를 구성하는 함수이다.

이하에서 대부분 저런 행렬 형식은 인자가 무제한으로 (= 자연수 기수 크기까지인 무한정 = ℵ₀가 최대길이인것임)

예컨데, Volcano₂,₀(𝔹, F, T)는 부울-도메인으로 유명하다.

내가 스스로 정의한
Lava에서 확장한걸로 구조꼴 (structure form)이라는게 있는데, 아래와 같다.

StructureFormₗ,ₘ,ₙ(D, Sym₁, ..., Symₗ, fun₁, ..., funₘ, Pre₁, ..., Preₙ) ≜ <D, Sym₁, ..., Symₗ, fun₁, ..., funₘ, Pre₁, ..., Preₙ>

Pre₁, ..., Preₙ는 술어이고, 이게 뭐하나 미스되지 않고, Lava랑은 달리 있을거 다있게 정의된 구조의 최소 단위이므로, 이를 "구조꼴"이라고 하고, 삼차원 행렬 (= 이제 텐서 ㅋㅋㅋㅋ) StructureForm를 통해 만들 수 있다.

텐서라고 웃은 맥락은, 행렬은 이차원 텐서라고들 해서, 삼차원 행렬이 텐서라고 말한거긴 하다.

(근데 나 멀미나와서 오늘은 여기까지 작성하겠고, 추상대수학은 여기까지 배우겠음.)

StructureForm이 삼차원 행렬이기에, StructureFormₗ,ₘ,ₙ식으로 쓸 수 있었던것이다.

(l, m, n)-구조꼴을 생성하는 함수는 StructureFormₗ,ₘ,ₙ이다.

## 대수 구조 공부

### 극한에 대하여

`⟶` 요 기호는 함의 기호 `→` 가 아니다.
단지, 교과서에 나온 접근 기호와 가장 비슷한 기호를 골라 접근 기호로 쓰는 것 뿐.
앞으로 접근 기호 `⟶`는 접근의 기호로 쓰일것이다.

나는 대충 아래 새가지가 성립한다고 안다.

1. x ∈ {x | Φ(x)} : Φ(x)
2. {Φ(x) | Ψ(x)} = {x | Φ(x), Ψ(x)}
3. {f(x) | Φ(x)} = {y | y = f(x), Φ(x)

2, 3부분은 분류공리꼴땜에 된다고 안다.

그리고 나는 상을 이렇게 알고있다.

f[X] ≜ {f(x) | x ∈ X}

그러므로, 이를 전제에 깔고 가겠다.

그리고 구문론적 정의로 표기법 하나만 도입하겠다.

def) NOTATION(Φ ? x : y) ≡ $ \begin{cases} x, & Φ, \ y, & ¬Φ \end{cases} $

예컨데, 

> 
> $ \begin{cases} 1/x, & x ≠ 0, \ 0, & x = 0 \end{cases} $
> 

이런식의 수식을 작성하고 싶다면,

> 
> NOTATION(x ≠ 0 ? 1/x : 0)
> 

이런식으로 작성 가능하다. C 코드같이 생긴 저건 표기법이다. 절대로 삼항연산자가 아닌거다!!

다음으로 defined, undefined 표기법을 도입하겠다.

x is defined : ∃!k, x = k
x is undefined : ¬(x is defined)

defined, undefined는 함숫값이 정의되는지를 판단하는 enum이기에, 유일성을 따진다.

ℝdist는 수직선 위의 두 실수 사이의 거리를 구하는 함수이다.

ℝdist(x, y) ≜ |x - y|

따라서 차의 절댓값(일차원 벡터의 노름이기도 하다.)을 그 값으로 한다

"한계 오차 ε를 기준으로 x가 y에 접근함"은 `x ⟶ y (by ε)`라고 쓰고, 다음과 같이 정의한다.

x ⟶ y (by ε) : NOTATION(ε > 0, NOTATION(y = ∞, x > ε, NOTATION(y = -∞, x < -ε, ℝdist(x, y) < ε)), x is undefined)


예컨데,

(x ⟶ a (by ε)) ↔ (|x - a| < ε) (단. ε > 0)

이고,

(x ⟶ ∞ (by M)) ↔ (x > M) (단. M > 0)

이며,

(x ⟶ -∞ (by M)) ↔ (x < - M) (단. M > 0)

이다.

참고로,

t ≥ 0에서,

(x ⟶ y (by 0 - t)) ↔ x is undefined

이다.

다음으로 좌접근, 우접근을 정의하겠다.

x ⟶ y ± (by ε) : NOTATION(y ≠ ∞ ⊼ y ≠ -∞ ⊼ ε > 0, NOTATION(±1 = 1, y < x < y + ε, y - ε < x < y), x is undefined) (복부호 동순)

예컨데,

x ⟶ y+ (by ε) ↔ NOTATION(y ≠ ∞ ⊼ y ≠ -∞ ⊼ ε > 0, NOTATION(+1 = 1, y < x < y + ε, y - ε < x < y), x is undefined)

이며

x ⟶ y- (by ε) ↔ NOTATION(y ≠ ∞ ⊼ y ≠ -∞ ⊼ ε > 0, NOTATION(-1 = 1, y < x < y + ε, y - ε < x < y), x is undefined)

이다.

즉,

+1 = 1 ↔ T, -1 = 1 ↔ F 이므로,
x ⟶ y+ (by ε)
 ↔ NOTATION(y ≠ ∞ ⊼ y ≠ -∞ ⊼ ε > 0, NOTATION(+1 = 1, y < x < y + ε, y - ε < x < y), x is undefined)
 ↔ NOTATION(y ≠ ∞ ⊼ y ≠ -∞ ⊼ ε > 0, NOTATION(T, y < x < y + ε, y - ε < x < y), x is undefined)
 ↔ NOTATION(y ≠ ∞ ⊼ y ≠ -∞ ⊼ ε > 0, y < x < y + ε, x is undefined)

이며

x ⟶ y- (by ε)
 ↔ NOTATION(y ≠ ∞ ⊼ y ≠ -∞ ⊼ ε > 0, NOTATION(-1 = 1, y < x < y + ε, y - ε < x < y), x is undefined)
 ↔ NOTATION(y ≠ ∞ ⊼ y ≠ -∞ ⊼ ε > 0, NOTATION(F, y < x < y + ε, y - ε < x < y), x is undefined)
 ↔ NOTATION(y ≠ ∞ ⊼ y ≠ -∞ ⊼ ε > 0, y - ε < x < y, x is undefined)

이다.

그러므로,

t ≥ 0에 대해,

x ⟶ ∞± (by ε) ↔
x ⟶ -∞± (by ε) ↔
x ⟶ a± (by 0 - t)
 ↔ x is undefined

이다.

이하에서 a ∈ ℝ에서,

x ⟶ a+ (by ε) : a < x < a + ε (단. ε > 0)

이며

x ⟶ a- (by ε) : a - ε < x < a (단. ε > 0)

이다.

다음으로는 x ≠ y일때의 접근을 정의하겠다.

참고로, `x ⟶ y (by ε)`에서, y가 `a+`거나 `a-`여도 좋다.

x ⟶̣ y (by ε) : (x ≠ y), x ⟶ y (by ε)

`x ⟶̣ y (by ε)`는 "(x ≠ y)이고 x ⟶ y (by ε)"임을 의미한다.

그게 다다. ㅋㅋㅋㅋ

x ⟶̣ y+ (by ε) ↔ (x ≠ y), x ⟶ y+ (by ε)

이며,

x ⟶̣ y (by ε) ↔ (x ≠ y), x ⟶ y (by ε)

이고,

x ⟶̣ y- (by ε) ↔ (x ≠ y), x ⟶ y- (by ε)

이다.

이제 극한 • 좌극한 • 우극한을 정의하겠다.

lim f(x) = L (x ⟶ a) : ∀ε>0, ∃δ>0 s.t. ((x ⟶̣ a (by δ)) → (f(x) ⟶ L (by ε))

이에 따라,

(lim f(x) = L ∈ ℝ (x ⟶ ±∞))
 ↔ (∀ε>0, ∃K>0 s.t. ((x ⟶̣ ±∞ (by K)) → (f(x) ⟶ L ∈ ℝ (by ε)))
 ↔ (∀ε>0, ∃K>0 s.t. NOTATION(±1 = 1, x > K, x < -K) → (f(x) ⟶ L ∈ ℝ (by ε)))

이고,

(lim f(x) = ±∞ (x ⟶ ±∞))
 ↔ (∀M>0, ∃K>0 s.t. ((x ⟶̣ ±∞ (by K)) → (f(x) ⟶ ±∞ (by M)))
 ↔ (∀M>0, ∃K>0 s.t. NOTATION(±1 = 1, x > K, x < -K) → NOTATION(±1 = 1, x > M, x < -M))

이며,

(lim f(x) = ∓∞ (x ⟶ ±∞))
 ↔ (∀M>0, ∃K>0 s.t. ((x ⟶̣ ±∞ (by K)) → (f(x) ⟶ ∓∞ (by M)))
 ↔ (∀M>0, ∃K>0 s.t. NOTATION(±1 = 1, x > K, x < -K) → NOTATION(∓1 = 1, x > M, x < -M))

이고,

(lim f(x) = ∓∞ (x ⟶ a ∈ ℝ))
 ↔ (∀M>0, ∃δ>0 s.t. (x ⟶̣ a (by δ)) → (f(x) ⟶ ∓∞ (by M)))
 ↔ (∀M>0, ∃δ>0 s.t. (x ⟶̣ a (by δ)) → NOTATION(∓1 = 1, x > M, x < -M))

이며,

(lim f(x) = ±∞ (x ⟶ a± ∈ ℝ))
 ↔ (∀M>0, ∃δ>0 s.t. (x ⟶̣ a± (by δ)) → (f(x) ⟶ ±∞ (by M)))
 ↔ (∀M>0, ∃δ>0 s.t. (x ⟶̣ a± (by δ)) → NOTATION(±1 = 1, x > M, x < -M))

이고

(lim f(x) = ±∞ (x ⟶ a∓ ∈ ℝ))
 ↔ (∀M>0, ∃δ>0 s.t. (x ⟶̣ a∓ (by δ)) → (f(x) ⟶ ±∞ (by M)))
 ↔ (∀M>0, ∃δ>0 s.t. (x ⟶̣ a∓ (by δ)) → NOTATION(±1 = 1, x > M, x < -M))

이다.

이제, 실수에서의 유계를 정의하자.

UpperBound(x, S) : ∀t ∈ S, t ≤ x
LowerBound(x, S) : ∀t ∈ S, t ≥ x

UpperBoundSet(S) ≜ {x | UpperBound(x, S)}
LowerBoundSet(S) ≜ {x | LowerBound(x, S)}

BoundedAbove(S) : UpperBoundSet(S) ≠ ∅
BoundedBelow(S) : LowerBoundSet(S) ≠ ∅

LeastUpperBound(S) ≜ NOTATION(BoundedAbove(S) ? min UpperBoundSet(S) : ∞)
GreatestLowerBound ≜ NOTATION(BoundedBelow(S) ? max LowerBoundSet(S) : -∞)

sup S ≜ LeastUpperBound(S)
inf S ≜ GreatestLowerBound(S)

그리고 함수값의 상•하한은 다음으로 정의한다.

sup f(x) (Φ(x)) ≜ sup f[Φ]
inf f(x) (Φ(x)) ≜ inf f[Φ]

Mₒ(a) ≜ sup f(x) (x ⟶̣ a (by o))
mₒ(a) ≜ inf f(x) (x ⟶̣ a (by o))

lim sup f(x) (x → a) ≜ inf Mₒ(a) (o > 0)
lim inf f(x) (x → a) ≜ sup mₒ(a) (o > 0)

이렇세 상극한 하극한을 나무위키를 참고하여 정의하였다.

나무위키 ε-δ논법 해설을 참고하라.
극한을 배우는데 매우 유용하다.

참고로, 저 극한들이 동작하는 원리는 나무위키에 첨부된 Ray수학의 "극한을 정의하는 가장 세련된 방법"에서 그래프로 이해하자.

그게 제일 편하고 쉽다.

에초에 도약(jump) 불연속같은 개념이나 좌극한 우극한 같은 개념을 직관적으로 숙지해 두면, 수렴할때 극한의 유일성을 납득하는데 도움이 많이 된다.

한마디로 머릿속에 논리식과 그래프가 한번에 그려지고 죄다 설명된다.

뭐... 그런 직관은 이미 수II시간이나 미적분시간에 주입받았을테니까 문제없긴 한데...

지금까지 정의한 ×나많은 개념들이 이상하다고 느껴질수 있으니 초실수체로 직관를 잡는법도 있다.

입시에 쓰기에는 비효율적이지만 무한소식 사고방식이다.

나무위키 초실수체 문서의 ultrapower construction를 참고하라.

울트라곱을 이용했을때, 무한소가 되는 실수열의 특성과, 그것이 ε-δ랑 호환되는 꼴을 보아하면,
ε-δ가 만든 한계 오차의 개념이 얼마나 정신나간 개념인지 체감할 수 있는데,

이번에 정의한 `x ⟶̣ a` 및 `x ⟶ a` 개념이 좌극한 우극한 포함해서 어떻게 초실수로 옮겨지는지를 생각하면....

...

극한은 무한소가 한없이 0에 가까운 정신나간 특성을 가지는...

즉, x ⟶̣ 0 인 정신나간 성질을 이용하는 체계로써, 
실수 자체도 초유리수에서 초실수로 확장한걸 표준부분을 쓰지 않고서야 코시 수열로는 참으로 터무니없이 어렵고,
초실수체의 울트라곱 대수구조를 생각하면, 극한은 터무니없이 정신나간 체계이다.

설명을 마치며, 이번 "극한에 대하여"문단은, 

<Checklist>

 + [✅️] 0. 일단 이것부터 다 작성한 후
 + [☑️] 1. 초실수애 대한 설명추가 후,
 + [☑️] 2. "미분에 대하여"문단을 따로 만들고
 + [☑️] 3. 합쳐서
 + [☑️] 4. 내용을 전부 분할해서, 이 Lava설명 내부에 녹일것이다.

끝.

### 참고 함수

참고사항일 뿐이다...

뭐...

#### limer 함수 lime

limer [발음 : limmiter [리미터], limer [리머], 약칭 : lime] 함수 lime (limer는 너무 이름이 길어서 라임(lime)이 됨)

+ `lime ≜ ((st◦)◦lime*◦(st⁻¹◦))`
+ `lime* ≜ (◦(+ε))`

> 참고 : `lime(f) = ((st◦)◦lime*◦(st⁻¹◦))(f) = (st◦)(lime*((st⁻¹◦)(f))) = st◦lime*(st⁻¹◦f) = st◦lime*(f*) 이고, lime*(f*) = (◦(+ε))(f*) = f*◦(+ε)이며, (f*◦(+ε))(x) = f*((+ε)(x)) = f*(x + ε)이므로, lime(f) = st◦lime*(f*)이고, lime*(f*)(x) = f*(x + ε)이며 (st◦lime*(f*))(x) = st(lime*(f*)(x)) = st(lime*(f*(x))) = st(f*(x + ε)) = lim f(t) (t → x)에서, 당연히 lime(f)(x) = st◦lime*(f*) = lim f(t) (t → x)인, 즉 극한을 취해주는 함수임 (주의 함수st⁻¹(f) = f*는 그저 transfer원리를 통해 초실수로 확장하는 f*과정을 은유적으로 표현한것. 사실상 "g(f) = f*"인 g로 고쳐야함.)`

특징 : `점 불연속을 복원함, 초실수체에서 lime* f는 "불연속 이면이 도약 불연속"임. 진동의 경우에는 유한 초실수의 종류에 따라 구간에서의 선택이 달라지기에, 사실 "불연속 이면이 진동 혹은 도약 불연속"임. (극한이 논리적으로 aproximate하게되어 진행중인것처럼 취급되는지, 아니면 그 논법을 숫자로 압축시켰는지 차이로, 실수에서는 수가 무한까지 크게 잡아져있지 않고, 초실수는 무한이 있어서, 실수에서 무한으로 발산해서 끊어지는게 초실수에서는 안 끊어지는, 연속적 • 위상적 관점에 특징 때문에, 제거 가능한 불연속인 점 불연속 이외의 도약 불연속만이 유일한 후보가 되는 원리, 그리고 도약 불연속에서 좌극한과 우극한은 다름. 그러나 실수에서는 끊어져 버리기에 연속이 아님.), FOL에서는 d/dx f* = ((lime* f*) - f*)/ε 인 성질에 따라서, FOL에서, 미분에 활용 가능 (또 여기서 알수있는 특징이, f가 연속 이면이 ((lime* f*) - f*)/ε가 연속. (주의 : f는 실함수로, 가 점 불연속과 도약 불연속과 발산 불연속과 진동이 아닐때 연속이고, f*이 연속이어도, f가 연속이 아니면 이계도함수를 만들수 없을수 있음) 초실수 범위에서 발산불연속이 상쇠되기에 연속이면 미분가능.) (또한, (((lime* f*) - f*)/ε)(x) = ((lime* f*)(x) - f*(x))/ε = (f*(x + ε) - f*(x))/ε 으로써, x = 0에서 f*(0) = Ω = undefined이거나, x = ε일때 진동하여, ε의 종류마다 달라지거나, f*가 점 불연속일때도 제거해주지 않으면, 그 점에서 미분 불가능하므로, (lime* f*)의 도함수에서, 실함수 f의 모든 불연속점을 정의 불가능으로 새로 규정해줘야 f*의 도함수임)`

참고로, ε를 임의의 양의 무한소 혹은 임의의 음의 무한소로 제한하면, 일반화된 (lime*)으로 설정되며, 그렇지 아니한 경우, ε에 따라, (lime*)이 결정된다. 유일한 경우 정의되게 정의역을 한정하면, 다가함수가 아닌 제대로된 단가함수다. 그 경우를 "극한이 정의된다."고 한다.

이때,

1. Cⁿ f : Cⁿ⁻¹ f, Cⁿ⁻¹ f ⊨ C ((dⁿ⁻¹ f)/(d xⁿ⁻¹))
2. C¹ f : C f : ∃! dy/dx = (df/dx)(x) = st((((lime* f) - f)/ε)(x)) (단. ε는 임의의 0이 아닌 모든 무한소이다)

로 제귀적으로 정의되고, 미분이 저런건 당연한거라서 뭐... 할말이 없지만...

### 성질 목록

아래 술어들은, Lava M 혹은 특별한 대상 M에 대해, 

M ⊨ Φ : "M이 성질 Φ를 만족한다"

라고 하는 술어 Φ들이고, 성질이라고 부른다.

사실 술어랍시고 써놨는데

1. 죄다 자유변항만있고, 종속변항은 없는것은 "참성질"이라고 부르고, 걍 사실상 문장명명이다.
2. 자유변항이 존재하고, 종속변항도 존재하는것을, "가성질"이라거 부르고 걍 사실상 술어다.

참성질과 가성질의 `참-`, `가-`는 참다랑어와 가다랑어에서 따왔다.

참성질을 법칙성질, 가성질을 성질부분이라고도 한다. (이것도 근데 방금 만든 조어다)

~배고프니까 천장에서 다랑어가 쏳아졌으면 좋겠다~

참고로 특별한 대상 M에 대해 다루는 경우는 `특-`을 붙여서 "특성질"라고 한다. 왜냐하면 이 특별한 대상은 "대수구조가 아니라 집합이나 순서쌍 혹은 함수다"

#### 결합법칙 (associative property)

결합법칙 Associative는 다음과 같은 법칙성질(참성질)이다.

Associative : "(a * b) * c = a * (b * c)"

#### 중가환 법칙 (medial property)

중가환 법칙 Medial은 다음과 같은 법칙성질(참성질)이다.

Medial : "(m * n) * (p * q) = (m * p) * (n * q)"

#### 교환법칙 (commutative property), 혹은 가환(commutative)

교환법칙 Commutative는 다음과 같은 법칙성질(참성질)이다.

Commutative : "a * b = b * a"

#### 좌역원임-가술어 (tunal is-leftinvers-of Predicate)

좌역원임-가술어 tunalIsLeftinversOf는 내가 방금전에 명명한 가성질이다.

가술어를 tunal 서술어를 붙이는 이유는 tunna-al (다랑어-적)이라는 뜻으로 가술어임을 말하기 위해서다. 이유는 가성질 • 참성칠 명명 유래 참고.

tunalIsLeftinversOf(e, b, a) : "b * a = e"

e = eₗ으로 대입해서 생각한다면, 좌항등원이 항등원인 좌역원임-가술어라고 하며, e = eᵣ이면 우항등원이 항등원인 좌항등원-가술어라고 한다.

해당사항은 하단의 우역원임-가술어에서도 통용된다.

(좌항등원과 우항등원의 정의는 항등원을 정의한 색션을 참고하라, 물론 상식이므로 참고하지 않는게 정상이다.) (심볼정의 문단의 항등원 참고)

#### 우역원임-가술어 (tunal is-rightinvers-of Predicate)

우역원임-가술어 tunalIsRightinversOf는 내가 방금전에 명명한 가성질이다.

tunalIsRightinversOf(e, b, a) : "a * b = e"

#### 좌역원임-술어 (is-leftinverse-of Predicate)

좌역원임-술어 isLeftinverseOf는 내가 방금전에 명명한 가성질이다.

b isLeftinverseOf a : isLeftinverseOf(a, b) : 항등원이존재함(eₗ, eᵣ), tunalIsLeftinverseOf(e, a, b)

로, 좌항등원과 우항등원이 같은 경우의 좌역원임-가술어이다.

(좌항등원과 우항등원의 정의는 항등원을 정의한 색션을 참고하라, 물론 상식이므로 참고하지 않는게 정상이다.) (심볼정의 문단의 항등원 참고)

#### 우역원임-술어 (is-rightinverse-of Predicate)

우역원임-술어 isRightinverseOf는 내가 방금전에 명명한 기성질이다.

b isRightinverseOf a : isRightinverseOf(a, b) : 항등원이존재함(eₗ, eᵣ), tunalIsRightinverseOf(e, a, b)

로, 좌항등원과 우항등원이 같은 경우의 우역원임-가술어이다.

(좌항등원과 우항등원의 정의는 항등원을 정의한 색션을 참고하라, 물론 상식이므로 참고하지 않는게 정상이다.) (심볼정의 문단의 항등원 참고)

#### 역원임-가술어 (tunal is-inverse-of Predicate)

역원임-가술어 tunalIsInverseOf는 내가 방금전에 명명한 가성질이다.

tunalIsInverseOf(e, a, b) : tunalIsLeftinversOf(e, a, b), tunalIsRightinversOf(e, a, b)

로, 좌역원임-가술어와 우역원임-가술어를 모두 만족시키는, 즉, 역원인 경우로써,

이경우도 e에 따라, 항등원이 좌/우 항등원인 역원임-가술어로 말할 수 있다.

### 역원임-술어(is-inverse-of Predicate)

역원임-술어 isInverseOf는 내가 방금전에 명명한 가성질이다.

b isInverseOf a : isInverseOf(a, b) : 항등원이존재함(eₗ, eᵣ), tunalIsInverseOf(e, a, b)

로, 좌항등원과 우항등원이 같은 경우의 역원임-가술어이다.

(좌항등원과 우항등원의 정의는 항등원을 정의한 색션을 참고하라, 물론 상식이므로 참고하지 않는게 정상이다.) (심볼정의 문단의 항등원 참고)

#### 가역원임-가술어 (tunal checking-does-it invertible-element Predicate)

가역원임 가술어 isInvertibleAs는 방금전에 내가 만든 가성질로,

역원 판별논리식 Φ에 대해,

x isInvertibleAs Φ : isInvertibleAs(x, Φ) : ∃y s.t. Φ(x, y)

인 isInvertibleAs로, FOL에서는 술어가 아닌 성질꼴로, 여러가지 성질의 접두사로 동작하며, 그 경우 Φ과 isInvertibleAs를 붙여쓴다.

그러나 권장사항은 SOL에서의 사용이다.

왜냐하면, 내가 FOL로 만들기 디껍고 귀찮기 때문이다.

다만 한가지 주의하기 위해 참고할 점은, ∃y라는 y는 해당 구조의 도메인 위에 있어야 하므로, 닫혀있는 원소인 조건이라는것이고, 따라서, 구조위에서의 의미해석을 해야함에 주의하자.

#### 가역원임-술어 (checking-does-it invertible-element Predicate)

가역원임 술어 isInvertible는 방금전에 내가 만든 가성질로,

x isInvertible : isInvertible(x)

이며,

isInvertible : isInvertibleAs isInverseOf

로써,

x = y, y = z, x = z에서

x isInvertible : isInvertible(x) : x isInvertibleAs isInverseOf : isInvertibleAs(x, isInverseOf)

인 isInvertible로, isInverseOf조건의 isInvertibleAs로 볼수 있으며,

가역원인지 확인하는 술어이다.

#### 전가역성 (Entire-Invertiblity)

전가역성 EntireInvertiblity는 내가 방금전에 만든 참성질 개념으로, "모든 원소가 가역원"을 말하기 귀찮아, 귀차니즘히 심히 많이 도져 귀찮고 괴로워서, 만든 개념이다.

EntireInvertiblity : "x isInvertible"

로써, 모든 x에 대해서 isInvertible인 일반명제임을 술어 Commutative과 같은 경우로 표기했다는 사실로써 능히 알 수 있다.

#### 전사성 특성질 (Surject, 전사성)

전사성 Surject는 치역과 공역이 같은 성질을 말하며,

Surject(f) : codom f = f[dom f]

로써, 모든 정의역 dom f에 대한 상 f,

즉, 치역 Y가 Y = 공역인 경우다.

#### 단사성 특성질 (Inject, 단사성)

단사성 Inject는 정의역과 치역이 일대일로 대응되는 성질을 말하며,

Inject(f) : ∀x, y ∈ dom f, f(x) = f(y) → x = y

로써,

함수 f는 항상 ∀x, y ∈ dom f, x = y → f(x) = f(y)이기에,

Inject(f) ↔ (∀x, y ∈ dom f, x = y ↔ f(x) = f(y))이다.

즉, graph f에서, y값에 대해 x값이 유일하다.

단사성을 만족시키는 함수를 일대일함수라고 한다.

#### 전단사성 특성질 (Biject, 전단사성)

전단사성 Biject는 정의역에 대해 공역이 하나도 빠짐없이 일대일로 대응되는 성질을 말하며, 

모든 공역에 대해 정의역이 하나도 빠짐없이 대응되고,

Biject : Surject, Inject

이다.

즉, 전사이며 단사인것이 전단사다.

전단사성을 만족시키는 함수를 일대일대응이라고 한다.

#### 왼쪽 함자 전단사성 (BijectiveLeftFunctor)

왼쪽 힘자 전단사상이란, 다음과 같은 법칙성질이다.

BijectiveLeftFunctor : "Biject((x *))"

말 그대로 왼쪽 함자가 전단사임을 말하는거다.
참고로, 저기서는 모든 x이 대한 왼쪽 함자이다.
쌍따옴표가 있으니, sentence로써 작동하는것이다.

#### 오른쪽 함자 전단사성 (BijectiveRightFunctor)

오른쪽 힘자 전단사상이란, 다음과 같은 법칙성질이다.

BijectiveRightFunctor : "Biject((* x))"

말 그대로 오른쪽 함자가 전단사임을 말하는거다.
참고로, 저기서는 모든 x에 대한 오른쪽 함자이다.
쌍따옴표가 있으니, sentence로써 작동하는것이다.

### 초실수상 수렴 (convergenceOfℝ*)

초실수상의 수렴은 발산하더라도 무한대로써 유한초실수가 아닌 초실수로 수렴하므로, 도약(jump)하는 경우가 유일한 수렴이 아닌 경우다.

convergenceOfℝ* : "f*(x - ε) = f*(x + ε)"

참고로, 발산이나 진동의 경우에는 모든 양의 무한소ε에 대해 값이 일정하지 아니한 경우이다.

다가함수가 아니려면, 함숫값이 유일하게 결정되야하므로, 자세한건 함수 사용전에 어떻게 범위를 설정하는지에 달렸다.

#₩# 연속 (continuous)

연속 (continuous)이란, 함숫값과 극한값이 같음을 말한다

continuous : (lime f)(x) = f(x)

등호도 관계이므로, 함숫값과 극한값이 정의되어야(다른말로 "x = y ⊨ ∃x, ∃y" 등호 관계가 성립함음 그 대상이 존재해야하는 경우가 전제되기에, 귀결이다, 그 역은 x ≠ y를 만족하는 경우로 부등호 관계도 존재를 전제하기에 아님.) , 등호의 동등관계가 작동한다.

### 연산 목록

#### 왼쪽 역연산 (LeftInverse)

왼쪽 역연산 LeftInverse은

x LeftInverseOf(`*`) y ≜ (x `*`)⁻¹(y)

으로, 왼쪽 연산에 대한 역연산으로,

역함수가 존재할 조건인 일대일대응일것임을 만족하기위해

왼쪽 함자 전단사성을 만족시켜야 한다.

#### 오른쪽 역연산 (RightInverse)

오른쪽 역연산 RightInverse은

x RightInverseOf(`*`) y ≜ (`*` y)⁻¹(x)

으로, 오른쪽 연산에 대한 역연산으로,

역함수가 존재할 조건인 일대일대응일것임을 만족하기위해

오른쪽 함자 전단사성을 만족시켜야 한다.

### 관계 목록

n항 관계 Φ는 집합 D에 대해, Φ ⊆ Dⁿ이다.

술어 Φ는 집합 D에 대해, Φ ⊆ D이다.

즉, 술어는 단항관계이다.

술어 Φ가 집합 S에 대해, Φ ⊆ S일때,

S = Dⁿ이면 Φ는 n항관계이다.

그렇다. 나는 관계와 술어에 구분을 두지 않을것이고,

따라서, 관계는 나에게 그저 튜플이 만족시키는 술어일 뿐이라는거다.

아래 관계들은, FunctionalRelationship을 이용하여, 이루어지는 관계들에 대해 다룬다.

FunctionalRelationship이란

FunctionalRelationship(f, P, Q) : f[P] = Q

인 술어로, P에 대한 f의 상이 Q인 관계이다.

즉, (∃f, FunctionalRelationship(f, P, Q)) ⊨ R을 만족시키는 R들이다.

(참고 : 앞으로, "학부 수준의 통상적 대수구조에서의~"가 붙을 말은, 에초에 학부 수준을 넘어서 범주론까지 설명하는건 뇌절이라고 보고, 대화 맥락과 주제가 "학부 수준의 통상적 대수구조에서의~"를 전제로 하는 경우를 대부분으로 하여 서술하고싶기에, "다루고자 하는~"이라고 하겠다.

#### 등수관계 (equinumous)

등수관계 equinumous란,

P equinumous Q : (∃FunctionalRelationship(f, P, Q))(Biject(f))

인 관계로, P에서 Q로가는 일대일대응이 존재하는 관계이다.

P equinumous Q ↔ card P = card Q이다.

#### 준동형 (Homomorphism)

준동형 Homomorphism이란, 대게의 경우에는 다음을 만족한다.

Volcanoᵢ,₁(P, Sym₁, ..., Symᵢ, `*`) Homomorphism Volcanoⱼ,₁(Q, Sym₁, ..., Symⱼ, `◦`) : (∃FunctionalRelationship(f, P, Q))(homomorphism(f, Volcanoᵢ,₁(P, Sym₁, ..., Symᵢ, `*`), Volcanoⱼ,₁(Q, Sym₁, ..., Symⱼ, `◦`)) [i := card P][j := card Q]

저건 P와 Q사이의 준동형사상 f가 존재하는 관계이다.

<br>

준동형사상 homomorphism은

homomorphism(f, Volcanoᵢ,₁(P, Sym₁, ..., Symᵢ, `*`), Volcanoⱼ,₁(Q, Sym₁, ..., Symⱼ, `◦`)) : dom f = P, codom f = Q, (∀x, y ∈ dom f, f(x `*` y) = f(x) `◦` f(y)) [i := card P][j := card Q]

이다.

<br>

마그마 이상을 이루는 P, Q에 대해, P에서 Q로 가는 사상 f가 (에초에 처음부터 함수인지 뭔지 제안하거나 명시하지 않았었음) 각각의 연산 `*`, `◦`에 대해, f(x `*` y) = f(x) `◦` f(y)를 만족시키므로, 준동형사상은 대수구조의 성질을 보존한다, 즉, 대수구조의 성질은 준동형사상에 양변을 대입하여, 다른 대수구조로 옮길수 있다.

참고로 모델은 튜플이므로, first(x, y) = x와 last(x, y) = y에 대해,

P와 Q는 first로 구해지며, sym을 넘어서 `*`와 `◦`는 last를 각각 i + 1번, j + 1번 하여 얻어지며, i, j는 P, Q의 카디널리티로 얻어지므로, 정의에서 Volcanoₖ,₁사용부분에 결정성에 문제가 생기는지는 걱정하지 않아도 좋다.

범주론에서 대수적 구조 = 아벨 범주이다.
준동형사상은 아벨 범주 위의 사상으로, 범주론을 다루지 않고자 한 지금의 설명에서는 엄밀한 준동형사상의 정의를 다루기 위해 아벨 범주를 다루고싶지 않기에, 다루지 않겠다.

#### 자기 사상을 낀 관계 (Endomorphism)

솔찍히 이게 등호랑 뭐가 다른지 원.....

Volcanoᵢ,₁(P, Sym₁, ..., Symᵢ, `*`) Endomorphism Volcanoⱼ,₁(Q, Sym₁, ..., Symⱼ, `◦`) : (∃FunctionalRelationship(f, P, Q))(endomorphism(f, Volcanoᵢ,₁(P, Sym₁, ..., Symᵢ, `*`), Volcanoⱼ,₁(Q, Sym₁, ..., Symⱼ, `◦`))) [i := card P][j := card Q]

인 관계로, P와 Q사이에 자기 사상이 존재하는 관계이다.

자기 사상 endomorphism이란,

endomorphism(f, Volcanoᵢ,₁(P, Sym₁, ..., Symᵢ, `*`), Volcanoⱼ,₁(Q, Sym₁, ..., Symⱼ, `◦`)) : homomorphism(f, Volcanoᵢ,₁(P, Sym₁, ..., Symᵢ, `*`), Volcanoⱼ,₁(Q, Sym₁, ..., Symⱼ, `◦`)), dom f = codom f [i := card P][j := card Q]

이다. 즉, Volcanoᵢ,₁(P, Sym₁, ..., Symᵢ, `*`) = Volcanoⱼ,₁(Q, Sym₁, ..., Symⱼ, `◦`))이다.

#### 다루고자 하는 단사 사상을 낀 관계 (Monomorphism)

다루고자 하는 단사 사상을 낀 관계 (Monomorphism) (이)란,

Volcanoᵢ,₁(P, Sym₁, ..., Symᵢ, `*`) Monomorphism Volcanoⱼ,₁(Q, Sym₁, ..., Symⱼ, `◦`) : (∃FunctionalRelationship(f, P, Q))(monomorphism(f, Volcanoᵢ,₁(P, Sym₁, ..., Symᵢ, `*`), Volcanoⱼ,₁(Q, Sym₁, ..., Symⱼ, `◦`))) [i := card P][j := card Q]

인 관계로, P와 Q사이의 다루고자 하는 단사 사상이 존재하는 관계이다.

다루고자 하는 단사 사상 monomorphism은,

monomorphism(f, Volcanoᵢ,₁(P, Sym₁, ..., Symᵢ, `*`), Volcanoⱼ,₁(Q, Sym₁, ..., Symⱼ, `◦`)) : homomorphism(f, Volcanoᵢ,₁(P, Sym₁, ..., Symᵢ, `*`), Volcanoⱼ,₁(Q, Sym₁, ..., Symⱼ, `◦`)), Surject(f) [i := card P][j := card Q]

으로, 단사성을 가지는 준동형사상을 말한다.

#### 다루고자 하는 전사 사상을 낀 관계 (Epimorphism)

다루고자 하는 전사 사상을 낀 관계 (Epimorphism) (이)란,

Volcanoᵢ,₁(P, Sym₁, ..., Symᵢ, `*`) Epimorphism Volcanoⱼ,₁(Q, Sym₁, ..., Symⱼ, `◦`) : (∃FunctionalRelationship(f, P, Q))(epimorphism(f, Volcanoᵢ,₁(P, Sym₁, ..., Symᵢ, `*`), Volcanoⱼ,₁(Q, Sym₁, ..., Symⱼ, `◦`))) [i := card P][j := card Q]

인 관계로, P와 Q사이의 다루고자 하는 전사 사상이 존재하는 관계이다.

다루고자 하는 전사 사상 epimorphism은,

epimorphism(f, Volcanoᵢ,₁(P, Sym₁, ..., Symᵢ, `*`), Volcanoⱼ,₁(Q, Sym₁, ..., Symⱼ, `◦`)) : homomorphism(f, Volcanoᵢ,₁(P, Sym₁, ..., Symᵢ, `*`), Volcanoⱼ,₁(Q, Sym₁, ..., Symⱼ, `◦`)), Surject(f) [i := card P][j := card Q]

으로, 단사성을 가지는 준동형사상을 말한다.

#### 동형 (Isomorphism)

동형 Isomorphism이란,

Volcanoᵢ,₁(P, Sym₁, ..., Symᵢ, `*`) Isomorphism Volcanoⱼ,₁(Q, Sym₁, ..., Symⱼ, `◦`) : (∃FunctionalRelationship(f, P, Q))(isomorphism(f, Volcanoᵢ,₁(P, Sym₁, ..., Symᵢ, `*`), Volcanoⱼ,₁(Q, Sym₁, ..., Symⱼ, `◦`))) [i := card P][j := card Q]

인 관계로, P와 Q사이의 동형사상이 존재하는 관계이다.

동형사상 isomorphism이란,

isomorphism : monomorphism, monomorphism

으로, 전사 사상이고 단사 사상인 사상으로,

걍 일대일대응인 준동형사상이라고 보면 된다.

동형인 두 대수구조에서, P, Q는 등수관계이므로,

i = j이다.

k = i = j라고 하면,

Sym₁, ..., Symₖ가 동형사상을 통하여 일대일대응되어, y = f(x)에서, z ∈ {x, y} 로 잡으면, x와 y의 대수구조 종류가 같고, 성질이 같으며, 심볼의 모든 대수구조상의 특성이 동등함(=동치임)을 알수있다.

요컨데, 동형임은 대수적 구조로서 완벽하게 동일함을 말한다.

#### 자기동형 관계 (Automorphism)

자기동형 관계 Automorphism(이)란,

Volcanoᵢ,₁(P, Sym₁, ..., Symᵢ, `*`) Automorphism Volcanoⱼ,₁(Q, Sym₁, ..., Symⱼ, `◦`) : (∃FunctionalRelationship(f, P, Q))(automorphism(f, Volcanoᵢ,₁(P, Sym₁, ..., Symᵢ, `*`), Volcanoⱼ,₁(Q, Sym₁, ..., Symⱼ, `◦`))) [i := card P][j := card Q]

인 관계로, P와 Q사이의 자기동형사상이 존재하는 관계이다.

지기동형사상 automorphism이란,

automorphism : isomorphism, endomorphism

으로, 동형 사상이고 자기 사상인 사상으로,

동형이고, 자기사상을 낀 관계이다.

#### 위상동형사상 관계 (homeomorphic)

위상동형사상 (Homeomorphism)

Homeomorphism(fn) : Biject(fn), (x ∈ dom fn, f = fn ⊨ continuous), (x ∈ codom fn, f = f⁻¹ ⊨ continuous)

### 심볼 목록

아래 심볼은, Volcano에서 사용 목적이 정해진 특수한 심볼이다

#### 항등원 (identity element)

이항연산 `*`의 항등원은

 - 좌항등원 eₗ
 - 우항등원 eᵣ

이 존재하고,

각각

+ eₗ * x = x
+ x * eᵣ = x

를 만족하며, (이게 바로 정의)

다음 술어

항등원이존재함(eₗ, eᵣ) : eₗ = eᵣ

에 대해,

항등원이존재함(eₗ, eᵣ) ⊨ ∃e s.t. eₗ = e = eᵣ

인, 즉, 좌항등원과 우항등원이 같으면, "항등원이 존재한다"고 하고, 좌항등원과 우항등원이 같으니, 그것을 "항등원"이라고 하며, 이것의 존재조건인 좌항등원과 우항등원이 같을것이 항등원의 존재 조건이다.

N.B. ATTENTION, WARNING, NOTE(IMPORTANT), WATCHOUT, TIP, DECLARE, READIT : 이하에서, 좌항등원 및 우항등원 기호도 여기에서 정의했으므로, 여기를 참고해야한다는걸 강조하고 또 경고하겠다.

### Laval 대수구조 명칭 목록

**Laval은 Lava + -al이라서, Lava + -적(的) 이라는 뜻이다. `Laval == Lava적(的)`인것이다. (오타아님, 중요)**

어떤 Laval 대수구조 명칭 (= Lava식 대수구조 명칭) K란,

K(Volcanoₘ,ₙ(D, Sym₁, ..., Symₘ, fun₁, ..., funₙ)) : "대수구조 Volcanoₘ,ₙ(D, Sym₁, ..., Symₘ, fun₁, ..., funₙ)가 그 Laval 대수구조 명칭 K가 지칭하는 대수구조를 이룬다"

인 K를 말한다.

예컨데, Magma(Volcanoₘ,₁(D, `*`))은 항진인것이, lava는 기본적으로 닫혀있기에, 그 대수구조 위에 연산이 정의되어있디면 마그마다.

요컨데, Laval 대수구조 명칭은 술어이다.

예컨데 마그마의 Laval 대수구조 명칭 Magma는

Magma라는 영문 명칭 술어이다

#### 1. 1. 단위 마그마 (unit magma)

이항연산 `*`가

Volcano₁,₁(D, e, `*`) ⊨ "이항연산 `*`가 (D, `*`, e)를 이룸"

인 `*`라면, 즉, 항등원을 가진다면,

이를 단위 마그마라고 부른다

Laval 대수구조 명칭은 UnitMagma 이다.

#### 1. 3. 중가환 마그마 (medial magma)

이항연산 `*`가

Volcanoₘ,₁(D, Sym₁, ..., Symₘ, `*`) ⊨ "이항연산 `*`가 (D, `*`)를 이룸", Medial

인 `*`라면, 즉, 당연히 `*`는 마그마니까, 그 마그마가 중가환법칙을 만족시킨다면,

이를 중가환 마그마라고 부른다.

Laval 대수구조 명칭은 MedialMagma 이다.

#### 1. 2. 가환 마그마 (commutative magma)

이항연산 `*`가

Volcanoₘ,₁(D, Sym₁, ..., Symₘ, `*`) ⊨ "이항연산 `*`가 (D, `*`)를 이룸", Commutative

인 `*`라면, 즉, 당연히 `*`는 마그마니까, 그 마그마가 교환법칙을 만족시킨다면, 즉, 가환이라면,

Laval 대수구조 명칭은 CommutativeMagma 이다.

이를 가환 마그마라고 부른다.

#### 2. 1. 반군 (semigroup)

이항연산 `*`

Volcanoₘ,₁(D, Sym₁, ..., Symₘ, `*`) ⊨ "이항연산 `*`가 (D, `*`)를 이룸", Associative

인 `*`라면, 즉, 당연히 `*`는 마그마니까, 그 마그마가, 결합법칙을 만족하면,

이를 반군이라고 한다.

Laval 대수구조 명칭은 Semigroup 이다.

#### 2. 2. 모노이드 (monoid)

이항연산 `*`가

UnitMagma(Volcano₁,₁(D, e, `*`)), Semigroup(Volcano₁,₁(D, e, `*`)) ⊨ "이항연산 `*`가 (D, `*`, e)를 이룸"

인 `*`라면,

즉, 이항연산 `*`가 반군을 이루며, 단위 마그마를 이루면, 

이를 모노이드 (monoid)라 한다.

Laval 대수구조 명칭은 Monoid 이다.

#### 2. 3. 군 (Group)

이항연산 `*`가

(⊨ Monoid(Volcano₁,₁(D, e, `*`)) ⊨ EntireInvertiblity) ⊨ "이항연산 `*`가 <D, `*`>를 이룸"

인 `*`라면,

즉, 이항연산 `*`가 반군을 이루며, 전가역이면 (= 전가역성을 띄면 = 전가역성을 만족하면)

이를, 군이라 한다.

Laval 대수구조 명칭은 Group 이다.

#### 2. 4. 아벨 군 (Abelian Group) • 가환군 (Commutative Group)

> 솔찍히 중학교때 생각한 생각인대 소신발언 하자면, 오차방정식의 근의공식이 없다는걸 밝힌 위대한 수학자 아벨(Abel)님이 너무 고생하고 비참하긴 한데, 대학못간새끼만큼 비참한건 아니니까, (반대하면 인신공격하고싶... 크흠..), 우리 학생들을 위해 과감히 버리고, 가환군이라고 부르는게 좋다고 본다. 소신발언임 주의.

이항연산 `*`가

CommutativeMagma(VoLeftQuasigrouplcano₁,₁(D, e, `*`)), Group(Volcano₁,₁(D, e, `*`)) ⊨ "이항연산 `*`가 <D, `*`>를 이룸"

인 `*`라면,

즉, 이항연산 `*`가 군을 이루는 동시에 가환 마그마를 이룬다면,

이를, 가환군 • 아벨군 이라고 하며,

(또한, AbelianGroup = CommutativeGroup 이고)

Laval 대수구조 명칭을 CommutativeGroup로 한다.

(당연히 AbelianGroup = CommutativeGroup이므로, AbelianGroup로 해도 된다. 왜 대입이 되는지는 "Laval명칭"의 정의 참고. (술어임))

#### 2. 5. 자명군 (trivial group)

이항연산 `*`가 

Group(Volcano₁,₁(D, e, `*`)) s.t. D = {e} ⊨ "이항연산 `*`가 <{e}, `*`>를 이룸"

일때, 이를 자명군이라고 하고, Laval 대수구조 명칭을 TrivialGroup 이라 한다

#### 3. 1. 1. 왼쪽 유사군 (LeftQuasigroup)

Volcanoₘ,₂(D, Sym₁, ..., Symₘ, `*`, `◦`) [`◦` := LeftInverseOf(`*`)] ⊨ "이항연산 `*`가 (D, `*`, `◦`)를 이룸", BijectiveLeftFunctor

인 `*`라면, 즉, 당연히 `*`는 마그마니까, 그 마그마가, 왼쪽 함자 전단사성을 만족시킨다면, 이를 왼쪽 유사군이라고 한다.

#### 3. 1. 2. 오른쪽 유사군 (RightQuasigroup)

Volcanoₘ,₂(D, Sym₁, ..., Symₘ, `*`, `◦`) [`◦` := RightInverseOf(`*`)] ⊨ "이항연산 `*`가 (D, `*`, `◦`)를 이룸", BijectiveRightFunctor

인 `*`라면, 즉, 당연히 `*`는 마그마니까, 그 마그마가, 오른쪽 함자 전단사성을 만족시킨다면, 이를 오른쪽 유사군이라고 한다.

#### 3. 1. 유사군 (Quasigroup)

LeftQuasigroup(Volcanoₘ,₂(D, Sym₁, ..., Symₘ, `*`, `◦`)), RightQuasigroup(Volcanoₘ,₂(D, Sym₁, ..., Symₘ, `*`, `◦`)) ⊨ "이항연산 `*`가 (D, `*`, `◦`)을 이룸"

왼쪽 유사군이자 오른쪽 유사군인것.

즉, 함자가 bijection이면 유사군이다

유사군의 Laval 대수구조 명칭을 Quasigroup라 하자.

<br>

`=== well... ===`

<br>

시실 쉽게말해서, 항상 역연산이 성립하는건게, 항등원 개념이 없어도 된다.

역연산의 특성은 유사군에서 오고, 왼쪽•오른쪽 함자에서 역함자가 존재해서 역연산이 정의되는거다.

어떤 함자 방정식의 해가 유일하게 결정되기 때문이다.

군이라서 역연산이 있는게 아니다.

군이 유사군을 이루기 때문이다.

왜?

전가역성 때문에, a에 대해 그 가역원 b에 대해, (* b)가 (* a)의 역연산으로 정의 가능하기 때문에, 그리고 실제로 일대일대응이 되버리기 때문에, 군은 유사군을 이룬다.

#### 3. 2. 고리 (Loop, 위키백과에선 고리라고 했다만, 수학계에서는 루프라고 부른다고 카더라)

이항연산 `*`가

Quasigroup(Volcano₁,₁(D, e, `*`)), UnitMagma(Volcano₁,₁(D, e, `*`)) ⊨ "이항연산 `*`가 <D, `*`>를 이룸"

일때, 이를 고리라고 하고, Laval 대수구조 명칭으로 Loop 이라 한다.

Quasigroup에 대해서는 최근 설명을 추가했으니, 위 항목 참고

### 성질, 예약 심볼, 대수구조에 대한 해설

#### 결합법칙에 대해 해설하며 ; Associatival Extension과 반군

m항연산 f가 Associative를 만족한다면, m < n인 n에 대해,

f(x₁, ..., xₙ) ≜ f(x₁, ..., xₘ₋₁, f(xₘ, ..., xₙ))

로 제귀적으로 정의하며,

이러한 구조의 작동 원리는 결합법칙에 근거한다.

이러한 제귀적 정의를 결합적 확장 (Associatival Extension)이라고 부르며, 내가 방금 만들어낸 조어이다

m, n은 무한해도 좋을거다. 아마도.

Associatival Extension에 의해, m항연산과 가변항연산의 경계가 허물어지는 특징을 보이기에, 반군인 연산은 k항연산이라면, 최소 항의 수를 k로 간주한다.

#### 역원임-술어에 대해 설명하기 : 좌역원이자 우역원이면 역원임 정리

좌역원이자 우역원이면 역원임 정리는 내가 만든 정리로, 사실 정리라고 하기에도 존나 애매한 난이도다.

+ p' = p ∧ r
+ q' = q ∧ r
+ s = p ∧ q
+ s' = s ∧ r

에서,

p' ∧ q' = s'임은 당연히 안다.

이때,

+ p = 좌역원임-가술어이고
+ q = 우역원임-가술어이고,
+ r = 항등원이존재함(eₗ, eᵣ)일때,

좌역원임-술어, 우역원임-술어, 역원임-가술어, 역원임-술어의 정의에 따라, 

좌역원임-술어 ∧ 우역원임-술어 = 역원임-술어

이라는것이다.

## 의미해석

(작성중; 규칙도입계와 기초적 파악이 어떻게 작동하는지를 먼저 적겠음. 나중에.)

### 규칙도입계

(작성중)

### 기초적 파악

앞으로 말할 L은 모델론적 언어라는 맥락에서 말하는거다.

또한, (작성중)

#### 명세관계 ; isInterfaceOf

T isInterfaceOf L : isInterface(L, T) : (L ⊨ T) s.t. (∀T' ⊨ L)(T ⊨ T')

T는 L의 명세인 관계로, L의 기초임을 알리는 관계다.

L의 정의 ⋅ 규칙을 담당하는 부분으로, 논리 언어 Lₗₒₛᵢₖ (저 및첨자들은 원래 "losik"이 아닌 "logic"로 쓰려고 했지만, 유니코드의 한계상 포기)이 자연 연역(Natural Deduction)하는걸 제외한, 규칙계형 파트로 전반적 논리를 구성한다.

예를들어 L은 TensorFlow, T는 그 공식 document로, 기능은 L에 있고, 그 원리가 T이다.

예를들어,

L = 페아노 산술, T = peano axioms and defines이면,

L"1 + 1 = 2"에서,

정의는, T에서,

```markdown
## DEFINITION

### 덧셈 `+`의 정의

1. x + 1 = x⁺
2. x⁺ + y = (x + y)⁺

여기에서, 정의 2번에 1번을 대입하면, (x + 1) + y = (x + y) + 1로, 결론을 부정하는 조건을 만족하는 명제를 역산해보자면, 그것이 바로 교환법칙의 부정과 결합법칙의 부정이므로, 부정한 결론이 틀림에 근거하여, 이중부정을 통해, 덧셈은 가환반군을 이룸을 알 수 있다. 참고로, 0을 정의하지 않은 버전에서는 모노이드도 아니고 걍 반군이다.

## AXIOMS

다음 다섯 공리를 만족하는 상수 1과 집합 ℕ이 존재한다.

1. 1 ∈ ℕ
2. n ∈ ℕ ⇒ n⁺ ∈ ℕ
3. ∀n ∈ ℕ, n⁺ ≠ 1
4. ∀n ∈ ℕ ∀m ∈ ℕ, n⁺ = m⁺ ⇒ n = m
5. ∀S ⊂ ℕ, (1 ∈ S ∧ (n ∈ S ⇒ n⁺ ∈ S)) ⇒ (S = ℕ)

공리 5를 자연수의 귀납적 정의라고 하며, 이는 무한공리에서 말하는 무한집합 중 최소의 크기를 가지는 집합이라는 뜻이다. 또한, 저기에서 수학적 귀납원리가 나온다.

저걸 함수의 언어로 바꾸면, 어떻게 모델을 구축해야할지 보인다.

4번 공리를 보아하니, 다음수 연산 `⁺`는 단사(일대일함수)이다. 그런데, 치역이 1 이상의 자연수 전체이므로, 해당 자연수를 정의역으로 하고 치역이 1이상의 자연수를 치역으로 한다면, 전단사함수(일대일대응)일것이고, 따라서, 다음수 연산은 역함수인 이전수 `⁻`를 가진다. (이 설명의 근걸는 2번 공리 함고)

3번, 1번, 5번 공리를 보면, 자연수는 1에서 시작해서 연쇠적으로 세어나가면서 나오는 수들의 집합이다.

참고로 5번 공리를 보지 말고, 2번 공리만 보더라도 알 수 있다.

사실 5번 공리에 1번 공리에 쓰인 텍스트와, 2번 공리에 쓰인 텍스트가 전부 들어간 점에서, 우리는 자연수 집합 S = ℕ을 다룰떄, 1번, 2번, 3번 공리를 보면 됨을 쉽게 알 수 있다.

사실은, 이것의 모델에서 1은 상수 심볼인데, 번외에서 신기한 특징을 다루겠다.

## 번외

다음 술어 ℙ₁, ℙ₂, ℙ₃, ℙ₄, ℙ₅를 DEFINE하자.

ℙ₁(k, ℕₖ) : k ∈ ℕₖ
ℙ₂(k, ℕₖ) : n ∈ ℕₖ ⇒ n⁺ ∈ ℕₖ
ℙ₃(k, ℕₖ) : ∀n ∈ ℕₖ, n⁺ ≠ k
ℙ₄(k, ℕₖ) : ∀n ∈ ℕₖ ∀m ∈ ℕₖ, n⁺ = m⁺ ⇒ n = m
ℙ₅(k, ℕₖ) : ∀S ⊂ ℕₖ, (ℙ₁(k, S) ∧ ℙ₂(k, S)) ⇒ (S = ℕₖ)

다음은 AXIOMS이다.

다음 공리를 만족하는 상수 k와 집합 ℕ이 존재한다.

1. ℙ₁(k, ℕₖ)
2. ℙ₂(k, ℕₖ)
3. ℙ₃(k, ℕₖ)
4. ℙ₄(k, ℕₖ)
5. ℙ₅(k, ℕₖ)

여기에서도, 4번공리를 통해 다음수의 특징이 유추되며,
1, 2, 3번공리를 통해, k부터 시작하는 자연수(서수) ℕₖ를 정의함을 알 수 있다.

참고로, 덧셈의 정의를 통해서 다름수의 뜻을 알수 있음은 너무 당연한 사실이고, 여기서도 동일하다.

참고로 ℕ₀를 범자연수라고 하며, 𝕎 = ℕ₀로 표기하기도 한다.

참고로,

수가 0, 수가 null(=Null), 수가 NaN인것의 차이가 뭐냐하면,

0은 잔액이 0,
null은 잔액이 없음 (= 그런거 없음)
NaN은 잔액이 수가 아님 (= 0/0꼴)
인것이라서,

0은 통장 잔액이 텅장
null은 통장이 없음
NaN은 통장 잔액이란 개념이 없음

이었던가...? 그랬다.

그런데 잔액이 없는거 (수량을 보는데 그값이 없음(=null))랑 잔액이 0인거 (수량이 0인것)가 무슨 차이인가?

수량으로써 0은 그것이 수량으로 있어야 한다.

0은 없는것을 의미하는, 즉, 1 - 1을 의미하는 수량이고,

이게 자연수가 되야하는지는 논란이었다. (= 자연에 있는 수인지, 자연으로부터 나오는지 논란)

그러나, 수라는게 자연을 설명하는것이고, 셈을 시도했을때, 무조건 ℕ₀(= 𝕎)나 NaN(=원래는 실수에서 정의역 벗어남이지만, 여기서는 범자연수로 치자.)으로 세어지므로, 범자연수로 다룬다고 합리화하는것 같다.

솔찍히 나도 뭐가 맞는지 모르겠고, 걍 범자연수로 구축하는게 용이한건 확실하다.

그래서 실제로, 페아노 공리계를 구축할때는, 범자연수를 쓴다고 한다.
```

이므로, 해당 언어는 모델론이 의미하는 규칙에 따라, L"1 + 1 = 2"가 L"1⁺ = 2"로 치환되서 (덧셈의 정의), 심볼 '2'가 의미하는 바가 1의 다음수를 표기하는 Notation임을 알 수 있다.

그러니까 십진법 기호 표기법은,
1. 2 = 1⁺
2. 3 = 2⁺
3. 4 = 3⁺
4. 5 = 4⁺
5. 6 = 5⁺
6. 7 = 6⁺
7. 8 = 7⁺
8. 9 = 8⁺
   
를 만족하는 모델론적 언어로 볼 수 있다.

십육진법에서는
1. 추가규칙 아님, 상단참고
2. 추가규칙 아님, 상단참고
3. 추가규칙 아님, 상단참고
4. 추가규칙 아님, 상단참고
5. 추가규칙 아님, 상단참고
6. 추가규칙 아님, 상단참고
7. 추가규칙 아님, 상단참고
8. 추가규칙 아님, 상단참고
9. A = 9⁺
10. B = A⁺
11. C = B⁺
12. D = C⁺
13. E = D⁺
14. F = E⁺
    
인 추가 규칙이 생기는것이고 말이다.

참고로, 범자연수식으로 보자면, 1 = 0⁺로 정의된다.

물론 이에 대해, 항상 참인거 아니냐고 물을 수 있을텐데, 무한공리를 허용하지 않으면, 이러한 구축방법은 참이 아니고, 이런식으로 정의와 공리를 적고 나서 그를 만족시키는 모델이 존재하지 않는...

예컨데, 공리에 1 = 2를 추가하면 배중률을 어기는데, 이를 만족하는 모델은, 더이상 형식논리가 아니므로, 항상 참은 아니다.

하필 자연수의 덧셈을 가져와서 항상 참이지만

하필.

#### 구현관계 ; isImplementOf

M isImplementOf T : isImplementOf(T, M) : T isInterfaceOf L, M ⊨ T ⊨ L

M이 T의 구현 (Tip : 구현체로 이해해도 좋음)인 관계로, M은 T인 체계를 구성한다.

L언어와 그것을 이룰 요건인 기초 T를 만족하는 M은 구조모델이고, M은 기초 T와 Pre와 Fun, Sym정의 등을 구현(=구성)하며, M ⊨ L ⊨ T인 측면이 있다.

그러나 T의 본질이 M인지 확신할 수 없으며, 당장 FOL에서 뢰벤하임-스콜렘 정리 (Löwenheim–Skolem theorem)등에 따라서, 본질이라기 보다는, 수학적 • 구조적 정합성 측면에서 본질로 볼 수 있는 측면이 있는 구현(=형식화, 사실 정의 되는지도 모르겠는걸 분석 후 모델로써 정의하는것같은 원리다)이지, 유일한, 그리고 절대적인 진리 따위가 아니다.

뢰벤하임 스콜렘 정리에 따라서, 여러가지 모델로 본질을 표현할 수 있다고 하고, 당장에 실수에 대해서, Łoś's theorem으로 만든 `ℝ*` (초실수체, hyperreal field) 만 봐도, 알 수 있다.

그러나 겉모습만 보여주고 그걸 본질이냐고 묻는데에 대해서는 전혀 그렇게 확신할 근거가 없다고 단언한다. 근거를 가져와야한다.



다시 돌아와서, T와 M에 대해 말하자.

예컨데 T는 TensorFlow의 document, M은 일게 그 구현체,

혹은 T는 C언어나 LISP, M은 gcc나 Racket을 예로 들수 있을것이다.



다시한번 이전에 peano공리계로 예를 들었듯 peano공리계 T와 체르멜로(Zermelo)의 구성(Constructure) M과, 폰 노이만 (von Neumann)의 구성 `M'`으로 예를 들어보자 

먼저 M은

```markdown
s(x) = x⁺에서,

0 := ∅
s(x) := {x}

즉,

M = <ℕ₀, 0 = ∅, s(x) = {x} s.t. codom s = ℕ>

인 체계로,

16진수 표기법은,

0 := ∅에서,

1. 1 := {0}
2. 2 := {1}
3. 3 := {2}
4. 4 := {3}
5. 5 := {4}
6. 6 := {5}
7. 7 := {6}
8. 8 := {7}
9. 9 := {8}
10. A := {9}
11. B := {A}
12. C := {B}
13. D := {C}
14. E := {D}
15. F := {E}

로 볼 수 있다.

덧셈은, 범자연수에 대해 가환 모노이드를 이룬다.

> 
> pf.
> 
> 기본적으로 덧셈은 가환 반군을 이룬다.
> 
> 집합 중간에 구멍을 송송내서 닫히지조 못하게 고문하는 경우는 제외하고 말이다.
> 
> 그런 비정상정임경우를 가져오는 미친놈은 아마 없을것이다.
> 
> ~~(가져온다면 덧셈왈 나는 입이없지만 소리를 질러야 한다 이럴듯하다)~~
> 
> 0 + 1 = 0⁺ = 1이므로,
> 
> (0 + x)⁺ = 0⁺ + x = 1 + x = x + 1 = x⁺임을 알수 있는데,
> 
> (x + 0)⁺ = x⁺이므로,
> 
> x + 0 = x임을 알 수 있다.
> 
> 즉 항등원을 가지니, 단위 마그마를 이룸을 알 수 있다.
> 
> 가환 반군이자 동시에 단위 마그마인것은, 가환이고 반군이자, 동시에 담위 마그마인것으로, 가환이고, 모노이드인것으로, 가환 모노이드이다.
> 

2 + 2 = 4인것은,

2 = 1⁺이기에,

2 + 1⁺ = 1⁺ + 2 = (1 + 2)⁺ = (2 + 1)⁺ = 3⁺ = 4로 구할 수 있다.



덧셈은,

1. Φ₁(`*`) : `x * 1 = x⁺`
2. Φ₂(`*`) : `x⁺ * y = (x * y)⁺`
3. Φ : Φ₁, Φ₂

이게 정의한 술어 Φ에서,

Φ(`+`)인 연산이다.

사실은 (+ 1) = s 이게 정의되며, 닫혀있다면 가환반군을 이룰성질을 부여해서 구축했다고도 볼 수 있다.

근데, 이러면, 단점이 좀 있어서, 충분히 나은 폰 노이만 방식을 택한다.

당연히 최대효율을 택하는 한계효용 생각해보면 합리적으로 보인다.
```

`M'`은

```markdown

자연수가 서수(ordinal) 이게도 만들어주는 장점많은, 삐까뻔쩍한 구성이다.

s(x) = x⁺에서,

0 := ∅
s(x) := x ∪ {x}

식으로 구성한다.

즉,

`M'` = <ℕ₀, 0 = ∅, s(x) = x ∪ {x} s.t. codom s = ℕ>

사실 도매인(정의역, 모델의 닫여야하는 집합)이 ℕ₀일떼, codom s = ℕ임은 전부 그렇다.

이 점에서, 자연수가 간단히 나오니 걍 범자연수 구축이라도 왜 이래야 하는지 따지지 말고 받아들여줬으면 좋겠다.



자, 폰 노이만 구성에서 16진수 표기법은

0 := ∅ (= {}) 에서,

1. 1 = {0}
2. 2 = {0, 1}
3. 3 = {0, 1, 2}
4. 4 = {0, 1, 2, 3}
5. 5 = {0, 1, 2, 3, 4}
6. 6 = {0, 1, 2, 3, 4, 5}
7. 7 = {0, 1, 2, 3, 4, 5, 6}
8. 8 = {0, 1, 2, 3, 4, 5, 6, 7}
9. 9 = {0, 1, 2, 3, 4, 5, 6, 7, 8}
10. A = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
11. B = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A}
12. C = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B}
13. D = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C}
14. E = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D}
15. F = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E}

이다.

마찬가지로 반군을 이루고, 덧셈의 구성 방법도 같다.



폰 노이만 식이든 체르멜로 식이든

Rank x = x 임은 같고,

x ∈ x⁺임도 같지만

폰 노이만 방식은

0, 1, ..., x ∈ x⁺

이며,

card x = x (단. 이 문장은 엄밀하지 못하다. 범자연수와 기수와 서수는 다른것이, 기수(카디널리티, 카디널)는 "××집합의 카니덜은"이라고 말하는데에서 알수 있듯, 집합에 대한것이다 (정의상), 집합의 카디널리티는 일대일대응이 있으면 같은것이므로, 카디널리티(기수)를 범자연수로 정의하지 아니하였다면, 카디널이 같은지 여부에서는, 에초에 관계의 정의역에 들어가지 못하는 불상사다 일어나, 항위일것이니, 카디널리티가 범자연수인 경우에 맞는 문장이다)

이라는것이 특징이다.

또한, y ≤ x에서,

y ⊂ x으로,

외연공리를 이용하여 같은지 다른지를 알 수 있는 장점이 있다.

사실 범자연수 집합의 존재성은, 무한 공리에서 보장한다.

ZF공리계에서 초한수의 최소이자 초한기수의 최소는 자연수번째 무한 혹은 자연수의 카디널, 즉 자연수 크기의 무한인데,

무한 공리에서 말하는 최소 크기의 무한집합이 자연수이기 때문이다. (자연수의 정의)

그리고 이게 표준 방법이다.

비표준이라고 틀린건 아니지만, 권총과 망치로 인해 표준이 맞는것처럼 치도록 강제할수 있다.

사회라는 약속으로.
```

위와같이 모델을 만들수 있어도, 이것이 왜 그 구현이여야 하는지 잘 모르겠지 않나?

진짜 자연수는, 그 본질이 공리계에 있을것이다.

(사실 굳이 그 공리계로 잡지 않아도, 다른 공리계가 그 공리계를 만족시킨다.)

아마도 말이다. 이것은 본질이라기에는 실용적 구현에 가까워보이니, 함부로 명세가 본질이네 구현이 본질이네 할 증거가 없다고 단언한것이다.

그 증거를 더 가져와야 한단것을.

그리고, 자연수의 두 구현체를 보고, 당연히 그런식으로 약속했으니 그렇게 되는것 아니냐고 묻는다면 말하겠다.

당신은 Lisp(언어)와 Racket(구현체)이 완전히 동일하다고 생각하는가?

#### 상속자 : Extender

N.B. ATTENTION, WARNING, NOTE(IMPORTANT), WATCHOUT, TIP, DECLARE, READIT :  자, 이제부터 다루는 내용이 핵심이다. isInterfaceOf나 isImplementOf는 일게 모델론적 개념의 표기법용 노트의 설명에 불과하다.

N.B. ATTENTION, WARNING, NOTE(IMPORTANT), WATCHOUT, TIP, DECLARE, READIT : 내가 설명항 내용은 지금부터 시작이고, 의미해석의 핵심 파트는 상속사, 피상속자, 참피상속자, 섹터, 명제귀결, 구조귀결, 폼페이 함수를 이용한, 기초적 파악이고, 이중 피상속사 참피상속자, 섹터같은 구조가 상속자에서 나온다.
N.B. ATTENTION, WARNING, NOTE(IMPORTANT), WATCHOUT, TIP, DECLARE, READIT : 그러나 핵심적인 논리흐름은 명제귀결, 구조귀결을 알아야 하고,
N.B. ATTENTION, WARNING, NOTE(IMPORTANT), WATCHOUT, TIP, DECLARE, READIT : 다루는 대상은 기초적 파악이다.

자, 본론으로 들어가보자.

Interface, Implement, Extend... 사실 이것들은 다 Object Oriented Programming Language인 Java에서 따온 명칭이다.

뭐... 그냥 그렇다는거다.

Extenderₙ(M₁, ..., Mₙ) ≜ M s.t. M₁, ..., Mₙ ⊨ M

Extender(상속자)란 n개의 Implement들을 상속한 Structure Model을 주는 함수로 Extender의 용법의 대표적 예시로는, DustunalExtenderalObject와 Sector가 있다.

상속자를 아래 예시로 살펴보자.

```python

class CORE(bool):
    def __init__(self, value) -> None:
        super().__init__(value)
    
    def __gen_my_type(self, ob):
        return type(self)(ob)

class ConjuntionLattice(CORE):
    def __init__(self, value) -> None:
        super().__init__(value)
    
    def __and__(self, other):
        return self.__gen_my_type(self and other)

class ANF(ConjuntionLattice):
    def __init__(self, value) -> None:
        super().__init__(value)
    
    def __xor__(self, other):
        return self.__gen_my_type(int(self) ^ int(other))

class NagationStructureModel(CORE):
    
    def __init__(self, value) -> None:
        super().__init__(value)
    
    def __invert__(self):
        return self.__gen_my_type(not self)

class CNF(NagationStructureModel, ConjuntionLattice):
    def __init__(self, value) -> None:
        super().__init__(value)

class DNF(NagationStructureModel):
    def __init__(self, value) -> None:
        super().__init__(boolean)
    
    def __or__(self, value):
        return self.__gen_my_type(self or other)

class PsudoAngdeAlgebra(ConjuntionLattice):
    '''
    # diffrence between PsudoAngdeAlgebra and Angde Algebra
    
    while Angde Algebra is defined by me, and also it only use imply and use boolean value , not using conjuntion, but PsudoAngdeAlgebra is using Conjunction to form the logical operated.
    
    model theory to make an logical language or gödel numbering's logical operand.. blablabla

    it used in past as whole diffrent forms. that's an critical diffrence betwean AngdeAlgera
    '''

    def __init__(self, value) -> None:
        super().__init__(value)
    
    def __le__(self, value):
        '''
        letter `<=` seems like reversed implication operator `⇐`, so it will coded as `<=` means `←` which implication symbol s.t. `x ← y` means `y implies x` s.t. `x ← y = y → x = (¬y ∨ x)`
        '''
        return self.__gen_my_type(self or not value)

class HighschoolLevelLogicalOperator(PsudoAngdeAlgebra, CNF, DNF, ANF):
    '''
    L = {'~', '&&', '||', '^', '<='}
    '''
    
    def __init__(self, value):
        super().__init__(value)
```

이처럼 상속 구조는 필드(구조체 상수)및 메서드(구조체 함수)를 가져오는데,

다음 c/c++코드를 보라.

```cpp

struct intSizeTyp {
    int main_value;
    
    intSizeTyp(int main_value) {
        this.main_value = main_value;
    }
}

struct MathmaticalStructure : intSizeTyp;

struct MathmaticalStructure {
    const MathmaticalStructure Sym1 = MathmaticalStructure(0);
    const MathmaticalStructure Sym2 = MathmaticalStructure(1);
    
    MathmaticalStructure Fun1(intSizeTyp x) {
        return x + this.Sym2
    }
    
    MathmaticalStructure Fun2(void) {
        /* null-ary operand */
        return this.Sym1
    }
};
```

저 구조체는 다음과 같은 튜플이다.

MathmaticalStructure = <constructer, Sym1, Sym2, Fun1, Fun2, main_value>

각각 도메인(이라고 치자고 ㅋㅋ ㅠㅠ) 상수기호 Sym1, Sym2, 함수기호 Fun1, Fun2, 변수기호 main_value가 차례대로 담긴 그저 튜플이다.

그리고 이건 시벙 놀랍게도 C의 구조체의 역할인 그냥 이름붙여 묶기를 잘 수행하는 튜플이다.

예를 들어보자.

```cpp
struct cardesian_coordinate {
    double x; //8B = 64bit
    double y; //8B = 64bit
};

cardesian_coordinate v;
```

위 코드는 다음과 같이 메모리에 적제될것이다. (컴파일 예시지 실제로 저러진 않는다.

```
memory addr : 0000 0000 0000 07B4 | v.x
memory addr : 0000 0000 0000 07BC | v.y
```

그러면 저 필드가 가르키는건 순전히 <x, y>인 튜플의 원소다.

실제로 SIMD vectorization연산도 이와 유사하다.

이와같이, 어떤 구조체 M, N이 있어서, M ⊨ N의 만족관계를 가지면, 상속된다고 비유적으로 이해할 수 있다.

#### 피상속자 ; ExtenderalObject

피상속자 ExtenderalObject는 External과 반대로, 부모를 쫒아간다 생각하면 편하다. (편하다고 했지, 꼭 그런건 아닌게, 피상속 관계를 만족시키는걸 뱉는 다가함수로, 부모 모델들의 집합을 뱉지만 그걸 여러개 뱉으므로, M, N, L을 상속했더라도 `M'`, `N'`, `L'`이 나오지 않으리란 보장이 없다. 사실 둘다 다가로 나오는 함수니까. (이가라고 한정한 적 없음))

ExtenderalObjectₙ ≜ (Extenderₙ)⁻¹

ExtenderalObject는 다가함수로, M이 상속된 자식이게 하는 M₁, ..., Mₙ들의 모임 `M'`을 뱉는 다가함수로, M'이 여러개이기에, 튜플(=구조체)집합(=모임)(=M')의 집합족(M'들의 모임)으로 가는 치역을 가진다.

ExtenderObject는 결국 M을 만족시키기에, 자신을 낳을(=모델링할) 부모를 파악하는 함수이다. 또한, 

(작성중)

#### 참피상속자 ; DistunalExtenderalObject

(작성중)

#### Sector

(작성중)

#### 명제귀결 ; ProposolalConsequence

(작성중)

#### 명제귀결도입기반 구조귀결 ; ProposolalConsequenceIntroduceSystemicConsequence

(작성중)

#### 폼페이 함수 ; Pompeii

(작성중)

#### 기초적 파악

(작성중)

## NOTE

으아....
```

아직... 성에차지 않아.....

CONTEXTOUS DEQUE의 근원이 될수 있는 객체를 만들겠노라...

```
# Abstract Collection

## 2025.09.26

(주의 : 이 글에서 Abstract Collection은 스칼라가 실수 전체일수도 있음에도, 아니 사실상 기본적으로 유리수임은 깔고가는거에도 불구하고, 슬라이싱이나 인덱싱같은걸 할때, 범자연수처럼 취급합니다. 주의하세요.)

Abstract Collection이란 내가 발견한 연산인데, 나는 보통 배열류 객체를 프로그래밍의 컬렉션으로 보는 시각이 있다.

그런데 이제보니, Sequence나 Tuple이나 Vector나 공통된 추상적 속성이 있는것같다고 느끼고 발견한 추상적 객체를 지지난주쯤이 적어놨다.

처음 여러번 적다 정리한 Abstract Collection을 지난주 쯤에 완성된 서술본을 만들었고, 이번에 아예 github에 포스팅할겸 새롭게 적어놨다.

그래서 실제로 모델을 제시할때쯤 되야 이것인 그제서야 없는 대상에 대한 이상한 논의가 아니게 될것이다.

지금부터 말하는 내용들중에 근거를 찾을수 없는 내용은 전부 어쨌든 Ac의 성질에 따라 성립하는것이니,

추후에 사실상 대수구조인 모델 <Ac, -•, •[L], •[•], •[:•], •[•:], •[::•]>을 통하여 재대로 성질에 대한 공리계를 만들어 정의해야겠다고 생각한다.

어쨌든간에 나답게 맥락없이 바로 본론으로 들어가자.

Abstract Collection의 집합 Ac에 대해,

닫힌 연산인 Collection concat연산 •[•]은

∀A, B, C ∈ Ac, A[B[C]] = A[B][C] 이다.

즉, 결합법칙을 만족하므로, 반군을 이룬다.

Empty(=Blank) Collection ε에 대해,

A[ε] = A = ε[A]

즉, ε는 Collection concat연산의 항등원이다.

따라서, 반군이 항등원을 가지므로, 모노이드이다.

길이를 제는 연산은 ∀A ∈ Ac, A[L]인데, 이 연산 역시 닫혀있다.

그렇다. 보통의 연산에 대하여 A는 벡터공간을 이루므로, A[L] = 1c인 A는 Ac의 스칼라와 동형이다.

애초에 정의 자체가 SIMD연산처럼 배열간 잡연산이 처리되니 벡터공간을 이루는거지만 말이다.

중요한건 체 F위의 벡터공간은 합과 스칼라배만 정의되면 된다는거다.

스칼라 S에 대해 S¹, S², S³, ..., Sⁿ [n := ℵ₀]까지 싹다 합집합으로 묶은 백터공간인 셈이다.

정의상 벡터공간인 점에 주목해서 보자.

참고로, ε[L] = 0c이다.

참고로, 1c, 0c는 쌍대기저 c'가 A[L] = 1c인 A의 집합에서 스칼라로 가는 동형사상이므로, c' 1c = 1, c' 0c = 0인 1c, 0c이다.

그러나, Ac에서 벡터공간들의 기저공간의 기저는 차원 축에 대하여 유일하다.

그러니까, A[L] = 2c이고, 2c[L] = 1c이니, A = ac + bc₂일때, 기저 c, c₂는 2c, 1c에서 기저 c에 대해, {c}의 확장으로 {c, c₂}가 있는것으로 두 c는 같다.
그러니까, 진짜로 무한차원 벡터공간의 기저가 모든 차원을 죄다 생성한 벡터공간들의 합집합인 이 컬렉션 셋에서, 저차원의 공간은 국소적으로 축을 줄였을 뿐이지, 벡터공간을 이루게 하는 핵심 요소인 기저는 같은거다.

사실 길이가 같은 배열끼리만 벡터연산할꺼니까 달라도 되긴 하는데, 설명을 위해서 비표준적으로 같게 설정했다.

사실은 실제 정의상에서 기저는 다르다! 지금 저 "c"를 쓰고싶어서 저젛게 잡은거다. 표준적으로는 다르다.

벡터로써의 연산 *에 대해,
A, B, C = A * B에서,

first(x, y) = x
last(x, y) = y

를 정의하고,

tuple의 제귀적 정의에 따라,

first <x, y> = x
last <x, y> = y

이므로, 벡터에다가 first와 last를 적용할수 있음으로, 이를 통하여 C를 설명하겠다.

Ac에서 Vector연산은 정확히 Vectorized SIMD연산과 동형이다.

first C = (first A) * (first B)

이고

last C = (last A) * (last B)

이라는거다.

어찌보면 이쯤되면

사실상 A[L] = (dim A) c이지 않냐고 할수 있겠다.

뭐... 기저 c = 1c이므로 맞긴 하다.

그니까 이 벡터공간에서 유일하게 스칼라와 연산하는건 상수배밖에 없으며,

유일하게 길이가 다른 연산은 Ac의 고유연산이다.

행렬곱을 추가하면 되지 않느냐고 생각할수 있는데,

행렬이나 텐서를 코벡터로 취급하는 기법을 이용하여, rank-1텐서인 벡터공간 𝕍를 스칼라로 놓는다면, 그건 rank-2텐서인 행렬이고, 그걸 또 스칼라로 놓고 이런식으로 뇌절해서 구하면, 사실상 1 × n행렬, 즉 행벡터와 1 × 1행렬인 일차원 벡터를 곱하는것과 같으므로 보통을 필요성을 느끼지 못한다.
그럼에도 더 생각해보자면 결정적인 문제로, 벡터간의 곱셈은 n벡터와 n벡터사이의 상수배가 아닌 곱셈만이 정의되는데, 보통은 행렬표현을 한다면, 곱셈은 행렬곱으로 취급하므로, 행렬곱과 오인의 여지가 있기에 기호 혼용의 여지때문에 정의하기 더럽게 까다롭다.

그래서 사실 1×1행렬과 1×n행렬을 곱하는 시나리오도 같이 영원히 사요나라~ 하면서 정의하지 않은거다.

신기한걸 보여주겠다. •[L]은 다음과 같은 준동형사상이자 자기사상이다.

A[B][L] = A[L] + B[L]

그리고 영벡터들에 대해 생각해보자면,

(0A)[0B][L] = (0A)[L] + (0B)[L]

으로 자기동형사상이다.

마지막으로, functor ([L][L])는 상수함자인데,

A[L][L] = 1c이다.

그래서 지금부터 1c = codom ([L][L]) 으로 취급하겠다.

Collection reverse 연산자 -• 에 대해서, 

-(-A) = A이고 involution이다.

-(A[B]) = (-B)[-A] 를 만족한다.

(-A)[L] = A[L]이다.

Collection Slicing 연산자 •[•:]및 •[:•]및 •[::•]에 대해

A와 I[L] = A[L][L]에 대해, A[:I][L] = I이다.
또한, I ≤ A[L]일때, -(A[:I]) = (-A)[:A[L] - I]이다.

마치 처치 인코딩의 뺄셈같이 I > A[L]일때, -(A[:I]) = ε이다.

역정렬 연산자 - • 와 뺄셈을 명확히 구분하여 이해하도록 하자.

J[L] = I[L]이라면,

A[I:][J:] = A[I + J:]이고
A[:I][:J] = A[:I + J]이다.

사실상 자기사상 함자 [I:], [J:], [:I], [:J]에 대하여,

[I:][J:] = [I + J:], [:I][:J] = [:I + J]인

f(x) = [:x]혹은 f(x) = [x:]에서,

f가 f(x + y) = f(x) ◦ f(y)인 준동형사상이자 자기사상이다.

python에서 slice객체가 start:end:step순이듯, 여기서 •[::•]는 step순이다.

마치 python list x에 대해, y[n] = x[kn]인것같이 만드는것같은 심상이 든다.

A[::I][L] = k + I[L]은 A[L] ÷ I = k ••• (A[L] mod I)이듯이 k이다.

A[::I][::J] = A[::I×J]이다.

즉, [::I][::J] = [::I×J]로, 요것은 또, f(x) = [::x]일때

f가 f(I×J) = f(I) ◦ f(J)인 준동형사상이자 자기사상인것인거다.

A[I:][:I[L]] = A[:I+I[L]][I:]이다.

indexing처럼 생각하면 편하다.

[::I][J:][J[L]:] = [I×J:][:I[L]]이다.

다시한번 말하지만 마치 python list x에 대해, y[n] = x[kn]인것같이 만드는것같은 심상이 든다.

n벡터 A에 대해,

1. n + k = n
2. 0 - k = 0
3. -k = n - k
4. p × q > n이라면, p × q = n으로 한다.

라는 규칙을 추가해서, [0, n)범위의 자연수에서만 마치 셀처럼 작동하는 수 체계를 Collection Index System이라고 하겠다.

-f = (-•) ◦ f식으로 reversed연산자를 정의한 표기법을 Nero라고 하겠다. (작명은 내맘임 ㅋㅋ 검은고영이 네롴ㅋㅋㅋ Nego에서 g를 r로 바꿨다. 고양이가 연상되는게 마음에 들기 때문이... 사실은 지금 Night Dansor듣고있어서 감성이 충만해서 그런 감도 있고, 진짜로 ㄹㅇ로 작명은 완전 개썅마이웨이여서 그렇다.)

Nero와 Collection Index System에서,

-[:I] = [I:]이고,
[:I][:J] = [:I + J]이며,
[::I][::J] = [::I × J]이다.

[;]은 함자의 최초 입력을 뜻하고, [;][L]은 최초 입력의 값의 길이를 말한다.

따라서, [:[;][L]] = I이다.

사실 함자식 P에 대해, P(x)가 P([;]) [[;] := x]로 평가받는 셈이다.

나는 Collection Index System가 수직선상의 ln(x)스케일에서, 정의역을 n등분하여, 상한이 최댓값이고 그걸 n으로, 하한이 최솟값이고 그걸 0으로 하는 자연수 서수로 대응시킨 수 체계 집합같다고 느낀다.

그리고 •[•:], •[:•], •[::•], •[•], •[L]가 Collection Index System과 동형인 구석을 통해 대부분 설명된다고 본다.

아예 그냥 [X]식으로 함자를 만들면, 단항연산 •[L], (-•) 및 연산 •[•], •[:•], •[•:], •[::•]과 함자 [•], [:•], [•:], [::•]에 대하여, 동형성등 닮은구석이 많은 Collection Index System와 비교하는 방법으로 정리할수 있을것이라고 본다.

그러면 오늘은 "슬라이싱되는 무언가"에 대해, 지지난주 정도에 발견한 Ac를 적어보았다.

의사코드 예시로 python코드를 적고 끝내고싶지만 귀찮다.
(현 고딩인데 Python이 제2외국어 선택 과목인데 python을 평소에 안쓰고 공부도 전혀 안하는데 제2외국어 선택에서 저득점이아니라 만점맞고, 심지어 처음보는 라이브러리도 알아서 척척 이해할정도로 내부구조와 바이트코드 및 문서화 및 클린코드와 모듈화 및 라이브러리 제작법까지 다 아는 내가 python으로 프로그래밍하는데 어려움이 있는건 아니지만, 귀찮다고 하는건 작업이 쉬운데도 안하는것으로, 그냥 나태한거다. 돈을 굶겨봐야 정신을 차릴거다 아마도. 사실은 애니보고싶은데 동시에 작업하기는 귀찮아서 미룬거다. ~~이미 그러고 있지만~~)

나같으면 int랑 tuple을 다 상속받아서 연산을 구현한 후, ε, 0, 1은 기본적으로 클래스에서 상수처럼 가지고 있으며, __neg__에서, tuple->yield이용하거나 이터레이터 이용하여 역방향->tuple해주고, __getitem__에서 len을 받아서 len(self)해주며, 여러 연산들을 구현해야하는데, 굳이 그런 괴상한짓을 할 이유가 무엇인지 모르겠다.

개다가 젠장할, slice부분에서, 음수를 넣지 말아야하며, start, end, step부분을 각각 적절히 우리 시스템에 맞게 python타깃으로 컴파일하여, start는 길이 이상이면 ε를, end는 0이면 ε를 리턴하는 아주 개꼴받게 힘든짓을 해야한다.

결정적으로 [;]같은 노테이션이 안통하고, Collection Index System같은 경우 int비스므리한 자료구조를 하나 더 만들어야 한다.

다음번에는 그 귀찮은 과정을 직접 해와서 코드를 적을것이다.

그렇기에 마크다운에서도 `###`가 아닌 `####`로 된 곳에 날짜를 적어서 이 글을 부연설명하는 문단정도로 만들거다.

아마 곧 만들어올거다.
```

나타나라, 내 CONTEXTOUS DEQUE를 뒷받힘하는 근거 문단이여!

그는 마침내,독자가 보는 영역을 건드리는 흑마법을 쓰게 된다.

### 내가 생각하는 언어와, 그 생각의 배경

````markdown
아, 제가 독자 탐구 내용을 배경으로 깔고 이야기했네요 죄송합니다.

# 의외성 정리

## 용어 정의

 - True Mean (참뜻) : 의외성(속뜻)
 - Shell Mean (껍대기 뜻; 쉘 민) : 겉뜻
 - 속뜻 없음 (Exceptless) : Shell Mean = True Mean
 - 초완전성 (Hyper-Completeness) : "This sentence is False"를 허용하는것.
 - Black and White Proposol : ⊢ (¬Hyper-Completeness)
 - Simply Mean Proposol : ⊢ Exceptless
 - 단순언어 : Simply Mean Proposol이 항진인 언어

### 흑백논리와 형식언어의 정체에 대한 고찰

Black and White Proposol를 공리로 하는 논리를 흑백논리라고 부를수 있음이 당연하다

또한 흑백논리중 단순언어인것이 형식언어인것이라도 보면 된다.

#### 정리 문단에 따른 보조설명

우리 언어는 보이는대로 해석해야하는것과 아닌것이 있어,

보이는대로 해석해야하는것을 단순언어 (이 경우 언어 해석에 예외가 없이 보이는대로 닥치고 그뜻이다)

그리고 단순 언어가 아닌 언어 (이 경우, 언어 해석에 여러 의외성이 끼어들기에, 단순히 보이는 뜻을 뜻으로 단정할수 없다)가 있다

또한 논리는 장자철학처럼 "갓나서 죽은 아기보다 오래 산 사람은 없으니 팽조(760살이 넘게 살았다는 전설 상의 신선)도 일찍 요절한 사람이다"가 맞을수 도 있지만,

흑백논리에서는, Black and White Proposol을 참으로 하여, x이면서 동시에 x가 아닌것은 불가능하다. (Fun Fact : 흑백논리이면 단순언어임이 논리적 귀결이다)

## 공리

1. 말의 뜻은 True Mean과 Shell Mean이 있다

## 정리

### TrueMean Theroem

Hyper-Completeness 일때도 "말의 뜻 ≠ True Mean"마저 True Mean으로 True Mean(결국 전제로 한 참인 문장에서 연역(이때는 초완전땜에 가능)으로 "말의 뜻 = True Mean")이고 (Hyper-TrueMean Lemma)

Hyper-Completeness 가 아닐때도, "말의 뜻 = True Mean"이므로, 말의 뜻 = True Mean으로 (Formal-TrueMean Lemma)

말의 뜻은 True Mean을 말한다. (TrueMean Theroem)

A. Formal-TrueMean Lemma
 - ¬Hyper-Completeness, ⊭ 말의 뜻 ≠ True Mean ⊢ 말의 뜻 = True Mean

B. Hyper-TrueMean Lemma
 - Hyper-Completeness, 말의 뜻 ≠ True Mean ⊢ 말의 뜻 = True Mean

C. TrueMean Theroem
 - 말의 뜻 = True Mean

Proof)

1. 말의 뜻 ≠ True Mean [Hyp]
2. Hyper-Completeness [Hyp]
3. "말의 뜻 ≠ True Mean"라는 점도 True Mean임
[Paradoxic Lemma]
3. "말의 뜻 ≠ True Mean"라는 점도 True Mean이고 참이기에, 말의 뜻 = True Mean임
4. 말의 뜻 = True Mean

이하에서,

말의 뜻 ≠ True Mean, Hyper-Completeness ⊢ 말의 뜻 = True Mean ⋯ (1)

1. 말의 뜻 ≠ True Mean [Hyp]
2. ¬Hyper-Completeness [Hyp]
3. "말의 뜻 ≠ True Mean"라는 점도 True Mean임 [Paradoxic Lemma]
4. 모순

이하에서, ⊭ 말의 뜻 ≠ True Mean ⊢ 말의 뜻 = True Mean

(1), (2) ⊢ 말의 뜻 = True Mean

Q.E.D.

#### 해설

항상 True Mean만 말의 뜻임을 증명하자,

True Mean이 뜻이 아닌 말이 있다고 가정하자,
그렇다면 그 말은 True Mean이 뜻이 아니라는 뜻이 True Mean이 된다

이것이 Paradoxic Lemma다

이하에서 Hyper-Completeness에 따라 참인 경우와 거짓인 경우로 나누어 논증하자.



상황 1. Paradoxic Lemma에서, Hyper-Completeness인 상황

Paradoxic Lemma가 참이될수 있으므로, Hyper-TrueMean Lemma가 참이다

상황 1 종료



상황 2. Paradoxic Lemma에서, 비 Hyper-Completeness인 상황

Paradoxic Lemma이 모순이므로, 전재인 "말의 뜻 ≠ True Mean"이 거짓이다.

따라서, Formal-TrueMean Lemma가 참이다

상황 2 종료



이하에서,

상황 1, 상황2에 따라, 연역,
항상 True Mean이 말의 뜻이 된다.

따라서, TrueMean Theroem이 참이다

Q.E.D.

### Exceptless Thorem

Exceptless ⊢ 말의 뜻 = Shell Mean

Proof)

1. Exceptless [Hyp]
2. 말의 뜻 = True Mean [TrueMean Theroem]
3. Shell Mean = True Mean
4. 말의 뜻 = Shell Mean [결론]

이하에서, `Exceptless ⊢ 말의 뜻 = Shell Mean`임이 당연하다.

#### 해설

앞서 증명한 TrueMean Theroem에 따라,

말의 뜻 = True Mean

Shell Mean = True Mean 이면, 그리고 이때만 Shell Mean = True Mean이다

(쉽게말해 A = B = C니 A = C)

# 보편-개연론 (U-P(Universality - Plausibility) System)

앞으로 말하고자 할 개연성은

Logical Coherence (논리적 일관성(Logical Consistance) • 논리적 맥락성 • 논리적 개연성)

도 어느정도 맞고

Likelihood도 어느정도 맞다

그러나 Logical한 측면의 plausibility로 번역하는개 옳다.

귀납 추론을 합리화시키기 때문이다.

두 람다성 우연술어의 정의)

L♡x : L"x의 개연성이 타당하다 할만하다."

L○x : L"x는 보편적이다."

그리고 해당 언어 L은 논의 대상인 언어로써 생략하여 다음과 같이 적을수 있다.

♡x : "x의 개연성이 타당하다 할만하다."

○x : "x는 보편적이다."

개연성의 보편 원리)

"O○(♡x)"

(단. 양상논리에서 당위논리의 경우에는 `□`기호 대신 `O`기호를 쓴다는점을 기억하자.)

당위적으로, 마땅히, x 개연성이 타당하다 할만하다는 판단은 보편적이다.

즉, 개연성은 보편성을 가진다.

## 보편성

보편성은 그 언어에 속성이다.

언어가 변하므로, 보편성이 변한다.

그 사실을 알면 얼마나 언어가 많이 변하는지 세삼 체감하게 된다.

일상•사회생활을 하다보면 정말 보편이 그토록 짧은시간에 많이 변한다는걸 느끼게 된다.

다음 문장을 보자.

Φ(x) : "x는 논리적이다."

논리라는것의 실체는 x s.t. Φ(x)이다.

논리 = x s.t. Φ(x)다.

당연하다. 동명사꼴로 만들었으니까.

따라서, 논리가 성립하기 위해서는

다음 문장

"Φ(Φ(x))는 옳다"

이 옳다고 말한대로여야 한다.

즉, 언어는 논리를 가지기에, 다음이 되는거다.

Φ(x) : "x는 보편적이다"

보편 = x s.t. Φ(x)

이때,

"보편은 논리적이다"는 보편논리적으로 참이다.

즉, **논리적이라는것의 어감에 모두가 이치에 맞는것으로 동의할만한것이다**는 어감이 있다.

그게 왜 참인가?

논리 : "말이나 글에서 사고나 추리 따위를 이치에 맞게 이끌어 가는 과정이나 원리."

그렇다. 논리적이라는것이 이치에 맞으니까 그런 어감이 드는거다.

## 1. 비-예외 논리의 확장성과 그 원리

비-예외 논리에서의 확장성과 그 원리에 대해 다뤄보자.

먼저 이 글은 핵심적인 본론만은 담기 위해서 서론을 삭제하고 여러 본론들에 대한 결론으로 글을 쓰는 구조이다.

또한 글을 쓸때 있어 나는 가끔 어감에 의존하는 직관적 표현으로 논리적으로 받여질경우 그냥 그 말을 채택해서 적기에, 엄밀하지 않은 표현에 대해선 주석을 남겨놨을것이다.

사실 그런던 대게 규칙도입계 구현의 "컴펙트지지"라는 Alkalic적 논리 해석방식으로 서술되어 그러는데, Alkalic에 대해선 외부 자료이니 이 글에 대한 작성이 끝났을때 레퍼런스에 적혀있을태니 참고하라.

미안하게도 Alkalic이란 내가 만든 체계이다.

추가적으로 지적받은 점에 대해 적자면,

이 글은 수학같은 연역논증만이 참이라고 생각하는 자들이 꽤나 편협함을 깨닫게 할것이며

수학과 Alkalic에 대한 이해가 어느정도 필요하고,

공리계가 가정되지 않았는데 (공리계적인 논리에 대해) 비논리적인 대화가 되는데

그 대화가 존재하므로 공리계가 객관적인지 의문을 삼는다는점 명시해두겠다.

### 다가논리 주장명세

작성중...

새상에 참과 거짓으로 구분되는 논리가 가장 객관적이냐는 질문에,

세상에나 요즘 4차 산업혁명 시대 2025년 사람들은 정신나갈정도로 그렇다고 믿는것 같다.

다소 모호해보이는 "불가지"라는 명제에 대한 판단에 대해 사람들은 혼란스러워 하며,

고대 인도 논리학의 "참도 거짓도 아님"에 대해 모호하다 느끼며,

인류의 위대한 지성사의 자랑스러운 과거 정도로 치부한다.

심지어 Veritaserum이라는 훌륭한 과학 유튜버는,

Russel과 Whitehead의 Mathmatica Principia에 대해,

매우 정밀해서,

불분명한 Fuzzy Logic들이 머리를 감싸며 도망갈것 같다고 말하니

얼마나 개탄스럽나.

에초에 왜 그러한 수학 규칙이 참이되는지에 대해,

누군가는 "선험적인 참으로써 우리 모두가 당연히 그렇다고 받아들일 지식이기에"라고 하며
누군가는 "경험적인 근거로써 당연한 정리로써 수학에 박힌것임"이라고 말한다.

나는 그 말에 대해 그 말이 나온 시대상에 따른 안타까운 착각이라고 본다.

과연 수학이 선험이라면 왜 누구는 머리를 싸매고 왜 누구는 선천적인 지식조차 없나?

또, 모든 논리가 다 지성으로 해결될수 있어 "이성적"이며 "합리적"인 방법으로 나아가야 하니

모든 문제가 "이성적"인 방법으로 풀려야해서 "불완전성"을 무시하거나 "그럼에도 불구하고" 불완전성을 즐거워하며 동시에 불완전성이 "비이성적"이라고 해야하나?

하... 너무 화가 나서 말이 봄 공격적이었다.

그런건 이성적이지 않은건데 말이다.

"살아봤더니 새속이 좋아지더라, 혹은 연역적 논증이나 과학적 탐구가 믿을만하더라."거나

"과연 이러한 시대상에서도, 굳이 고집부려서 글을 수리논리로 부숴서 생각하길 거부할것이냐?"하는 질문에 대해서,

"그건 니 인생 경험이고, 다른 인생도 폭넓게 들어보고 살았냐? 짜샤?"라고 묻는다면 어찌할것인가?

물론 나라고 잘나지 않는다. 지금 잘난것처럼 말하는 내 말투도 크게 문제다.

내가 살아보니까 보수적인 것들도 틀리진 않았다.

언어적인 것도 충분히 논리를 가진다,

아니 그전에 논리라는것이 에초에 가정되기 이전에 성립되지 않는

그 논리라는 대상은 누가 겪어서 만들거나 가르쳐주거나 구체화되어서 있는것이지

공리계나, 타당한 발견이나, 용어정의나, 그것에 대한 사전 지식 • 사전 지식으로써의 생각한 기술적 경험 없이 과연 그런게 존재하는가?

나는 확고하게 발표한다.

언어는 철학을 가지고 그 철학의 그 윤리와 그 논리를 가진다.

그러니까 우리의 생각에서 윤리와 논리는 언젠가 필연적으로 발생한것으로 보이고,

따라서, 그런것이 존재하여 우리 사고의 근간을 이루며

생각을 초월해서 그 생각에 같혀 알을 깨지 않고 순수히

언어라는 달걀 그대로 봤을때, 당연히 생각에서 그런거 없다.

그런건 다 허상이고, 달걀 밖의 뇌절로 간 구간이다.

특히 논리에 대해서는 그것이 언어 안에 있어야 한다고 확신한다.

왜냐고? 그 주장을 뒷밭힘하는 근거로서 그 평가가 그 논리에 대한 평가가, '옳다'는 평가값이 'x는 옳다'의 존재론적 언질이기 때문이다.

논리가 언어에 의해서 생기니 수학 언어는 자만하지 말아야 한다.

바보같이 자신이 속박되어 어디선가 들고 온 정의를 숭배하는 우상숭배를 하지 말아야 한다.

### 다가논리 구체증명

언어 L에 대해 그 진리평가함수공간 Func(L*, 𝔹)이 있다면
어떤 긍정 yes에 대해, 논리적 동등 • 에 대해
(f(p • v) • yes) (단. yes ∈ 𝔹)에서,
(f(p) • v) (단. v ∈ 𝔹)로 평가될 것이고,
이러한 당연한 수학적 정리에 따라서,
다치논리를 설명하는 모형이 있기에
다치논리 이론은 타당하다.

이때 배중률을 만족하지 않는 논리는 출력값이 집합이면 되므로 그띠 𝔹는 모든 원소가 집합인 집합족이다.
따라서 그러한 경우 다가함수가 된다.
따라서, 다가함수-다치논리는 타당하다.

### 규칙도입계 주장명세

공리계라는것이 믿을만하다는건 어떻게 보일수 있을까?

왜 공리계에 기반하여 참인 명제로 증명하거나 자연연역을 통해 당연한 방법으로만 증명하는 논리가 믿을만할까?

과연 아름다운 공리계가 믿을만할까?

유클리드때부터 내려오는 정의-공리-증명 방식의 추론에서 중요한 점이 있다. 추론 규칙은 타당해야 하기에 정리여야 하므로, 공리계 기반 추론은 공리에 의존한다.

즉, 공리계 논리에 한정해서 말하자면, 논리는 공리에서 시작되며, 공리가 논리를 만든다.

예컨데 공리를 가정하지 않으면 모든 수학 체계와 그 논리를 가정할 필요가 없어진다.

공리 없이는 논리도 없다. 따라서 공리시스템에 있어 절대적인 세팅값인 공리는, 그 시스템의 규칙이다.

공리는 받아들이지 않아도 무방하다. 논리는 전부가 이니고, 논리는 멍청한 공리라는 가정이기 때문이다.

따라서, 이 규칙에 따른 결과로써 논리가 나오는것이지, (참고로 지금은 공리시스템의 논리를 논하고 있음) 논리는 절대로 객관적인 대상이 아닌것이다!

물론 수학 언어가 논리를 만드니 맞냐고 치면, 연역적인 수학 언어는 경험론적 전체론에 따른 연역적 정의와 출발이 막힘에 따라, 완전히 연역적인 수학이란 존재할수가 없게 된다.

따라서, 이러한 문제를 해결하기 위해, 언어 수준에서 절대적 시작점으로, 그 역사와 무관히 정의하여 강제한 논리가 바로, 공리인것이다.

이러한 규칙이 공리적 학문을 만들고,

규칙 없이는 아무 (공리적) 논리를 작성할수 없는것이다.

따라서, 이러한 공리계를 분석하기 위해서, 규칙도입계를 구성하고 실험하여 얻은 경험으로 완전히 연역적인 시도를 할수 있으며,

이는 궁극적으로 형식과학인 수학의 탐구방법과 일치하고,

규칙도입계 상에서 실험된 성질이 바로 규칙도입계-공리계의 성질인것이다.

애기들이 장난으로 규칙도입계용 공리계를 만든다 하여도 절대로 그것을 비판할수 없다

너무 당연하다.

왜냐하면, 그 어린아이의 규칙 도입계용 공리나 수학 공리나 다 멍청한 주장이자 가정이며 (공리적) 논리라는 이름을 뒤집어쓴 주장이다.

완전 개찐도찐이다.

규칙 도입계는 필연이다.

그렇다면 어떻게 규칙을 도입하는 체계를 만들까?

간단하다! 규칙을 설정하고 그게 참이 되는 논리적 논의 영역이 규칙도입계다.

에초에 이 개념은 어린 아이의 규칙놀이와 공리계의 차이를 논하려 만들었지만, 지금은 그런 시시콜콜하고 멍청한 짓은 관심이 없다. 그런걸 구분하는건 멍청한 대중이나 하는것 같다. (대중이 멍청하다는 말은 아니다. 인스타나 이런데에 가끔식 멍청이들이 좀 있다.)

### 규칙도입계 구체명세

규칙도입계란 관계열 Eₖ에 대해 k-tuple (t₁, ..., tₖ)에 대해, Eₖ(t₁, ..., tₖ)가 참이라면 E₍ₖ₋₁₎(t₁, ..., t₍ₖ₋₁₎)이 참이고, E₂(t₁, tₖ)가 참이며 E₂(x, y)란 x = y일때 참인 동등관계열 Eₖ에 대해, rule의 U를 딴 관계열 Uₖ에 대해, 컴펙트 지지인 Uₖ의 정의역이 Eₖ이고 (단. 이 해설은 엄밀하진 않은게, Uₖ가 Eₖ에 포함된다 보는게 맞다. "컴펙트 지지인 Uₖ의 정의역이 Eₖ이고"는 엄밀하지 않다.) Uₖ(t₁, ..., tₖ)가 참이라면, U₍ₖ₋₁₎(t₁, ..., t₍ₖ₋₁₎)이 참이며 술어형 관계 U₁(x)가 참이려면 x가 참이여야한다. rule의 L을 딴 관계열 Lₖ에 대해, Lₖ(Lang, t₁, ..., tₖ) : Lang"U(t₁, ..., tₖ)" 인 Lang어 술어이므로, 자연어 술어여서 술어논리에서는 우연명제이다.

규칙도입계-공리계란 다음을 말한다.
"규칙도입계 공리계에서 참의 정의는 Lₖ가 항진인, 즉 Lₖ가 참이다"라는 정의의다.
엄밀한 표현으론, T = Lₖ이며, 정의로 적어놓은 사실상의 공리이다.
단. 이 내용은 공리이므로 정의하는데 있어서 경험적인 내용이 아니라고 가정되는 방식이다.

이 공리계는 내 이론을 검증하기 위해 만든 도구일 뿐이다.

## 우연양화논리론 구체명세 : 양화논리는 우연명제에 대한 회피기제를 가진다.

이제부터 문자열 변수를 쉽게 쓰는 표기법으로, "○"를 도입하겠다. 문자열 집합 타입의 문자열로써 쓰려니까 존나 힘들어서 x라고 표기하기보다, "○"라고 표기하는게 나을것같다.
에잇 에초에 수학자들처럼 표기하는거니까 뭐!

그렇게 되면 배중(률을 만족하는 언)어 L에 대해, 크립틱(S, L)이 잘 정의된다. 크립틱(Kriptic)이란 이름의 명명에는 크립키 모형같다는 비유법에 있다.

배중어(L) : "L ⊨ 배중률"
크립틱("○", L) : L"○"

그러면 다음을 알 수 있다.

자연어 L = 한국어 일때,

내가지금먹고싶은거(x) : L"x는 필자가 지금(2025.Aug.08 18:02)먹고싶은 음식이다"

내가지금먹고싶은거는 우연명제이다.

참고로 내가지금먹고싶은거는 L"불고기 뺀 콤비네이션 마르게리따 피자"다.

아 쓰다가 이미 18:03이 됬으니 어떻게 펙트다 ㅋㅋ

저런식으로 어떤 고지식한 사람이 "난 이것만 먹을꺼야"라고 할때 그 음식 고르는것에 대해,
명제이지만 우연명제가 존재하여 잘 정의할수 있다는, 잘 정의된다고 취급하는것에 대한 문제에 대한 비판을, 고지식한 사람의 음식리스트 비유라고 한다.

내가 만든 비판이다. (내가 자기 주관이 강하긴 하다만 고지식한 사람의 음식리스트 비유만큼 고지식하진 않다... 나는 변덕도 심하기 때문이다... 내가 말한 고지식한 사람은 그걸 절대 안바꾸거나 주어진 시간동안 바꿀 가능성같은건 없는 가상의 존재를 상정한거라서, 지독하게 고지식하다는 점.)

이런식으로 정언논리상의 우연명제를 양화논리로 옮겼을때, 그 우연논리는 논리식을 쓰지 않는 한 험밀하지 않은 임시적이거나 비표준적인 방법이고, 불가피한 경우에도 처치-튜링 명제 이외에 잘 사용되지 않는 방식이다.

이러한 우연명제의 사용이 가능한데 실재로 사용시에는 이것을 회피하길 마련이다.

이것은 양화논리의 Ridiculous한 회피기제다.

참고로 배중률을 거부하는 경우에는 그것에 대한 판단 언어는 필연적으로 존재하므로 (왜냐하면 방정식의 경우 해가 두가지라서 배중률을 거부하며, 이러한 경우에도 수학은 판단 가능하단건 어떤 함수로 모뮬화된 튜링완전적 혹은 비결정추상언어적 술어 Φ에 대해, Φ(x) : P(x) = 0인 방정식은 Alkalic에서 증명했든 타당히 이것이 명제와 언어의 성질을 가지는 논리 판단에 대한 의미론적 동등을 통한 당연한 본질에 대한 한가지 해석이라는 사실에 근거하기에, 그 배중율을 거부해도 수학은 판딘 가능하단게 당연하다.)

아, 참고로, 술어논리는 술어에 자연어를 적을수 있지만 권장되지 않는다. 재대로 정의되기 위해서다.
얼마나 이상한가?... 잘 정의되지 않을거면 그 명제를 없에야하는데... 그러나 수리논리는 수학의 전유물이 아니기에, 아리스토텔레스를 탓할수밖에 없다.
에초에 그런걸 정의할수 있게 논리학을 만들었으니 토달지 말아야한다.

### 우연양화론적 양상논리구현론 : 크립키 모형을 통한 형식적 양상논리의 우연양화논리론적 접근 a.k.a. 양상논리의 기괴성

다음 술어를 보라.

P(v) : ◇v
Q(v) : "v일수 있다"

만약 Q의 언어가 양상논리라면 P = Q이다.

그러면 Q의 언어가 양상논리랑 상호번역되는 언어인 경우

Φ = P = Q 로 정의하겠다.

그러면 다가논리 주장명세에서, "언어는 철학을 가지고 그 철학의 그 윤리와 그 논리를 가진다"는 명제에 대해, "그 주장을 뒷밭힘하는 근거로서 그 평가가 그 논리에 대한 평가가, '옳다'는 평가값이 'x는 옳다'의 존재론적 언질이기 때문이다"라는 말을 달았는데,

이는 형식언어를 통해서 곧 말할 많은 방법을 통해 잘 정의된 자연어 혹은 언어 L에 대해, 그 우연양화논리적 해석에 있어서, 존재할수밖에 없는 "지옥"같은 상황에 빠진다.

즉, 언어 L은 UG에 의해 해석되기에 모든 수학 외 언어는 자연어니, 이러한 자연어 우연명제를 UG때문에 막을수도 없는데, 기괴한 양상논리의 존재성은 이 우연명제의 이용으로써 나타나므로 필연(항진 정리)이다.

에초에 그거에 맞는 언어적 모델을 구축하는건 식은죽먹기다.

## 우연양화논리론 구체구현

Necesurry(x) : □x : ModalLogicTranslatibleLanguage"x는 필연이다 : ¬◇¬x
Necesurization(x) : Theorem(x), x ⊢ □x
Able(x) : ◇x : ModalLogicTranslatibleLanguage"x일수 있다."

따라서 규칙도입계-공리계를 도입하면 이는 참임을 알 수 있다.

에초에 규칙도입계를 수학에서 쓰려면, 크립키-모델을 이용하기 위해 양상논리를 활용하면 된다.

### 결론

UG의 존재와 규칙도입언어의 특성과 수학에서 서술할수 있는 언어평가의 특성에 의해 필연적으로 양상논리같은 비표준 논리도 "언어는 철학을 가지고 그 철학의 그 윤리와 그 논리를 가진다"는 명제에 대해, "그 주장을 뒷밭힘하는 근거로서 그 평가가 그 논리에 대한 평가가, '옳다'는 평가값이 'x는 옳다'의 존재론적 언질이기 때문이다"라는 표준수리논리에만 적용되는줄 알았던 명제가 그 확장으로 언어에 대해 존재할수밖에 없고 이는 언어에 창발성에 기인한다.

## 2. 예외 논리의 구성가능성과 그 무한한 구조

어떤 무언가를 서술하는 글이 담긴 책이 있다 하자.
그 글에 대해 참으로 두고 그것에 대해 설명한다면,
그 글에 대해 거짓으로 두고 그것에 대해서도 설명해야한다.

한마디로 그 대상에 대해서 언어로써 전달 가능한 생각으로써
기능할 조건을 그 글에 요구한다면
필연적으로 그 글은 변별력을 필요로 한다.

따라서, 모든 언어적인 단순무식한 생각과 그 "주장함"(주장하는 행위)는 변별이라는 방법으로 구성할수 있으며,

이러한 측면에서 예외에 대해 서술하는것도 당언히 가능하다.

예외라는 측면에서 언어에 대해 변별한다면, 필요 이상으로 논리적인 생각이겠지만,

빈틈없는 주장으로써는 훌륭한 방법이고 선대의 지혜로써 고안된 추론방법이다.

물론 그 추론 방법은 지금에 이르러 완전히 폐기하고 뉘앙스만 언어화되어 이용되어 독립되게 만들어 그 원인을 잊고 눈을 가리비만 말이다.

어떤 참으로 말하는 AFFRIMO(긍정)적인 대상을 논리적으로 설명하는 빈틈없는 오랜 고민끝에 나오는 생각으로 ontological한 뉘앙스의 주장으로 새우고,
어떤 거짓으로 말하는 NEGO(부정)적인 대상을 예외적으로 매꿔주는 완성까지 있다면,

그건 휼륭한 어떤 질문에 대한 대답 규칙체계를 만든것이고 아주 잘 만들어진 노력의 산물일것이다.

내 말은, 이런게 일반적이므로 있고, 더 나아가,

이러한 명쾌한 이분 체계에 대한 해설로써 긍정 존재를 강제해주고 부정 예외를 추가해주는 구조를 만들수 있으며,

그것이 왜 수학도들도 타당하다 받아들여야 하는지 말하고자 하는거다.

### 존재강제구조 주장명세

존재강제구조란 논의계층 h와 그 아래의 계층 aₕ에 대해,
aₕ의 결함이 h로 전달되는걸 "반역"이라 명명할때 반역되지 않으며,
h가 일반으로써 설정되는것을 말한다.

우리 언어이 변별과 일반 구조에 의해서, 아무리 엄밀한 체계라도, 예외를 이용하여 서술하는 아이디어를 피할 수 없으며, 이를 보이지 않게 녹이는 수학같은 방법도 존재한다.

따라서 이러한 예외도 타당한 논리다.

심지어 기호증명용으로 구성도 되는 구체적이고 규칙적이고 엄밀한 체계다.

### 존재강제구조 구체구현

어떤 존재론적 언질적 존재를 만들어주는,
즉, 어떤 성질에 대한 한정까지 포함한 존재를 민즉어주는것.

먼저 ∃Φ(x)와 ∃x s.t. Φ(x)의 의미를 보자. 참고로 두가지는 같은 의미다.

항진술어 T에 대해서도, 함축기호 • 에 대해,

(∃Φ(x))(T(x))라는 말은 곧 (∃x s.t. Φ(x))(T(x)) 이며, (∃x)(Φ(x) • T(x)) 이므로, (∃x)(Φ(x) • T(x))이니 특히 이경우 (∃x)(Φ(x))라고 잡힌것이다.

자, 저 논리식의 의미를 봤으니,
이제 저런 가정을 하는것에 대한 서술로 존재론적 언질적 존재를 만들어주는 존재성애 대한 논의의 기호적 표기를 쉽게 이해할 수 있을것이다.

이런 존재를 설정해주는 공간으로써 높은 위계와 그것에 대한 응용 공간의로써 낮은 위계로,
논리에 그 위와 아래가 있다면, 계층적으로 예외를 이용한 논리의 서술의 일관성 문제가 해결될것이다!

존재를 설정해주는 공간을 어쨋든간에 절대적으로 존재하게 강제한점에서 기묘하고 신묘하다는 의미에서 실존에 비유하여, 실존공간이라 하고 h라 하겠다.
그리고 그 실존공간 h에 대해, 논리적으로 논의하는 그 논리에서의 논의공간, 즉 현실인 a를 aₕ라고 하겠다.

h와 aₕ의 정의는

V(∃Φ(x), h) → V(∃Φ(x), aₕ)

이며, 이를 계층 관계라고 한다.

논리에 있어 배중률이 없는 언어가 있을수 있다는것은 이미 이야기했으니 배경지식으로 탑제하고 태클걸지않고 갈수있다는건 당연하게 알것을 선언하겠다.

 h 규칙도입계(참고로, 규칙도입계로 동작하는 이유는 그 언어의 공리계가 생겼다면 그런거라 지금 서술 방식을 규칙도입계처럼 다루는거여서 그렇지, 규칙도입계라는 표현은 엄밀하지 않고, 논의계층이라는 말이 엄밀히다) 논리에 대해 aₕ 규칙도입계는 h에서 한 선언을 부정하여 h를 바꾸는 "반역"을 할 수 없으며 aₕ에 대해 선언은 h가 해줘서 제어 가능하고 자신은 결과를 받지 않지만,
aₕ에서는 스스로 예외규칙을 만들어 h에는 "반역"하지 않고 독자적으로 예외가 발생할 수 있다.

이처럼 예외를 가지는 언어는 계층을 가지고, 무한한 예외규칙의 경우, 계층은 무한하게 되어 구성된다.

# [referance : alkalic](https://faraway6834.github.io/unbeauty/privateNote/Alkali/alkali)

Tip : 컴펙트지지란, 해석학(수학)에서, 따로 정의하지 않는 구역에서 0이 되는 함수를 "컴펙트지지"라고 부르며, Alkalic에서 정의시 자주 활용한다. 바로 분기문을 컴펙트 지지 기반으로 만든다.
Tip : 위 팁은 수학을 즐기는 사람이면 누구나 이해하니 읽을 필요가 없다. 그래서 이런 하단 팁에 적어논것.

---

최근엔 저는 "보편과 특수"는 존재강제구조의 대표적인 동형을 이루는 구조로, 보편은 ♡(♡x ↔ x)로, 만물의 공통적 이상 (ideal) 새계이며, 특수가 차이점 새계로, 보편-특수, 공통-차이, 규칙-변칙같은 대조되는 요론 개념들은 존재강제구조와 동형인 구조로, 형이상학적 이상인 보편, 공통, 규칙이 존재새계 최상위로, 반대되는 예외인, 특수, 차이, 변칙이 현실새계 최하위로, 이러한 "보편적 사고 공간"이라는 이상적 공간 U_G에서, 크립키 모형 상에서, ♡Φ : V(U_G , Φ)이고, 개연성 ♧는 우리 사고를 지배하는 Meme이 규정한 참인 공간 U_M에서, ♧Φ : V(U_M, Φ)인것으로, ♡(♧Φ → ♡Φ)로 보편은 개연성에 친화적인 태도를 보이며, 보편 역시 하나의 Meme으로, 이러한 Meme에 의한 의미 규정에 의해 많은 비형식적 논리가 구현된다고 봅니다.
````

그리고

````markdown
# 형식논리언어와 논리의 괴리

읽어보기 전에

 + 이 글에서는 형식적인 사고는 기호의 조작일뿐이지, 논리는 logical cohereance에서 온다고 보았다.
 + 뇌과학적으로 logical cohereance를 관장하는 DLPFC없이 기저핵•측두엽•후두엽을 이용해 DLPFC없이 형식적으로 사고하는 나에게서 형식논리언어와 논리의 괴리를 찾아서 적어보았다.


표준국어대사전에 이렇게 나와있다.
```
논리 (論理) 「명사」 「1」 말이나 글에서 사고나 추리 따위를 이치에 맞게 이끌어 가는 과정이나 원리.
```

그뿐이다.

<br>

...

<br>

이제 글을 시작해 보겠다.

<br>

<br>

...

<br>

<br>

<br>

<br>

『형식논리언어는 그 언어적 사고를 하는데 있어, logical cohereance에 의존하지 않으니, logical cohereance에서 파생됬다고 보기 어렵다.』

형식논리상에서 긍정자 ♤와 일반적인 언어에서의 긍정자 ♠︎를 가정하자.

♤x : x ↔ T
♠︎x : (대충 x를 긍정하는 뜻)

나는 형식논리언어로 논리구문을 처리하기 때문에, 축소주의적 진리론을 당연하다고 착각하고 살았다.

자, 단순무식하게 새가지 펙트를 짚고 가자.

♤(x = y)

이때 x를 y로 해석해도 됨은 당연하다.

♠︎("미친놈아 참 잘하는짓이다" = "미친놈이 한 행위는 잘한 행위이다")

이것은 바보같은 해석이다. 형식문법리 아닌 속뜻과 맥락을 통한 해석이 있어야 한다.

여기서 먼저, 형식언어는 속뜻 = 겉뜻인 특성이 있어서, 그 의미론을 속뜻으로 파악하는 순간, 공리계 혹은 이론 T가 M ⊨ T인 M들에 의해 기계적으로 변환되는 대수적 사고방식으로 돌아간다는걸 알수있다.

Q1 : ♤(A가 B를 죽였다 → A는 마땅히 징역 5년을 구형받아야 한다.)가 맞나?

Q2 : ♠︎(A가 B를 죽였다 → A는 마땅히 징역 5년을 구형받아야 한다.)가 맞나?

두가지 문장 Q1, Q2는 다르다. 전자는 참일지 모르지만 후자는 맥락상 참이다. 그 이유는 전자는 가능새계에 구애받는데, 저것이 성립하는 가능세계인 「보편•사회문화맥락적 진리론」은 기본적으로 언어를 통한 사고에 깔려있기 때문이다.

우리는 여기서 형식언어가 「보편•사회문화맥락적 진리론」에 무관하다는 사실도 알 수 있다.

Q1 : ♤(A or B라면 마땅히 포함적이다)가 맞나?

Q2 : ♠︎(A or B라면 마땅히 포함적이다)가 맞나?

두가지 문장 Q1, Q2는 진리값이 다르다. Q1은 참이고 Q2는 반례를 "평생치킨 안먹기 또는 평생김치 안먹기 둘중 하나를 해야 살려주겠다"에서 "아니 두게다 안하게 해버릴수 있는 선택치를 주겠다고요? 이 나쁜놈아!"라고 할수 없는것같은 맥락에서, "또는"이 반례로 작용한다. Q2는 거짓이다.

참고로, Q1, Q2로 예시를 든 문장들은 「보편•사회문화맥락적 진리론」새계와 논리 구문 설명 예시에서, 각각 대한민국 형법과 양자택일의 상황 강요라는 부적절한 예시가 있었지만, 증명이 아닌 설명문이기에 굳이 수정할 이유가 없어보이니 넘어가자.

일단 마지막 예시를 보면 형식언어를 자연어로 번역하여 해석했을때, 형식언어로 사고했는지와 자연어로 사고했는지가 다르다.

콰인의 번역 불가능성 원리를 아는가?

> 
> "형식언어는 형식적으로 규정되는거지, 그 의미론은 형식적인 긍정자 ♤를 제외한 자연어로 규정되지 아니한다."
> 

이 문장은 번역 불가능성 정리에 의해 당연하다.

> 
> "언어 L에서 문장 Φ의 진리값은 L위에서 L의 단어로 평가된다."
> 

그렇다. 형식언어에서는 진리가 정의가 불가능하기에 절대적인 요소 ♤를 통하여 진리를 부여 가능하다.
그리고 ♤의 서술에는 ♤가 쓰인다. 즉, 올바른 설명이 아니다.

공리계인것이다.

공리계는 해당 공리계 내에서 설명 불가능하다. 어떤 설명문으로 설명하든지간에 그 근거가 될 수 없기 때문이다. 그것은 어떤 이유에서 참이지 않고 이유없이 참이기 때문리다.

따라서,

> 
> "진리 이외에 것들중에 공리계와 정의를 이론 T라고 하자. 이론 T가 형식적이면 진리는 형식적이지 않고 진리가 형식적이면 이론 T가 형식적이지 않다."
> 
> "이론 T가 형식적이지 아니하면, 그것은 형식언어가 아니다"
> 
> "따라서 이론 T는 형식적이여야 한다. 뭐... 그러나 미래에 형식언어의 정의가 바뀐다면 그렇지 아니할수도 있다... 아니 정확히 그렇지 아니할거다. 정의가 바뀐 미래에는"
> 

따라서 『형식논리는 **논리가 아니라 형식이다.**』

아스퍼거인인 나는 DLPFC를 통한 실행능력(계획•실행•사회적 사고)이 결핍되었기 때문에, 형식으로 사고한다.

그게 정말 논리적인 사고였으면 참 좋았을텐데, DLPFC라는 논리처리 프로세서를 쓰지않은 논리적 처리에서 나는 그저,

1. 몽상을 한다. 비논리적인 상태에서 증명에 로드맵을 짠다.
2. 해당 로드맵이 추론에 적합한지 형식논리를 통해 검토한다.
3. 형식논리적으로 기호를 조작한다.

순서로 사고한다.

그리고 【형식적이지 않고 진짜로 참된 관점에서의 논리적으로 일관된(logical cohereance를 가지는)】 논리는 이치에 맞아야 한다. 형식논리의 의미론(semmentics)는 언어 개임일 뿐이고,
그 이치가 구문론적인 언어 L위에서 T가 동작하기에 lang에 의해 의미론(semmentics)가 부여되어 「인간 사고」로 동작하는것이지, 인간사고이기 이전에 생각도 언어도 뭣도 의미도 아닌 형식일 뿐이다.

따라서 형식논리는 자연어의 논리와 다른 개념의 논리이다.

나는 지금까지 논리적인 구석 없이 (나는 어재까지는 DLPFC가 무력화되도 논리라고 보았으나, DLPFC에 의존하지 않고 맥락을 무시해서 생각했다는 점, 즉, 맥락없는 기호의 조작은 논리라고 보기 어렵기 때문에 지금은 논리적인 구석 하나 없었다는걸 느낀다.) 기계적으로 펙트만 뱉은 일개 어리석은 이(HOL이라는 논리의 탈을 쓴 집합론, 즉, 모델론이라는 집합론적 틀에 Zhegalkin계산만 조금 곁들어서 논리라고 착각하니, 어리석은 이라고 했다)였을 뿐이지, 절대로 형식논리를 통하여 논리적일수 없다.

그것(내가 형식적으로 사고하는것)이 논리적이라고 평가받는다면, 그건 사회적인 보편에 의해 "논리적임"이 부여된것 뿐이다. 그런평가는 아무래도 상관없다. 기분만 좋아지지 학교에서 날 논리적이라고 평가하는 사람은 없다.

대학갈때도 당연히 불리하다. 형식논리는 대학교 가서 시간날때 취미로 배우는게 맞다, 즐거워 보이는것에 이면에는 결국 패턴놀이라는 진실이 있었다.

학교에서는, 당연히 교육심리학에서 맥락과 사회적 적용에서 논리를 판단할텐데, 나는 그것에 대해 말도안된다, bullshit이다 라고 생각했지만, 교육심리학에서 맥락과 사회적 적용에서 논리를 판단하는것은 bullshit이 아니라 오히려 매우 타당한, 논리적 사고의 측정법이였으며, 실제로 논리적이지 않은것은, "형식"이라는 단어를 제외한 형식논리의 정의 자체인 형식이었다.

형식논리는 형식을 통해 정의된 논리인데, 메타논리 없이 사실은 자연어에서 "형식"이라는 단어를 통해 논리가 전달된다.

"형식"이라는 맥락 하에서만 논리를 한다는건, 사실 맥락을 읽을필요 없다는 맥락하에서만 논리를 한다는거다.
````

그리고,

````
# 수용 (acceptance)

형식언어 L에서 형식화된 표기법 • 모델을 통한 정의는 그 구문론이 모호하지 않으면, 구문론적으로 타당하고, 그 의미론이 폭발하지 않거나 그 의미론이 폭발함을 반증할수 없다면, 의미론적으로 타당하거나, 아니면 새 공리를 도입하는 해당 공리의 긍정에 대한 케이스를 다루는것으로 취급할 수 있다.
형식언어에서 언어의 창발성은 자신과 호환되는 언어를 자신이 수용(acceptance)하는데서 온다. (예외 : 교과과정)

따라서 나는 다음 ASCII문자열로 작성된 수용기호를 제안한다.

1. acept [Base64]
2. acept *.txt
3. acept [uri]
4. acept [uri] *.txt

1. 1번이 바로 수용기호의 정의이고, 
2. 2번은 전산환경에서 동일 디렉토리의 ASCII Base64 텍스트 파일로 자동검증할수 있을것으로 그 문맥을, 형식증명언어의 추론규칙 검증 튜링기계의 몫으로 명확히 규정한 interface이므로, (근데 이건 진짜로 위험하게도 튜링기계 재량이다.) 생략법으로 도입한 정의며?
3. 3번은 uri로 참고하겠다는 소리인데, 만약 저 uri가 "고정됨"을 담보하지 않는다면, 모호성을 가지므로, 예도 위험해서,
4. 4번은 그걸 ASCII Base64 txt 파일로 저장하겠다는 소리이다. SSL을 보통 "신용"을 담보할수 있다고 하는데, 그것도 못빋으면 4번 쓰면 된다. (함정은 OS같은 튜링기계도 못믿는 사람이 나타나면, OS를 acept [Base64]를 쓰고 너무 글자가 기니 표준으로 박자는 사람이 나올지도 모른다는것)

그래서 모든 텍스트와 심지어 텍스트 파일 및 웹도 MIME타입이 텍스트이며, 인코딩이 ASCII인데 Base64를 통해서 다른 인코딩 등등의 정보를 저장 가능하기에, ASCII txt파일 기표 주제에 쓸만한 문서로 작동할수 있다.

사실.... 그냥 zip아카이브를 디렉토리로 하면 모든 문제가 말끔히 해결되고 일관된 형식도 가능하긴 하다

## 구문론적 정의에 대하여

≡ₛ 는 유니코드로 문서를 작성하는 한계로, 전용 기표가 없기에, 구문론적 등호 기호로 쓰겠디.

≝ₛ 는 유니코드로 문서를 작성하는 한계로, 전용 기표가 없기에, 구문론적 정의 기호로 쓰겠다.

<br>

구문론적 등호 A ≡ₛ B와 구문론적 정의 A ≝ₛ B에 있어서,

(임의의 문자열 A, B에 대해)

Φ : "A ≝ₛ B"

라 하면,

Φ를 만족하는 문자열들에 대해, 위에 명시한 구문론적 등호가 Φ과 동치임은 당연하게 알 수 있다, 

그러므로, 술어화된 문장

"A ≝ₛ B"

에서,

"A ≝ₛ B" : 각각의symbol들 ∈ 그symbol의StringSet으로써regex에서_켑쳐에_대응

식으로, 정의할 수 있음을 알 수 있다.

## 의미론적인 "규정"에 대하여

정의(definition)나 할당(assignment, 대부분 대입을 변수 선언에 쓰기에, 대입을 할당의 의미로 쓰는경우가 많다)은 비변수기호의 모델 M내에서의 규정이거나, (변수나 비변수의)  동일자로써의 값을 M에 "규정"될수 있으므로, 구문의 타당성이 그 모델의 언어가 형식언어가 아닐 정도의 모호성(Ambiguity)을 가지는지 유무로, 없으면 타당한걸로 결정된다.

또한 어떤 헝식언어에서 특정 모델 M의 언어 L이나 걍 다른 형식문법 G의 언어 L을 수용했을때, "폭발원리에 의해 폭발"하지 않으면, 의미적으로도 타당하다.

## 그렇다면 공리같은 참은 뭔가?

참이라고 규정되서나 판단되는것은, 논증에서 가설 H로 삼을수 있으며 (건전한 추론의 조건), 그 진리값이 T니 그 언어에서 "H"를 "T"로 평가할 수 있고,

그러므로! 어떤 "Φ"를 공리로 규정한 언어의 lang(랑그)가 하는, T(참)으로 평가되는 해석은,

그 평가가 이루어지는 기표와 기의의 연결이 본질적으로 형식적 규칙놀음과 동일자로 이루어지는 것 뿐이므로, 일부 AC같은 예시를 보아하면, 일관성을 증명할 수 없을수도 있음을 알 수 있다.

그러므로, 항진이 아닌 수학적 서술은 규정되야 항진일 가능성이 생기므로,

우리는 형식언어 L이 권위같은거 없고 언어의 자의성으로 연결됬음에 근거하여, 사용가능함이 증명된 L의 공리•모델•문법에 "근거"하여, 그 구문의 validity와 의미론적 해석늬 validity를 쓴다.

## 나는 과감히 이렇게 말할수 있다.

"형식체계는 권위에 관심없다. 형식체계를 받아들일 근거에 모호한 권위나 권위적인 사회성을 우기지 말자."

## 참고

아래 내용을 참고하라.

```markdown
# 형식논리의 고정성

"형식논리의 평가는 유동적이지 않다"는건 참이다!

모두가 인정하고 부르짖는 참이다.

그러니 그 광기어린 부르짖음을 잠시 멈춰보고, 듣어보자.

형식논리와 형식언어는 "형식언어 L은 고정된 평가를 가진다"는 이데올로기이다.

단언컨데, 내가 사랑하는 수학은 그런 이데올로기다.

## "고정됨(fixed)"


"고정됨(fixed)"의 반댓말로 유동적임을 들수 있다.

언어는 유동적이라는건 펙트로 볼 수 있다.

수학언어도 많이 변해왔다

....

그러나 우리 수학언어, 형식언어는 고정되어있다.

"형식언어 L의 평가는 고정됨(fiexd)"

L이 형식언어라는것은 그 평가가 고정됬다고 우리가 정의한거다.

모호함이나 속뜻을 가짐 혹은 유동적임이 더 일반적으로 언어에서 통용되는 "만물의 공통적•일반적 속성"의 종류로써 그 언어에 특징임을 우리는 알고있다.

그리고 사실 단 하나로 정리된다.

1. "형식언어 L의 평가는 고정됨(fiexd)"은 증명없이 받아들여지는 fact이다.
2. 그러한 맥락과 배경에서 논의가 이뤄졌던것이다.
3. 보편적 meme이고 이데올로기인거다.

수식같은 형식언어의 기표를 어린아이에게 설명한다고 필연적으로 "언어에 사회성을 통해서 이 meme이 형식언어라는 틀로 분류됬으니까, 이 아이는, 수학은 유동적인 이상한게 아니라고 생각할꺼야"라고 하는 추측이 맞을까?

아니, 그 순수한 아이가 그럴거란 보장이 없다.

왜냐하면, "형식언어 L의 평가는 고정됨(fiexd)"이라는 전제를 깔아줘야하는데, 그렇지 아니하였기 때문이다.

그러므로, "형식언어 L의 평가는 고정됨(fiexd)"이라고 앞으로 내가 단언하는데는 우리가 형식언어라고 약속한것들의 사회성으로써, 고정됨에서 오니까, 그렇게 하는걸로 치겠다.
```

---

## 번외, 블렉유머 :「상식」을 주입하기 위해서 「교과」라는 경전을 기록하는 사제들은 **불가피하게도**

아니 ㅋㅋㅋ 당연히.... "모범풀이"라는 "기본상식"에 해당되는 Algorithm몇게 가르쳐주는거지.

고등학교 나온 수학과 지망생이 "응애 나 방정식도 모르고 최소공베수도 어려워" 이지랄이면, 기본 상식이 안된거야.

<<〔보편 상식〕을 배울 교육권의 영역을 지키기 위해서, 학교수학은 acept를 금지하는 도덕적으로 당연한 부분에, 도덕따위에 수학이 희생되었다. >>

그리고... 학교수학은 교과서가 허용하는 이상으로 adept를 금지하기에, 공짜로 집합과 함수를 교육과정 내에 넣어줘서, 람다산술을 정의하고싶어도 하지 못하게한다는 블렉코미디 ㅠㅠ
문제풀이 난이도는 새로운 심볼에 값을 할당해서 함수나 관계를 만들거나 집합론이나 대학교 해석학 수준으로 내면서 모범답안에는 정신나갈정도로 긴 케이스 풀이에 암산까지 요하면서 되도않는 풀이과정의 정신나간 모범풀이법들의 조합으로 상상을 아득히 초월하는 기묘한 풀이법으로 전개햐서 답안을 내놓는 불수능이라.... 오라 달콤한 지옥이여 ㅠㅠ

기호가 금지된 기호교육이여....

그러나 그 안에서도 본질을 깨닫는 영재가 나오지.

영제들은 그러나 본질은 끝까지 찾아내지, 문제를 존나풀다보니, "아아... 선대들이 「정의」라는걸 하지 않았으면 이런 풀이나 연산에 명칭이 붙지 않았을텐데 왜 이러한 성질이나 페턴을 기호화한거지? 내가 춘 65536개의 유형들에서 젘부 그런거 보니 역시 수학의 본질은 문제풀이를 기호놀음화하는건가보다... 더 문제를 풀어서 더 많은 유형을 익혀서 16384개정도 더 풀면 똑똑한 나는 존나 정신나갈정도로 숨겨진 패턴을 번뜩히는 뇌로 찾을 지능을 갗췄지"하면서 입시용 모범답안이나 뒤지는 셈이지

그러나, 나는 영재가 아니라 일게 일탈자, 열등생이요, 놀아서 배운 형식언어는 나에게 가장 즐기는 게임이요.

물론 나는 프로그래밍하다가 우연히 형식논리 교과서를 만나고 인터넷으로 배우다보니 독학해서, 독감으로 앓아누어서 ADHD증상으로 산만해져셔 히죽거리다 눈감고 이불덮고 있을때도, 머릿속으로 기호가 조작되는 수준으로 개념학습과 형식언어를 Educational Programming Lanuage인 엔트리를 5년, Programming Lanauge인 Python을 5년, Lambda Calculus및 기계어 및 형식언어이론을 반년동안 한시간도 빠짐없이 하루에 75%를 빠짐없이 소모, 그 이후로 할일이 아닌 생명유지에 필요없는 모든 행동은 기호논리로 보내다 보니까, 어느세,

"대체 왜 공리계따위를 밎지? 연역적 근거는?"

"데체 왜 형식논리따위를 밎어? 어 불완전성의 정리?"

"대체 왜 형식언어를 숭배해? 어? 언어게임이론?"

이러고있다...

그리고 선생님께 물었지

"풀이 답란에 함수 정의해서 푸는게 빠를것같은데요."

"교과과정에서는 「정의」를 막아놨다고요 ㅠㅠ, 그러니까 하지 마. 정답으로 체점해줄수 없어"라고 선생님이 답하고 느꼈지.

"아아... 교과과정이라는 형식언어는 「정의」라는 개념이 없고 경전.. 아니 <교과>를 따르는구나"

그러므로, 이것을 만드는데 기여한분은, 문제풀이에 "개념정의"를하는 행위가 감점행위니 하지않는걸 권장하신 선생님이지.

아아, 대체 왜 「상식」을 배워야 합니까?

그 이유는 간단해. 내가 보수 수구 꼴통인 우익진영이니까 크하하핳

(이 번외 단락은 이 문서를 작성한 배경지식으로써, acept의 부재가 있는 언어를 만난 경험을 쓴 유머글입니다. 읽지마세요.)

그리고...

"사회의 보편•일반적 기본상식에 해당하는 문제풀이 algorithm을 배우는것이 중점이기에 acapt를 막아놓은 자연어로 해설하는 형식의 형식논리언어다"는걸 생각해보면...

난 비판할 권리가 없긴함.

기본상식 가르친다고 떠들어대는데 가서 "본질"을 부르짖는 맥락없는 미친소리는 다들 무서워서 피하거든.

광인에게 비판할 권리가 없거든.

모범생이 아닌사람에게 비판할 권리가 없거든.

교육진영에 몸담지 않고서야, 자신들의 불가피한 선택을 비판하면 안되거든.
````

그리고,

````
# 주장의 명제 긍정기능 (현제 작성 진행중이고 다 끝나지 않음)

우리는 평소에

대화 1
A : 지금까지 너는 버거만 먹을꺼니 오늘도 버거를 먹을거다
B : 응 아니다. 국밥먹으러 가고있다.

대화 2
A : wir müssen wissen, wir werden wissen
B : Nein!!! 모르는것도 충분히 존재한다.

이런식으로 긍정•부정을 하는 말하기를 하고 산다.
사실 상황 자체거 제 0 맥락으로 파악하거나, 0번째 전에 기본적으로 깔고가는 맥락도 있다.
그리고 이러한 맥락은 주장의 명제 증명기능에서 나온다.

우리들이 말하는데 있어서 긍정문은 반박되기도 한다.

그러나 그것은 일게 ♠︎¬Φ에 불과하다.

중요한건, 생각은 스스로 변형될수 있으며, 특정 조건 하에서 전해질수 있다.
또한 생각은 인간 사고의 틀로 동작할수 있으며,
인간 사고의 메커니즘(작동기전)이 사고다.

우리가 이성적인 예측을 할때 크게,

사회적인 계체군에서 살아남기 위함이 있어,

1. 상황•맥락 파악 ; 현제 상태 파악
2. 이성적 계획•실행 ; 지능적 행동을 위해서 정밀하게 준비하고 총쏘듯 행동하기

방식으로 진행될것이다.

당연히 이성적 행위와 실행은 현실이라는 맥락이 반영되고

【상황은 현실을 반영한다.】

상황•맥락이 바로 이때 논리적인 부분이 된다.

그러하여, 논리에서는 ♠︎을 이용한 추론이 있다.

지난번에 우리는 ♤와 ♠︎를 [형식논리언어와 논리의 괴리](./형식논리언어와_논리의_괴리)라는 제목으로 다루었었다.

그래서 이제 맥락이 뭔지 알아보자.

## 밈의 명제 긍정기능

이야기하기 앞서, 보편에 대해 알아보자. 이것 역시 밈으로 설명 가능하다.

보편과 비슷한 어떤 구조들은 특정 밈의 구조이다.

집단 S에 대해, S내의 대상 X애 대해, Φ(X)가 통용되면 공통점이고, 그렇지 아니하여 구별되면 차이점임을 알 수 있다.
그리하여, 공통점과 차이점의 서술은 보편의 색채와 특수의 색채를 가지고,
이 서술을 [규칙]-[예외(=변칙)] 구조라고 볼 수 있다.

만물에 통용되는 일반적이고 추상적인 속성이 보편이다.

따라서, ♡x : "보편적으로 x임" 이라고 했을때, 혹은 ♡x : "일반적으로 x임"이라고 했을때,

♡(♡x ↔ x)인 성질이 일반에서 가지며, 이 성질이 그대로 보편에서도 가져지며,

보편에서는 그 성질이 만족되는 대상이 집단 S에 대해 "S가 일반적으로 x"임에서 "만물이 일반적으로 x"이게 된다.

일반적인 성격은 예외라기보다 규칙에 가깝다.
또한 일반적인 성격은 공통적인 성격이다.

그렇다. 일반-특수 관계 역시 각각 보편의 색체와 특수의 색체를 가진다.

이는 존재강제구조의 핵심적 메커니즘이다.

존재강제구조에서, 반역이란, 어떤 논리계 X, Y에 대해, X에서 발생한 논리적 오류값이 Y에 전파되는것으로,

Y에서의 논리적 오류 ⊥에 대하여,

V(Φ, Y) = ⊥인 Φ에 대해, 

V((Φ, Ψ → Φ), X) → V(Ψ, Y)

인 오류가 일어나는게 반역이다.

그런데, 이런 오류 전파구조를 하나의 수리논리적 성질로 보고, 이것을 허용시키지 않으면, 규칙-변칙구조가 된다.

한마디로, 예외규칙에 대해 부정적인 스탠스 • 방어기제같은 스텐스를 취하는 규칙-변칙 논리구조에서, 명제 Φ를 적용하는 모양세의 차이가 있을 뿐이지, 동일한 논리구조를 이루고, 이를 규칙-변칙구조라고 한다.

자, 그럼 이 이야기를 왜 했을까?

meme이나 meme-plex라고 해서 달라질게 없기 때문이다.

보편이라는 논리를 여기서 설명할수 있기 때문이라는거다.

그러면, 앞서 설명한 보편이 왜 meme에서 나오는지 보자.

밈도 기능을 가진다. 그리고 그 기능은 분명이 다음과 같이 작동할수밖에 없을것이다. 이제부터 핵심 주장을 시작하겠다.

첫번째, 보편을 meme에서 사용할수 있고, 그 근거로 실제로 존재한다는 존제성을, 사례로 제시한다.

성경 출애굽기 20장 1~17절이 십계명이라고 하는데

8. 안식일을 기억하여 거룩하게 지켜라.
12. 너희는 부모를 공경하여라. 그래야 너희는 너희 하느님 야훼께서 주신 땅에서 오래 살 것이다.
13. 살인하지 못한다.
14. 간음하지 못한다.
15. 도둑질하지 못한다.
16. 이웃에게 불리한 거짓 증언을 못한다.
17. 네 이웃의 집을 탐내지 못한다. 네 이웃의 아내나 남종이나 여종이나 소나 나귀 할 것 없이 네 이웃의 소유는 무엇이든지 탐내지 못한다."

위의 7가지 종교적인 말들은 보편이다. 펙트다.
심지어 문화다.

제시가 되었다. 보편이 사용하는 규칙-에외 구조가 실제로 사용된 예시라고 할 수 있다.

물론 부분적으로 가져와서 설명이 정확하지 않고, 후에 이 설명 전체를 엄밀히 고칠 필요가 있다.

또한 『Meme은 명제를 긍정할수 있어, 어떤 Meme은 명제를 긍정한다.』

동일하게 어떤 Meme이 명제를 긍정한다는 예시를 가져오면 그만이다.

모순론의 예시를 보자.

아, 참고로 왜 사회주의사상을 가져오냐면 괭장히 인상깊은 논리전개여서 그렇다.

나는 정작 보수주의자에 반공사상을 따르는 사람에 가깝고, 사회주의 사상의 논리적인 부분을 발췌해오는것이기에, 특정 사상을 개인에게 강요할 의사가 없음을 밝힌다.

나무위키를 스크랩한 예문을 보자.

```
1 한 사회구성체에 적대적 모순으로서 ‘프롤레타리아와 부르주아 사이의 계급투쟁’이 존재할 수 있는 객관적 토대가 최소의 수준에서라도 마련이 되어있는가?
 + 아니오 → 1-1 적대적 모순으로서 ‘프롤레타리아와 부르주아 사이의 계급투쟁’이 존재할 수 있는 객관적 토대가 존재하지 않는다면 자본주의에 대항하는 의미로서의 계급투쟁은 불가능하다.
 + 예 → 1-2 그렇다면, 그것이 직접적인 의미에서 충분히 프롤레타리아와 부르주아 사이의 대결로 표상될 수 있는가?
    - 아니오 → 1-2-1 프롤레타리아와 부르주아 사이의 직접적인 대결이 표상되지 않다는 것은 해당 사회구성체의 모순은 다양한 의식성(意識性)의 중첩으로 인해 그 양태(様態)가 다양해졌다는 것이다. 따라서 다양한 계층 사이에서 매개 정합(整合)에 기초한 변증 투쟁을 이어나가야 한다.
    - 예 → 1-2-2 이는 프롤레타리아와 부르주아 사이의 직접적인 대결이 표상된 것이므로 전적으로 노동계급에 의거하여 변증투쟁을 전개해야 한다.
```

위의 진술이 명제들과 그 추론으로 이루어졌다는 사실을 알 수 있다.

고전논리적으로•양상논리적으로•양화논리적으로 환원되는 서술들을 빼고 어휘들을 보면

1-1에서, "**적대적 모순**으로서 ‘프롤레타리아와 부르주아 사이의 **계급투쟁**’", "**객관적 토대**", "자본주의에 대항하는 의미로서의 **계급투쟁**"등지의 단어가 객관적인 (이치에 맞는) 논리 전개를 위하여, 이미 쓰이는 용어들을 사용했음을 알 수 있다.

뭐... 에초애 나는 그러한 모순점들에서 보수적인 면을 따르는게 기존에 규정된 도덕에 맞다고 봐서 반대하긴 하는데, 그런 사실만 봐도, 내가 가진 반공이념과 모순론이 동일한 대상에 대해 다르게 규정한다는 사실을 알수있고, 두가지 다 이데올로기로써, Meme임도 당연하다.

다음 쳅터에서는 이러한 부분이 근본적으로 "Meme에 의해 Meme에 숙주가 주장한것"인 속성임을 알수 있으니, 얼른 다음 쳅터로 넘어가도록 하자.

## 주장의 명제 긍정기능

(작성중...)

## 부가적으로 알수있는 사실

그래서 이상의 내용에서 부가적으로 알수있는 사실은,

따라서 DLPFC를 사용하는 참된 논리라는것은, 일개 기호 조작에서 나오는게 아니라, 사전적으로 logical cohereance에서 오는데, 그러한 논리는 주장이나 Meme에 의해 긍정되어 규정되는것듯이 많고, 우리가 긍정문을 씀으로써 긍정하는 측면에서 파생되는 논리는, 이러한 모두가 인정하는 주장이나 Meme에서 그동안 파생되어왔음을 알 수 있고

따라서 『논리라는것은 상대적이고, 그 이유를 이분법적이고 형식적으로 해명할수 없는 속성과, 맞다고 규정할수 있음의 속성을 동시에 가진다.』

## referance (내가 만든거)

 + [비결정성 추상어](./temp)

```
## 1. 비-예외 논리의 확장성과 그 원리

비-예외 논리에서의 확장성과 그 원리에 대해 다뤄보자.

먼저 이 글은 핵심적인 본론만은 담기 위해서 서론을 삭제하고 여러 본론들에 대한 결론으로 글을 쓰는 구조이다.

또한 글을 쓸때 있어 나는 가끔 어감에 의존하는 직관적 표현으로 논리적으로 받여질경우 그냥 그 말을 채택해서 적기에, 엄밀하지 않은 표현에 대해선 주석을 남겨놨을것이다.

사실 그런던 대게 규칙도입계 구현의 "컴펙트지지"라는 Alkalic적 논리 해석방식으로 서술되어 그러는데, Alkalic에 대해선 외부 자료이니 이 글에 대한 작성이 끝났을때 레퍼런스에 적혀있을태니 참고하라.

미안하게도 Alkalic이란 내가 만든 체계이다.

추가적으로 지적받은 점에 대해 적자면,

이 글은 수학같은 연역논증만이 참이라고 생각하는 자들이 꽤나 편협함을 깨닫게 할것이며

수학과 Alkalic에 대한 이해가 어느정도 필요하고,

공리계가 가정되지 않았는데 (공리계적인 논리에 대해) 비논리적인 대화가 되는데

그 대화가 존재하므로 공리계가 객관적인지 의문을 삼는다는점 명시해두겠다.

### 다가논리 주장명세

작성중...

새상에 참과 거짓으로 구분되는 논리가 가장 객관적이냐는 질문에,

세상에나 요즘 4차 산업혁명 시대 2025년 사람들은 정신나갈정도로 그렇다고 믿는것 같다.

다소 모호해보이는 "불가지"라는 명제에 대한 판단에 대해 사람들은 혼란스러워 하며,

고대 인도 논리학의 "참도 거짓도 아님"에 대해 모호하다 느끼며,

인류의 위대한 지성사의 자랑스러운 과거 정도로 치부한다.

심지어 Veritaserum이라는 훌륭한 과학 유튜버는,

Russel과 Whitehead의 Mathmatica Principia에 대해,

매우 정밀해서,

불분명한 Fuzzy Logic들이 머리를 감싸며 도망갈것 같다고 말하니

얼마나 개탄스럽나.

에초에 왜 그러한 수학 규칙이 참이되는지에 대해,

누군가는 "선험적인 참으로써 우리 모두가 당연히 그렇다고 받아들일 지식이기에"라고 하며
누군가는 "경험적인 근거로써 당연한 정리로써 수학에 박힌것임"이라고 말한다.

나는 그 말에 대해 그 말이 나온 시대상에 따른 안타까운 착각이라고 본다.

과연 수학이 선험이라면 왜 누구는 머리를 싸매고 왜 누구는 선천적인 지식조차 없나?

또, 모든 논리가 다 지성으로 해결될수 있어 "이성적"이며 "합리적"인 방법으로 나아가야 하니

모든 문제가 "이성적"인 방법으로 풀려야해서 "불완전성"을 무시하거나 "그럼에도 불구하고" 불완전성을 즐거워하며 동시에 불완전성이 "비이성적"이라고 해야하나?

하... 너무 화가 나서 말이 봄 공격적이었다.

그런건 이성적이지 않은건데 말이다.

"살아봤더니 새속이 좋아지더라, 혹은 연역적 논증이나 과학적 탐구가 믿을만하더라."거나

"과연 이러한 시대상에서도, 굳이 고집부려서 글을 수리논리로 부숴서 생각하길 거부할것이냐?"하는 질문에 대해서,

"그건 니 인생 경험이고, 다른 인생도 폭넓게 들어보고 살았냐? 짜샤?"라고 묻는다면 어찌할것인가?

물론 나라고 잘나지 않는다. 지금 잘난것처럼 말하는 내 말투도 크게 문제다.

내가 살아보니까 보수적인 것들도 틀리진 않았다.

언어적인 것도 충분히 논리를 가진다,

아니 그전에 논리라는것이 에초에 가정되기 이전에 성립되지 않는

그 논리라는 대상은 누가 겪어서 만들거나 가르쳐주거나 구체화되어서 있는것이지

공리계나, 타당한 발견이나, 용어정의나, 그것에 대한 사전 지식 • 사전 지식으로써의 생각한 기술적 경험 없이 과연 그런게 존재하는가?

나는 확고하게 발표한다.

언어는 철학을 가지고 그 철학의 그 윤리와 그 논리를 가진다.

그러니까 우리의 생각에서 윤리와 논리는 언젠가 필연적으로 발생한것으로 보이고,

따라서, 그런것이 존재하여 우리 사고의 근간을 이루며

생각을 초월해서 그 생각에 같혀 알을 깨지 않고 순수히

언어라는 달걀 그대로 봤을때, 당연히 생각에서 그런거 없다.

그런건 다 허상이고, 달걀 밖의 뇌절로 간 구간이다.

특히 논리에 대해서는 그것이 언어 안에 있어야 한다고 확신한다.

왜냐고? 그 주장을 뒷밭힘하는 근거로서 그 평가가 그 논리에 대한 평가가, '옳다'는 평가값이 'x는 옳다'의 존재론적 언질이기 때문이다.

논리가 언어에 의해서 생기니 수학 언어는 자만하지 말아야 한다.

바보같이 자신이 속박되어 어디선가 들고 온 정의를 숭배하는 우상숭배를 하지 말아야 한다.

### 다가논리 구체증명

언어 L에 대해 그 진리평가함수공간 Func(L*, 𝔹)이 있다면
어떤 긍정 yes에 대해, 논리적 동등 • 에 대해
(f(p • v) • yes) (단. yes ∈ 𝔹)에서,
(f(p) • v) (단. v ∈ 𝔹)로 평가될 것이고,
이러한 당연한 수학적 정리에 따라서,
다치논리를 설명하는 모형이 있기에
다치논리 이론은 타당하다.

이때 배중률을 만족하지 않는 논리는 출력값이 집합이면 되므로 그띠 𝔹는 모든 원소가 집합인 집합족이다.
따라서 그러한 경우 다가함수가 된다.
따라서, 다가함수-다치논리는 타당하다.

### 규칙도입계 주장명세

공리계라는것이 믿을만하다는건 어떻게 보일수 있을까?

왜 공리계에 기반하여 참인 명제로 증명하거나 자연연역을 통해 당연한 방법으로만 증명하는 논리가 믿을만할까?

과연 아름다운 공리계가 믿을만할까?

유클리드때부터 내려오는 정의-공리-증명 방식의 추론에서 중요한 점이 있다. 추론 규칙은 타당해야 하기에 정리여야 하므로, 공리계 기반 추론은 공리에 의존한다.

즉, 공리계 논리에 한정해서 말하자면, 논리는 공리에서 시작되며, 공리가 논리를 만든다.

예컨데 공리를 가정하지 않으면 모든 수학 체계와 그 논리를 가정할 필요가 없어진다.

공리 없이는 논리도 없다. 따라서 공리시스템에 있어 절대적인 세팅값인 공리는, 그 시스템의 규칙이다.

공리는 받아들이지 않아도 무방하다. 논리는 전부가 이니고, 논리는 멍청한 공리라는 가정이기 때문이다.

따라서, 이 규칙에 따른 결과로써 논리가 나오는것이지, (참고로 지금은 공리시스템의 논리를 논하고 있음) 논리는 절대로 객관적인 대상이 아닌것이다!

물론 수학 언어가 논리를 만드니 맞냐고 치면, 연역적인 수학 언어는 경험론적 전체론에 따른 연역적 정의와 출발이 막힘에 따라, 완전히 연역적인 수학이란 존재할수가 없게 된다.

따라서, 이러한 문제를 해결하기 위해, 언어 수준에서 절대적 시작점으로, 그 역사와 무관히 정의하여 강제한 논리가 바로, 공리인것이다.

이러한 규칙이 공리적 학문을 만들고,

규칙 없이는 아무 (공리적) 논리를 작성할수 없는것이다.

따라서, 이러한 공리계를 분석하기 위해서, 규칙도입계를 구성하고 실험하여 얻은 경험으로 완전히 연역적인 시도를 할수 있으며,

이는 궁극적으로 형식과학인 수학의 탐구방법과 일치하고,

규칙도입계 상에서 실험된 성질이 바로 규칙도입계-공리계의 성질인것이다.

애기들이 장난으로 규칙도입계용 공리계를 만든다 하여도 절대로 그것을 비판할수 없다

너무 당연하다.

왜냐하면, 그 어린아이의 규칙 도입계용 공리나 수학 공리나 다 멍청한 주장이자 가정이며 (공리적) 논리라는 이름을 뒤집어쓴 주장이다.

완전 개찐도찐이다.

규칙 도입계는 필연이다.

그렇다면 어떻게 규칙을 도입하는 체계를 만들까?

간단하다! 규칙을 설정하고 그게 참이 되는 논리적 논의 영역이 규칙도입계다.

에초에 이 개념은 어린 아이의 규칙놀이와 공리계의 차이를 논하려 만들었지만, 지금은 그런 시시콜콜하고 멍청한 짓은 관심이 없다. 그런걸 구분하는건 멍청한 대중이나 하는것 같다. (대중이 멍청하다는 말은 아니다. 인스타나 이런데에 가끔식 멍청이들이 좀 있다.)

### 규칙도입계 구체명세

규칙도입계란 관계열 Eₖ에 대해 k-tuple (t₁, ..., tₖ)에 대해, Eₖ(t₁, ..., tₖ)가 참이라면 E₍ₖ₋₁₎(t₁, ..., t₍ₖ₋₁₎)이 참이고, E₂(t₁, tₖ)가 참이며 E₂(x, y)란 x = y일때 참인 동등관계열 Eₖ에 대해, rule의 U를 딴 관계열 Uₖ에 대해, 컴펙트 지지인 Uₖ의 정의역이 Eₖ이고 (단. 이 해설은 엄밀하진 않은게, Uₖ가 Eₖ에 포함된다 보는게 맞다. "컴펙트 지지인 Uₖ의 정의역이 Eₖ이고"는 엄밀하지 않다.) Uₖ(t₁, ..., tₖ)가 참이라면, U₍ₖ₋₁₎(t₁, ..., t₍ₖ₋₁₎)이 참이며 술어형 관계 U₁(x)가 참이려면 x가 참이여야한다. rule의 L을 딴 관계열 Lₖ에 대해, Lₖ(Lang, t₁, ..., tₖ) : Lang"U(t₁, ..., tₖ)" 인 Lang어 술어이므로, 자연어 술어여서 술어논리에서는 우연명제이다.

규칙도입계-공리계란 다음을 말한다.
"규칙도입계 공리계에서 참의 정의는 Lₖ가 항진인, 즉 Lₖ가 참이다"라는 정의의다.
엄밀한 표현으론, T = Lₖ이며, 정의로 적어놓은 사실상의 공리이다.
단. 이 내용은 공리이므로 정의하는데 있어서 경험적인 내용이 아니라고 가정되는 방식이다.

이 공리계는 내 이론을 검증하기 위해 만든 도구일 뿐이다.

## 우연양화논리론 구체명세 : 양화논리는 우연명제에 대한 회피기제를 가진다.

이제부터 문자열 변수를 쉽게 쓰는 표기법으로, "○"를 도입하겠다. 문자열 집합 타입의 문자열로써 쓰려니까 존나 힘들어서 x라고 표기하기보다, "○"라고 표기하는게 나을것같다.
에잇 에초에 수학자들처럼 표기하는거니까 뭐!

그렇게 되면 배중(률을 만족하는 언)어 L에 대해, 크립틱(S, L)이 잘 정의된다. 크립틱(Kriptic)이란 이름의 명명에는 크립키 모형같다는 비유법에 있다.

배중어(L) : "L ⊨ 배중률"
크립틱("○", L) : L"○"

그러면 다음을 알 수 있다.

자연어 L = 한국어 일때,

내가지금먹고싶은거(x) : L"x는 필자가 지금(2025.Aug.08 18:02)먹고싶은 음식이다"

내가지금먹고싶은거는 우연명제이다.

참고로 내가지금먹고싶은거는 L"불고기 뺀 콤비네이션 마르게리따 피자"다.

아 쓰다가 이미 18:03이 됬으니 어떻게 펙트다 ㅋㅋ

저런식으로 어떤 고지식한 사람이 "난 이것만 먹을꺼야"라고 할때 그 음식 고르는것에 대해,
명제이지만 우연명제가 존재하여 잘 정의할수 있다는, 잘 정의된다고 취급하는것에 대한 문제에 대한 비판을, 고지식한 사람의 음식리스트 비유라고 한다.

내가 만든 비판이다. (내가 자기 주관이 강하긴 하다만 고지식한 사람의 음식리스트 비유만큼 고지식하진 않다... 나는 변덕도 심하기 때문이다... 내가 말한 고지식한 사람은 그걸 절대 안바꾸거나 주어진 시간동안 바꿀 가능성같은건 없는 가상의 존재를 상정한거라서, 지독하게 고지식하다는 점.)

이런식으로 정언논리상의 우연명제를 양화논리로 옮겼을때, 그 우연논리는 논리식을 쓰지 않는 한 험밀하지 않은 임시적이거나 비표준적인 방법이고, 불가피한 경우에도 처치-튜링 명제 이외에 잘 사용되지 않는 방식이다.

이러한 우연명제의 사용이 가능한데 실재로 사용시에는 이것을 회피하길 마련이다.

이것은 양화논리의 Ridiculous한 회피기제다.

참고로 배중률을 거부하는 경우에는 그것에 대한 판단 언어는 필연적으로 존재하므로 (왜냐하면 방정식의 경우 해가 두가지라서 배중률을 거부하며, 이러한 경우에도 수학은 판단 가능하단건 어떤 함수로 모뮬화된 튜링완전적 혹은 비결정추상언어적 술어 Φ에 대해, Φ(x) : P(x) = 0인 방정식은 Alkalic에서 증명했든 타당히 이것이 명제와 언어의 성질을 가지는 논리 판단에 대한 의미론적 동등을 통한 당연한 본질에 대한 한가지 해석이라는 사실에 근거하기에, 그 배중율을 거부해도 수학은 판딘 가능하단게 당연하다.)

아, 참고로, 술어논리는 술어에 자연어를 적을수 있지만 권장되지 않는다. 재대로 정의되기 위해서다.
얼마나 이상한가?... 잘 정의되지 않을거면 그 명제를 없에야하는데... 그러나 수리논리는 수학의 전유물이 아니기에, 아리스토텔레스를 탓할수밖에 없다.
에초에 그런걸 정의할수 있게 논리학을 만들었으니 토달지 말아야한다.

### 우연양화론적 양상논리구현론 : 크립키 모형을 통한 형식적 양상논리의 우연양화논리론적 접근 a.k.a. 양상논리의 기괴성

다음 술어를 보라.

P(v) : ◇v
Q(v) : "v일수 있다"

만약 Q의 언어가 양상논리라면 P = Q이다.

그러면 Q의 언어가 양상논리랑 상호번역되는 언어인 경우

Φ = P = Q 로 정의하겠다.

그러면 다가논리 주장명세에서, "언어는 철학을 가지고 그 철학의 그 윤리와 그 논리를 가진다"는 명제에 대해, "그 주장을 뒷밭힘하는 근거로서 그 평가가 그 논리에 대한 평가가, '옳다'는 평가값이 'x는 옳다'의 존재론적 언질이기 때문이다"라는 말을 달았는데,

이는 형식언어를 통해서 곧 말할 많은 방법을 통해 잘 정의된 자연어 혹은 언어 L에 대해, 그 우연양화논리적 해석에 있어서, 존재할수밖에 없는 "지옥"같은 상황에 빠진다.

즉, 언어 L은 UG에 의해 해석되기에 모든 수학 외 언어는 자연어니, 이러한 자연어 우연명제를 UG때문에 막을수도 없는데, 기괴한 양상논리의 존재성은 이 우연명제의 이용으로써 나타나므로 필연(항진 정리)이다.

에초에 그거에 맞는 언어적 모델을 구축하는건 식은죽먹기다.

## 우연양화논리론 구체구현

Necesurry(x) : □x : ModalLogicTranslatibleLanguage"x는 필연이다 : ¬◇¬x
Necesurization(x) : Theorem(x), x ⊢ □x
Able(x) : ◇x : ModalLogicTranslatibleLanguage"x일수 있다."

따라서 규칙도입계-공리계를 도입하면 이는 참임을 알 수 있다.

에초에 규칙도입계를 수학에서 쓰려면, 크립키-모델을 이용하기 위해 양상논리를 활용하면 된다.

### 결론

UG의 존재와 규칙도입언어의 특성과 수학에서 서술할수 있는 언어평가의 특성에 의해 필연적으로 양상논리같은 비표준 논리도 "언어는 철학을 가지고 그 철학의 그 윤리와 그 논리를 가진다"는 명제에 대해, "그 주장을 뒷밭힘하는 근거로서 그 평가가 그 논리에 대한 평가가, '옳다'는 평가값이 'x는 옳다'의 존재론적 언질이기 때문이다"라는 표준수리논리에만 적용되는줄 알았던 명제가 그 확장으로 언어에 대해 존재할수밖에 없고 이는 언어에 창발성에 기인한다.

## 2. 예외 논리의 구성가능성과 그 무한한 구조

어떤 무언가를 서술하는 글이 담긴 책이 있다 하자.
그 글에 대해 참으로 두고 그것에 대해 설명한다면,
그 글에 대해 거짓으로 두고 그것에 대해서도 설명해야한다.

한마디로 그 대상에 대해서 언어로써 전달 가능한 생각으로써
기능할 조건을 그 글에 요구한다면
필연적으로 그 글은 변별력을 필요로 한다.

따라서, 모든 언어적인 단순무식한 생각과 그 "주장함"(주장하는 행위)는 변별이라는 방법으로 구성할수 있으며,

이러한 측면에서 예외에 대해 서술하는것도 당언히 가능하다.

예외라는 측면에서 언어에 대해 변별한다면, 필요 이상으로 논리적인 생각이겠지만,

빈틈없는 주장으로써는 훌륭한 방법이고 선대의 지혜로써 고안된 추론방법이다.

물론 그 추론 방법은 지금에 이르러 완전히 폐기하고 뉘앙스만 언어화되어 이용되어 독립되게 만들어 그 원인을 잊고 눈을 가리비만 말이다.

어떤 참으로 말하는 AFFRIMO(긍정)적인 대상을 논리적으로 설명하는 빈틈없는 오랜 고민끝에 나오는 생각으로 ontological한 뉘앙스의 주장으로 새우고,
어떤 거짓으로 말하는 NEGO(부정)적인 대상을 예외적으로 매꿔주는 완성까지 있다면,

그건 휼륭한 어떤 질문에 대한 대답 규칙체계를 만든것이고 아주 잘 만들어진 노력의 산물일것이다.

내 말은, 이런게 일반적이므로 있고, 더 나아가,

이러한 명쾌한 이분 체계에 대한 해설로써 긍정 존재를 강제해주고 부정 예외를 추가해주는 구조를 만들수 있으며,

그것이 왜 수학도들도 타당하다 받아들여야 하는지 말하고자 하는거다.

### 존재강제구조 주장명세

존재강제구조란 논의계층 h와 그 아래의 계층 aₕ에 대해,
aₕ의 결함이 h로 전달되는걸 "반역"이라 명명할때 반역되지 않으며,
h가 일반으로써 설정되는것을 말한다.

우리 언어이 변별과 일반 구조에 의해서, 아무리 엄밀한 체계라도, 예외를 이용하여 서술하는 아이디어를 피할 수 없으며, 이를 보이지 않게 녹이는 수학같은 방법도 존재한다.

따라서 이러한 예외도 타당한 논리다.

심지어 기호증명용으로 구성도 되는 구체적이고 규칙적이고 엄밀한 체계다.

### 존재강제구조 구체구현

어떤 존재론적 언질적 존재를 만들어주는,
즉, 어떤 성질에 대한 한정까지 포함한 존재를 민즉어주는것.

먼저 ∃Φ(x)와 ∃x s.t. Φ(x)의 의미를 보자. 참고로 두가지는 같은 의미다.

항진술어 T에 대해서도, 함축기호 • 에 대해,

(∃Φ(x))(T(x))라는 말은 곧 (∃x s.t. Φ(x))(T(x)) 이며, (∃x)(Φ(x) • T(x)) 이므로, (∃x)(Φ(x) • T(x))이니 특히 이경우 (∃x)(Φ(x))라고 잡힌것이다.

자, 저 논리식의 의미를 봤으니,
이제 저런 가정을 하는것에 대한 서술로 존재론적 언질적 존재를 만들어주는 존재성애 대한 논의의 기호적 표기를 쉽게 이해할 수 있을것이다.

이런 존재를 설정해주는 공간으로써 높은 위계와 그것에 대한 응용 공간의로써 낮은 위계로,
논리에 그 위와 아래가 있다면, 계층적으로 예외를 이용한 논리의 서술의 일관성 문제가 해결될것이다!

존재를 설정해주는 공간을 어쨋든간에 절대적으로 존재하게 강제한점에서 기묘하고 신묘하다는 의미에서 실존에 비유하여, 실존공간이라 하고 h라 하겠다.
그리고 그 실존공간 h에 대해, 논리적으로 논의하는 그 논리에서의 논의공간, 즉 현실인 a를 aₕ라고 하겠다.

h와 aₕ의 정의는

V(∃Φ(x), h) → V(∃Φ(x), aₕ)

이며, 이를 계층 관계라고 한다.

논리에 있어 배중률이 없는 언어가 있을수 있다는것은 이미 이야기했으니 배경지식으로 탑제하고 태클걸지않고 갈수있다는건 당연하게 알것을 선언하겠다.

 h 규칙도입계(참고로, 규칙도입계로 동작하는 이유는 그 언어의 공리계가 생겼다면 그런거라 지금 서술 방식을 규칙도입계처럼 다루는거여서 그렇지, 규칙도입계라는 표현은 엄밀하지 않고, 논의계층이라는 말이 엄밀히다) 논리에 대해 aₕ 규칙도입계는 h에서 한 선언을 부정하여 h를 바꾸는 "반역"을 할 수 없으며 aₕ에 대해 선언은 h가 해줘서 제어 가능하고 자신은 결과를 받지 않지만,
aₕ에서는 스스로 예외규칙을 만들어 h에는 "반역"하지 않고 독자적으로 예외가 발생할 수 있다.

이처럼 예외를 가지는 언어는 계층을 가지고, 무한한 예외규칙의 경우, 계층은 무한하게 되어 구성된다.

## 뭐쓸지 까먹은 목차 작성중 ...
```
````

## 디아볼리카의 등장...

"후후후, 리넉스여 그대도 결국 흑마법을 썼구려..."

"흥! 자네같은 물신주의에 지지 않을걸세"


이 둘은 대립을 새우기 시작햇다.

"뜨아아, 리넉스 대마법사와 디아볼리카가 나타났다..."



"

> 
> *아직 이번 장은 작성중임...*
> 