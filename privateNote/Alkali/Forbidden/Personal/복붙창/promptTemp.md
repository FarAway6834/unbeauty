# 비결정성 추상어

## 비결정성 추상어 논의

### 초기

```
# 어떤 언어에서 존재론적 언질의 응용가능성은 비결정성 추상의 활용가능성을 불러일으킨다.

조어 "비결정성 추상어"란 비결정성 추상의 활용 가능성을 가지는 언어인데, 예컨데 수학이나 그것보다 높은 자연어는 비결정성 추상어다.

"먹는 것"이 음식이므로, "먹다" 알고리즘과, "A 인지 판단하다" 알고리즘에서, "먹는것 인가요?"라는 말은 "먹다"에 대한 존재론적 언질이 되는 대상을 언급하며,
단어활용능력(조어력과 서술력이 창발적이라 충분히(=보편적인 언어와 「상호서술가능」한 언어 『주석임, 참고 : A』) 언어를 서술할수 있는 능력을 일컽는 내가 만든 조어)을 가짐을 알 수 있다.

참고로 말하겠다.
1. 비결정성 추상어는 추상의 활용 가능성을 가지는 언어라고 정의했다.
2. 비결정성 추상의 활용 가능성 만족의 필요충분조건은 단어활용능력의 만족이다.
3. 따라서 비결정성 추상의 활용 가능성의 만족에 대해서도 이미 잘 정의되었으니 이쯤에서 비결정성 추상어를 이해하지 못할리는 없다고 생각한다. (왜냐하면 이미 참고로 말하기 전에 힌트를 다 줬고 그걸 또 설명했기에 못알아듣으면 참사다 진짜로.)

따라서, 서로를 구성하는 구성능력(이것도 조어)관계가 양방향 구성능력이 될때, 상호서술가능(이것도 조어, 『참고 A』)관계가 되어, 같은 서술능력 위계에 있으므로,

비결정성 추상어는 단어활용능력에 따라 창발적인 단어생성및 활용이 가능해서, 모든 언어를 근사하는 근사-번역(이것도 조어다. 예를들어 "야바비자"가 "암니차르"를 의미하는지 "하나차르"를 의미라는지 "하나바시"를 의미하는지 모를때, 대충 "암니차르"로 번역하면 되고 이가 근사-번역이다. 예를들어 한자에서 "필멸"이라는 단어의 뜻은 mortar이며, 불멸이 immortar에 대비되는 영단어 번역용 조어가 필멸이기에, 이런식으로 대충 번역하는 근사-번역이 비결정성 추상어에서 단어활용능력에 기인한다.)을 하기에, 보편적인 언어의 위계가 된다.

## 철학어나 양상논리어 : 논할수 없는것을 논할수 있을때

논할수 없는것에 대해서도 말할수 있다는 철학을 가진 언어는, 논할수 없는것에 대해서 논할수 있을것이다.

왜냐하면 그게 그 언어에서 논리적인 참이기 때문이다.

그러나, 외부 시선(e.g. 비트겐슈타인의 논리-철학 논고에 쓰인 독일어 + 수리논리언어 조합에서의 설명)에서 보면 그저 헛소리일 뿐이다.

이 부분에 대해서는 나중에 파보자.

## 말 만들기 놀이와 완전파생언어

필자는 어릴때 언어 만들기 놀이를 한 바 있다.

나는 그러한 언어를 만들기 위해 암호처럼 만드는걸 지향했다.

허나 "먹는 것"이나 "음식" 같은 단어를 "레다크"나 "food"로 명명해도 되지 않는가?

나는 그걸 또래 친구들을 보고 알았다.

그러나 해당 언어는 쓸모가 없었다. (필자 주 : 쓸모없는 이유는 단어활용능력을 만족하기 않기 때문이다)

어찠든 명사랑 동사를 변환하더라도, 조어력과 서술력이 있다고 취급되는 창발적일 기준을 만족하지 않는다면, 그것은 비결정성 추상어가 아니다.

따라서, 단어사전처럼 명명하고 번역하는 언어를 상상해봐도 좋을것이다.

그건 완전번역가능한 언어로 완전번역가능어(이것도 조어)일테니까 말이다.

참고로, 나는 비결정성 추상어가 아닌 언어를 찾은적이 없다.
자연어 능력 이상이여야 하기 때문이다.

비결정성 추상어에서 조건이 추가되거나 삭제되면 비결정성 추상어는 아닐거다.

그러나 비결정성 추상어로 구상 가능한 언어의 범위는 보편적인 모든 사고이자 언어이기에 (단. 이 말에는 경험이 개입된단 한계가 있다. 지금까지 모든 언어가 서술능력이 언어면 언어로 배웠던 경험의 한계가 있기에 그것보다 서술능력이 높은 언어나 나오면 반박된다.) 더 큰 언어를 찾을수 없으리라 오늘 내 17년 6개월 인생의 경험의 방대함 걸고 장담한다.

뭐 사실 그 경험에 대한 방대함이 당연히 적으니 잃을것도 없다 ㅋㅋㅋㅋ 히히.

튜링 언어같은 결정성 구체어의 경우에 비결정성 추상어에서 조건이 빠졌으므로, 결정성 추상어가 아니다.
근데 비결정성 구체어라는 종류도 생각해볼 수 있는데 이는 예를들어서 객체에 대해서 정의할수 없는 도달 불가능 기수를 제외한 ZFC가 그 예시이다.

단어의 정의성이 강하면 왼만하면 정의되지만, 비결정성 구체어라는 언어는 보통 수학같은 이분논리를 가진 경우가 많아서 꽤 도전적일거다 ㅋㅋ 상수기호를 만드는게 나을거다.

구체어라고 한 이유는 정의된 대상만 씀을 가정했기에 그렇다.

결정성 추상어를 가정한다면 결정된 순간 수학적으로 모델링해버리면 구체적인 분석이 되는 이산논리적인 속성이 생긴다. 결정성을 가지면 그것이 이분법적 논리성을 창출한다.

예를들어 정언논리같은 경우 충분히 술어논리로 모델링할수 있지 않는가?

길이에 대해 의심해봤다면 알겠지만 그런 보존 개념이나 딱딱 떨어지는 이분성은 필연이 아니고 굳이 지키지 않아도 된다.

결정성 추상어는 그 본질이 아닌 부분에서 수학으로 서술 가능하고, 그것에 대한 부가설명으로 논리를 쓰면 된다.

길이에 대한 명명으로 설정히는 경우를 가정하자.

만약 정의가 절대적인 정의어만 가정해도 이분논리의 미친짓으로 이미 수학적 도구를 이용하여 그 단순성을 이용한 논법으로 설명하는것이다.

충분히 언어라는 대상을 보편적으로 생각할 땐 비결정성 추상어로 충분히 가능하다.

참고로 개빡치게 오해하는 사람이 있어서 정리하겠다.

사전으로써 충분히 많은 단어에 대해 번역 가능하여 그것으로 서술 가능한 언어를 번역할수 있으므로, 완전 번역이 가능해지면서 비결정성 추상어인 경우가 완전번역언어이다.

완전 번역언어는 비결정성 추상어를 만드는 가장 간단한 방법이다.

### 기본어휘언어

기본어휘언어는 준-완전번역가능어(완번번역가능어에 준하는 언어)이다. 기본어휘언어는, 고유한 언어를 기준으로 다른 모든 어휘를 설명한다.

로지반어가 대표적인 기존어휘언어이다.

따라서, 영영사전같이 로지반-로지반 사전을 만들면 기초어휘로 대부분은 쉽게 구성할 수 있다.

기초어휘 \`L*_basis\`에서 언어 \`L*\`를 구성할 수 있다는거다.

따라서 영한사전같이 로지반-영 사전을 만들면, 기초 어휘를 번역하는것 이외에는 로지반-로지반 사전에 대한 복사처럼 만들수 있음이 당연하다.

이것이 기본어휘언어의 환원적 성질이다.

기본 어휘 언어는 피결정성 추상어를 만드는 가장 효율적인 방법이면서 동시에 리스크가 크다.
구성적 방법으로 창조된 비결정성 추상어기 때문이다.

#### 완전번역가능 기본어휘언어 a.k.a. 완전파생언어

기본어휘언어이면서 완전번역가능언어인 언어이다.

이러한 언어는 필연적으로 그 orgin이라는 뿌리가 번역된 언어에 생겨버리게 된다.
완전번역가능 기본어휘언어는 솔찍히 창조라고 하기에도 너무 쉽다.

이게 가장 쉬운 비결정성 추상어의 창조 방법이라고 생각한다.

##### 기초어휘가 의성의태어인 완전파생언어를 : 표현기반완전파생어

완전파생언어는 기호를 만들거나 문법을 만들거나 어휘를 만들거나 하는것은 이미 수학에서 기호 만드는 실력, esolang 창작 실력, 언어핫 지식으로 거의 커버된다.

그러나 기초 어휘인 단어를 만드는데는 단어 발음을 만들기가 무지 어렵고 예술의 영역처럼 느껴진다.

그래서 쉽고 직관적인 방법으로 표현기반완전파생어를 제안한다.

표현기반완전파생어는 기초어휘가 의성의태어인 완전파생언어이다.

히나타 쇼요의 "슉~ 슈육 해서 퐛 했더니"이런 말이나 "엄... 유 엔 미 너 셈셈" 식으로 말하는 기안84같은 경우 "엄... 노 펜슬? 쓱쓱~ 쓱쓱"이라고 말할것이다.

가장 순수하고 직관적인, 픽토그램같은 발음이라고 생각한다.

나처럼 만드는데 부담되면 할만해보인다.

## 참고

용어정리)

비결정성 추상의 활용 가능성 : Φ(x)라는 속성에서 ∃x일때, 이에 근거하여 Φ를 서술하여 "먹다(x)" -> "먹는 것"이나 lojban어 "le Φ"같이 활용할 수 있는 술어에 대한 추상적인 속성에 대한 논의의 활용 가능성.
단어활용능력 : 보편적인 언어와 상호서술가능능력관계를 가질정도의 충분히 창발적인 조어력 및 서술능력
상호서술가능 : 언어 A에서 언어 B를 어떻게든 설명하는 말을 할수 있으면, A는 B를 서술가능하다 하고 A와 B는 서술가능관계이다. 그러나 이것이 단순 함의처럼 일방향인것이 아닌 양방향으로 변한다면, 즉, A는 B를 서술 가능하고 B가 A를 서술가능하면 A와 B는 상호서술가능하다고 한다.
완전번역가능어 (완전번역가능성을 가지는 언어와 완전번역가능이란) : 완전번역 가능성을 가지는 언어가 완전번역가능어고, 완전번역가능어가 완전번역가능성의 기준이다. 완전번역가능성이란, 사전을 통해 어떤 타 언어 L로 완전히 번역 가능한 L이 존재한다면 완전히 번역할수 있는것이고, (완전번역가능어, 즉 지금 번역한다는 주제의 언어는) 언어여야하므로, 비결정성 추상어 인것이다.
기본어휘언어 : 모든 단어 L*이 기본 어휘 L*_basis를 이용하여서 설명되고 정의된다면, (기본어휘언어, 즉 지금 논하는 초점이 되는 말의 언어는) 언어여애 하므로, 비결정성 추상어이다.
완전파생언어 : 완전번역가능 기본어휘언어로써 완전번역가능어면서 기본어휘언어이므로, 두 조건을 동시에 만족시키기에 수학적으로 자명하므로 더이상의 자세한 설명은 생략한다. 일 더하기 일 수준이다.
근사-번역 : 언어는 자기 자신에 대해 닫힌 말만으로 이루어질 수 없고 또한 언어는 자기 자신이 아닌 다른 언어에 대해서 완벽하게 번역 불가능한 번역 불가능성을 가진다. 따라서 이를 극복하기 위해 "가바가이"를 번역하듯 하는 번역을 근사-번역이라고 한다.
표현기반완전파생어 : 기초어휘가 의성의태어인 완전파생언어.

하... 생각해보니 완전번역가능어는 이름을 너무 지좆대로 지은것같다.
완전번역가능어는 이름이 존나 이상하게(비직관적으로) 지어져서 그렇지, 예를들어 basic english가 대표적인 완전번역가능어다. 사실 basic english는 기본어휘언어이기도 한다. 따라서 basic english는 완전번역가능어면서 기본어휘언어이기도 하여 완전파생언어이기에 뭐... 예를들어 한국어 암구로호 비결정성 추상어를 만들면 그게 완전번역가능어다.
이름이 참 어감을 지좆대로 해석하는 미친형태다.

이하에서는 1도 중요하지 않는 잡설 해설을 하겠다.

결정성 구체어 : 결정적인 구체적인 대상을 다루는 언어이고 튜링언어 이하의 위계의 언어를 말한다. 모든 해석은 결정적인 부분에서 구성 가능하며, 구체적인 알고리즘을 통해 이루어진다. 에초에 구체적인 알고리즘이라는것이 결정적인 방법인 최소한의 동작으로 작동하므로 α, β, γ 세가지를 가진 람다같은 튜링 완전 언어가 바로 이런 언어다.
비결정성 구체어 : 결정성 구체어와는 다르게 비결정적인 대상을 다룬다. 예를들어 범주론이 아닌, 범용적인 언어가 아닌 수학용 언어오써의 수학에서는 비결정적인 집합도 다룬다.
결정성 추상어 : 추상적인 대상에 대해 다루지만 결정성을 가지기에 추상을 서술하기 충분하지 않아 구체적인 추상으로 한정시켜버린다.

이런 잡설은 무시하라. 특히 비결정성 구체어와 결정성 추상어는 하등 쓸모없는 공상이니까 결정성 구체어 종류라는 부분으로 퉁쳐서 무시하거나.

잡설때문에 조어만들어서 미안하다. 왠지 내가 더 짜증나는 기분이다.

# 언어와 메커

여기서 부터는 응용철학 겸 오락용 실천이데올로기 급인 비결정성 추상어 이론과 완전파생언어 이론이 아닌 다른 글이다.

## 말하기 전에

언어의 되기적 특성으로 정명(성리학에서 정명)이 지켜지지 않는 동명(동명은 조어이며, 정명이 지켜지지 않고 계속 변하는 동적인 성질을 말한다.)을 가진다.

## 말해보자면

근데 이건 나중에 이어서 서술할꺼라서 오늘(2025.Aug.07)이후에 쓸꺼다

따라서 아직 작성중인거다....

라고 쓸려고 했는데 지금 찾아서 넣는다

### [메커론](https://faraway6834.github.io/unbeauty/privateNote/Alkali/Forbidden/%EB%A9%94%EC%BB%A4%EB%A1%A0)

\`\`\`\`markdown
메커론을 작성할때 상당히 제가 대단한줄 착각했던점 독자 여러분께 사과드립니다.

# 아래 내용은 아직 정리되지 않은 내 이론이며, 완성을 위해, 들뇌즈를 공부하고 싶다, 아직 들뇌즈의 소개밖에 못봐서 알지 못한다.

내 생각 :
\`\`\`
생각은 언어라고 노엄 촘스키가 말했다. 그러나 우리가 생각하는 생각은, 본질적으로 어떤 기제(메커니즘, 이하 메커)이다. 메커와 언어는 구분하는순간, 그 차이가 가려져서 차이가 안보인다, 그러나, 언어 이전에 메커가 언어로 되려고 존재하고, 메커는 언어로 되며, 언어는 메커를 촉진하고, 메커는 언어같은 사상과 생각을 반복한다, 즉, 언어는 완벽히 생습적이지 않고, 되기의 기능으로 어느정도 생습적이며, 나머지 보편적인 우리 신경의 되기 흐름 재능에 맞겨진다.

+ 언어 이전의 메커는, 논리•구조라는 언어를 동반하여 어떻게든 악착같이 가려지기 때문에, 역설적으로 우리는 그런 하등한 메커를 다룰 능력이 없는 고등생물놈들이다.... 바보지.

+ 언어 이전의 메커는 그 존재성을 논할수 없다는 소리다.
\`\`\`

우리의 사상은 윤리고, 새상의 본질은 메커며, 도구의 언어가 형식이다.
\`\`\`\`

# 발화의 배경 : 콰인에 대한 소신발언, 콰인의 이분법적 의견에 반대.

메커론 다음 내용은 내가 이 글을 쓴거에 대한 정리글이다.

\`\`\`markdown
# 수학적 합리의 탈을 쓴 멍청하고 순수하며 괴랄한 타당성 (콰인에 대한 소신발언, 콰인의 이분법적 의견에 반대.)

결론은... 양상논리는 괴랄하다..!!

생각해보자, "정의어"라는 개념으로, 대상을 사전처럼 말을 매핑해서 정의되는 언어로 그 언어의 철학과 그 논리가, 정의된 값은 논리를 낳는다는 입장이면?

실은 공리 A, B, C, D에 대하여, T = (T = A = B = C = D) 라는 스크립트 포멧을 만드는 언어의 논리로써, 그 언어의 논리를 선택하는 독선이다.

(x = T) = x 인것도 이산논리에서 기호 '='의 존재론적 언질로 추론가능하며, 공리 또한 포멧의 정의로 꼴통같이 구성하고, 이러한 이론 자체는 연역적이고 형이상학적인 닫힘을 만들면 꼴통이 되는데 어떻게 그딴것만 진리라고 하겠나

"결국은 뜻이 단순히 한 종류의 타입의 단일 객체로 해석되는 문장-평가값 쌍 뜻 언어에서, 속뜻이 겉뜻으로 이리 단순한 언어에서 하는 추론은 결국 자연연역같이 논리라는 합당한 추론방법사상으로 반복적 추론을 평가해서 이게 논리 위에서 옳다!"라고 허는 꼴임이 모든 논리 위에서 증명되는데 말이다.

논리적이므로 믿을만하므로 논리적이므로 하는 순환논법을 추론할만큼 객관적인 논리는 자신이 왜 믿을만한지 강제하지 못한다.

그러니 언어는 그 철학과 논리를 가지는데, 수학적 구성이 본질인지 의심스럽고, 모델론이 맞는지 종합적 진리가 맞는지는 순환이다.

이러한 불가지해보이는 흐름에서 각각의 명세에 대한 타당한 자연 연역에 관점에선, 짜증나는 논리도 타당하다.

내가 얼마나 짜증나고 타당한 논증을 많이썻는지!

콰인의 말은 설득력 있지만 망할 논리는 기반이 소용돌이치는 바수구마냥 더럽고 설득력이 약하다.

결국 양상논리와 가능새계 의미론은 짜증나게도 인정할수밖에 없는 언어임이 당연하다.

왜냐하면 술어논리조차도 그것에 대한 암시를 하였기 때문이다.

조건이란 도구로!

## 다치논리나 다치값의 해석은!

어떤 임의의 객체집합 S에 대해 선택함수 f가 존재해서, 첨수집합을 정의역으로 하는 시퀀스 ; P_1 = S이고, P_n = ∅이며, P_k = P_{k - 1} - f(P_{k - 1})에서, 어떤 언어 L에 대한 문장 T가 언어 L의 모델 M에 대해 μ로 평가되어, μ : L* -> S라면, M이를 구성할 모델 L이 존재하여 S의 원소러 평가되는 다치언어 T와 그 평가값 S는 존재론적 언질로써 수학에서도 존재한다.

## 술어논리의 회피하는 방어기제에 대해.

다음 공리를 술어논리에 도입함하면 정체불명의 술어가 생긴다.
AXIOM)
∃Necesurry
DEFINE)
Necesurry(Φ) : □Φ s.t. (⊨ Necessitation)
Posible(Φ) : ¬Necesurry(¬Φ)
Necessitation(Φ) : Τheorem(Φ), (Φ ⊢ necesurry(Φ))

### 비유

생각해보자, Necesurry(Φ) : "Φ is necesurry" 말고도, Φ(year, mounth, day, who, food) : "year년 mounth월 day일 who의 마음속에 확고한 마음으로 잘 정의된 그날 먹고싶은 음식 목록에 food가 있음"인 Φ는 어쩔것인가 (고지식한 이의 음식목록의 비유)

그러면 Φ_1(sentence) : "문자열 sentence는 형식 언어의 문자열이다"과 Φ_2(sentense) : "Φ_1(sentence)일때, sentense는 해당 언어에서 정리이며, 필연적인 명제다"에 대해 Φ_1(sentense) ⊨ Φ_2(sentense)를 만족하는 sentense에 대해서, 말할수 있음을 안다.

sentence에 대해서 L에 원소중에 '□'도 있으면 매우 모호해져서, 고지식한 이의 맛있는 음식 리스트다의 경우와 같다.

결국에 이 술어는 명확한 자연어 술어로써 참 혹은 거짓의 성질을 띄고, 논리적으로 논의하기 애매한 서술들이다.

따라서 우리는 자연어라는 명세에 대한 기호화된 논리식를 구성해서 회피하곤 한다.

자연어를 쓸수 있게 해놓고 그게 너무 광범위한 음식리스트가 되니 회피하는거다.

진리값이 잘 정의됬다 정의에 선언하는것이 잘 동작하지 않는다. 그러나 동작한다.

## 너무 너무 Ridiculous한것은!

귀납적 설명에는 actual인 관찰 Φ_k (k = 1 ~ n)에 대해, H_1 : Φ_k (k = n + 1 ~)이 존재함이 당연하므로, 일반화된 통찰 Φ에 대해 H_1 ⊨ (Φ_k, H_1 ⊨ Φ)임이 귀류법의 전제조건이지. 그러면, 이론 T와 그 모델 M과 모델에 대한 근거 가설 H_2에 대해, H_1, H_2 ⊨ Φ, H_2 ⊨ T로, 이러한 Φ에 대한, H_2, H_1, T의 관계는 추측관계 C(Φ, H, T) : H_1, H_2 ⊨ Φ, H_2 ⊨ T이며, 따라서 어떤 과학적 모델 M에 대해, M은 필연적으로 그 개연성이 추측관계 C(Φ, H, T)의 참인 개연성이므로 (개연성은 가설 이론이 얼마나 actual들을 잘 설명할 수 있는가이므로 타당) M은 Φ에 시간에 따라 의존적이고, M ⊨ T이며, H, Φ ⊨ M이므로, M고, 엮인 속성이 어쨌든 Φ, H, T이다. 추측은 개연성을 가진다. 자, 그렇다면 아까 했던 논의를 다치논리로 확장하여, 직관적 맞을 진리값(e. g. 200%)을 객체적 진리값으로 바꿔서 논의하듯 논의하면(즉, 절대적 참 거짓을 개워놓고 보면), 통계에서 왜 틀려도 맞냐하는지 설명은 극히 일부의 다치논리이고, 개연성이라는 진리치 이외에도 여러 진리치가 존재하여, 경향성이나 일반성 또한 모호히 잘 정의되기에, 쉽게 도달 가능한 ridiculous한 진리치들이 존재함은 타당하고, 이들을 논리로 해석할지는 자유가 된다.
\`\`\`
```

### 현

```
## 1. 비-예외 논리의 확장성과 그 원리

비-예외 논리에서의 확장성과 그 원리에 대해 다뤄보자.

먼저 이 글은 핵심적인 본론만은 담기 위해서 서론을 삭제하고 여러 본론들에 대한 결론으로 글을 쓰는 구조이다.

또한 글을 쓸때 있어 나는 가끔 어감에 의존하는 직관적 표현으로 논리적으로 받여질경우 그냥 그 말을 채택해서 적기에, 엄밀하지 않은 표현에 대해선 주석을 남겨놨을것이다.

사실 그런던 대게 규칙도입계 구현의 "컴펙트지지"라는 Alkalic적 논리 해석방식으로 서술되어 그러는데, Alkalic에 대해선 외부 자료이니 이 글에 대한 작성이 끝났을때 레퍼런스에 적혀있을태니 참고하라.

미안하게도 Alkalic이란 내가 만든 체계이다.

추가적으로 지적받은 점에 대해 적자면,

이 글은 수학같은 연역논증만이 참이라고 생각하는 자들이 꽤나 편협함을 깨닫게 할것이며

수학과 Alkalic에 대한 이해가 어느정도 필요하고,

공리계가 가정되지 않았는데 (공리계적인 논리에 대해) 비논리적인 대화가 되는데

그 대화가 존재하므로 공리계가 객관적인지 의문을 삼는다는점 명시해두겠다.

### 다가논리 주장명세

작성중...

새상에 참과 거짓으로 구분되는 논리가 가장 객관적이냐는 질문에,

세상에나 요즘 4차 산업혁명 시대 2025년 사람들은 정신나갈정도로 그렇다고 믿는것 같다.

다소 모호해보이는 "불가지"라는 명제에 대한 판단에 대해 사람들은 혼란스러워 하며,

고대 인도 논리학의 "참도 거짓도 아님"에 대해 모호하다 느끼며,

인류의 위대한 지성사의 자랑스러운 과거 정도로 치부한다.

심지어 Veritaserum이라는 훌륭한 과학 유튜버는,

Russel과 Whitehead의 Mathmatica Principia에 대해,

매우 정밀해서,

불분명한 Fuzzy Logic들이 머리를 감싸며 도망갈것 같다고 말하니

얼마나 개탄스럽나.

에초에 왜 그러한 수학 규칙이 참이되는지에 대해,

누군가는 "선험적인 참으로써 우리 모두가 당연히 그렇다고 받아들일 지식이기에"라고 하며
누군가는 "경험적인 근거로써 당연한 정리로써 수학에 박힌것임"이라고 말한다.

나는 그 말에 대해 그 말이 나온 시대상에 따른 안타까운 착각이라고 본다.

과연 수학이 선험이라면 왜 누구는 머리를 싸매고 왜 누구는 선천적인 지식조차 없나?

또, 모든 논리가 다 지성으로 해결될수 있어 "이성적"이며 "합리적"인 방법으로 나아가야 하니

모든 문제가 "이성적"인 방법으로 풀려야해서 "불완전성"을 무시하거나 "그럼에도 불구하고" 불완전성을 즐거워하며 동시에 불완전성이 "비이성적"이라고 해야하나?

하... 너무 화가 나서 말이 봄 공격적이었다.

그런건 이성적이지 않은건데 말이다.

"살아봤더니 새속이 좋아지더라, 혹은 연역적 논증이나 과학적 탐구가 믿을만하더라."거나

"과연 이러한 시대상에서도, 굳이 고집부려서 글을 수리논리로 부숴서 생각하길 거부할것이냐?"하는 질문에 대해서,

"그건 니 인생 경험이고, 다른 인생도 폭넓게 들어보고 살았냐? 짜샤?"라고 묻는다면 어찌할것인가?

물론 나라고 잘나지 않는다. 지금 잘난것처럼 말하는 내 말투도 크게 문제다.

내가 살아보니까 보수적인 것들도 틀리진 않았다.

언어적인 것도 충분히 논리를 가진다,

아니 그전에 논리라는것이 에초에 가정되기 이전에 성립되지 않는

그 논리라는 대상은 누가 겪어서 만들거나 가르쳐주거나 구체화되어서 있는것이지

공리계나, 타당한 발견이나, 용어정의나, 그것에 대한 사전 지식 • 사전 지식으로써의 생각한 기술적 경험 없이 과연 그런게 존재하는가?

나는 확고하게 발표한다.

언어는 철학을 가지고 그 철학의 그 윤리와 그 논리를 가진다.

그러니까 우리의 생각에서 윤리와 논리는 언젠가 필연적으로 발생한것으로 보이고,

따라서, 그런것이 존재하여 우리 사고의 근간을 이루며

생각을 초월해서 그 생각에 같혀 알을 깨지 않고 순수히

언어라는 달걀 그대로 봤을때, 당연히 생각에서 그런거 없다.

그런건 다 허상이고, 달걀 밖의 뇌절로 간 구간이다.

특히 논리에 대해서는 그것이 언어 안에 있어야 한다고 확신한다.

왜냐고? 그 주장을 뒷밭힘하는 근거로서 그 평가가 그 논리에 대한 평가가, '옳다'는 평가값이 'x는 옳다'의 존재론적 언질이기 때문이다.

논리가 언어에 의해서 생기니 수학 언어는 자만하지 말아야 한다.

바보같이 자신이 속박되어 어디선가 들고 온 정의를 숭배하는 우상숭배를 하지 말아야 한다.

### 다가논리 구체증명

언어 L에 대해 그 진리평가함수공간 Func(L*, 𝔹)이 있다면
어떤 긍정 yes에 대해, 논리적 동등 • 에 대해
(f(p • v) • yes) (단. yes ∈ 𝔹)에서,
(f(p) • v) (단. v ∈ 𝔹)로 평가될 것이고,
이러한 당연한 수학적 정리에 따라서,
다치논리를 설명하는 모형이 있기에
다치논리 이론은 타당하다.

이때 배중률을 만족하지 않는 논리는 출력값이 집합이면 되므로 그띠 𝔹는 모든 원소가 집합인 집합족이다.
따라서 그러한 경우 다가함수가 된다.
따라서, 다가함수-다치논리는 타당하다.

### 규칙도입계 주장명세

공리계라는것이 믿을만하다는건 어떻게 보일수 있을까?

왜 공리계에 기반하여 참인 명제로 증명하거나 자연연역을 통해 당연한 방법으로만 증명하는 논리가 믿을만할까?

과연 아름다운 공리계가 믿을만할까?

유클리드때부터 내려오는 정의-공리-증명 방식의 추론에서 중요한 점이 있다. 추론 규칙은 타당해야 하기에 정리여야 하므로, 공리계 기반 추론은 공리에 의존한다.

즉, 공리계 논리에 한정해서 말하자면, 논리는 공리에서 시작되며, 공리가 논리를 만든다.

예컨데 공리를 가정하지 않으면 모든 수학 체계와 그 논리를 가정할 필요가 없어진다.

공리 없이는 논리도 없다. 따라서 공리시스템에 있어 절대적인 세팅값인 공리는, 그 시스템의 규칙이다.

공리는 받아들이지 않아도 무방하다. 논리는 전부가 이니고, 논리는 멍청한 공리라는 가정이기 때문이다.

따라서, 이 규칙에 따른 결과로써 논리가 나오는것이지, (참고로 지금은 공리시스템의 논리를 논하고 있음) 논리는 절대로 객관적인 대상이 아닌것이다!

물론 수학 언어가 논리를 만드니 맞냐고 치면, 연역적인 수학 언어는 경험론적 전체론에 따른 연역적 정의와 출발이 막힘에 따라, 완전히 연역적인 수학이란 존재할수가 없게 된다.

따라서, 이러한 문제를 해결하기 위해, 언어 수준에서 절대적 시작점으로, 그 역사와 무관히 정의하여 강제한 논리가 바로, 공리인것이다.

이러한 규칙이 공리적 학문을 만들고,

규칙 없이는 아무 (공리적) 논리를 작성할수 없는것이다.

따라서, 이러한 공리계를 분석하기 위해서, 규칙도입계를 구성하고 실험하여 얻은 경험으로 완전히 연역적인 시도를 할수 있으며,

이는 궁극적으로 형식과학인 수학의 탐구방법과 일치하고,

규칙도입계 상에서 실험된 성질이 바로 규칙도입계-공리계의 성질인것이다.

애기들이 장난으로 규칙도입계용 공리계를 만든다 하여도 절대로 그것을 비판할수 없다

너무 당연하다.

왜냐하면, 그 어린아이의 규칙 도입계용 공리나 수학 공리나 다 멍청한 주장이자 가정이며 (공리적) 논리라는 이름을 뒤집어쓴 주장이다.

완전 개찐도찐이다.

규칙 도입계는 필연이다.

그렇다면 어떻게 규칙을 도입하는 체계를 만들까?

간단하다! 규칙을 설정하고 그게 참이 되는 논리적 논의 영역이 규칙도입계다.

에초에 이 개념은 어린 아이의 규칙놀이와 공리계의 차이를 논하려 만들었지만, 지금은 그런 시시콜콜하고 멍청한 짓은 관심이 없다. 그런걸 구분하는건 멍청한 대중이나 하는것 같다. (대중이 멍청하다는 말은 아니다. 인스타나 이런데에 가끔식 멍청이들이 좀 있다.)

### 규칙도입계 구체명세

규칙도입계란 관계열 Eₖ에 대해 k-tuple (t₁, ..., tₖ)에 대해, Eₖ(t₁, ..., tₖ)가 참이라면 E₍ₖ₋₁₎(t₁, ..., t₍ₖ₋₁₎)이 참이고, E₂(t₁, tₖ)가 참이며 E₂(x, y)란 x = y일때 참인 동등관계열 Eₖ에 대해, rule의 U를 딴 관계열 Uₖ에 대해, 컴펙트 지지인 Uₖ의 정의역이 Eₖ이고 (단. 이 해설은 엄밀하진 않은게, Uₖ가 Eₖ에 포함된다 보는게 맞다. "컴펙트 지지인 Uₖ의 정의역이 Eₖ이고"는 엄밀하지 않다.) Uₖ(t₁, ..., tₖ)가 참이라면, U₍ₖ₋₁₎(t₁, ..., t₍ₖ₋₁₎)이 참이며 술어형 관계 U₁(x)가 참이려면 x가 참이여야한다. rule의 L을 딴 관계열 Lₖ에 대해, Lₖ(Lang, t₁, ..., tₖ) : Lang"U(t₁, ..., tₖ)" 인 Lang어 술어이므로, 자연어 술어여서 술어논리에서는 우연명제이다.

규칙도입계-공리계란 다음을 말한다.
"규칙도입계 공리계에서 참의 정의는 Lₖ가 항진인, 즉 Lₖ가 참이다"라는 정의의다.
엄밀한 표현으론, T = Lₖ이며, 정의로 적어놓은 사실상의 공리이다.
단. 이 내용은 공리이므로 정의하는데 있어서 경험적인 내용이 아니라고 가정되는 방식이다.

이 공리계는 내 이론을 검증하기 위해 만든 도구일 뿐이다.

## 우연양화논리론 구체명세 : 양화논리는 우연명제에 대한 회피기제를 가진다.

이제부터 문자열 변수를 쉽게 쓰는 표기법으로, "○"를 도입하겠다. 문자열 집합 타입의 문자열로써 쓰려니까 존나 힘들어서 x라고 표기하기보다, "○"라고 표기하는게 나을것같다.
에잇 에초에 수학자들처럼 표기하는거니까 뭐!

그렇게 되면 배중(률을 만족하는 언)어 L에 대해, 크립틱(S, L)이 잘 정의된다. 크립틱(Kriptic)이란 이름의 명명에는 크립키 모형같다는 비유법에 있다.

배중어(L) : "L ⊨ 배중률"
크립틱("○", L) : L"○"

그러면 다음을 알 수 있다.

자연어 L = 한국어 일때,

내가지금먹고싶은거(x) : L"x는 필자가 지금(2025.Aug.08 18:02)먹고싶은 음식이다"

내가지금먹고싶은거는 우연명제이다.

참고로 내가지금먹고싶은거는 L"불고기 뺀 콤비네이션 마르게리따 피자"다.

아 쓰다가 이미 18:03이 됬으니 어떻게 펙트다 ㅋㅋ

저런식으로 어떤 고지식한 사람이 "난 이것만 먹을꺼야"라고 할때 그 음식 고르는것에 대해,
명제이지만 우연명제가 존재하여 잘 정의할수 있다는, 잘 정의된다고 취급하는것에 대한 문제에 대한 비판을, 고지식한 사람의 음식리스트 비유라고 한다.

내가 만든 비판이다. (내가 자기 주관이 강하긴 하다만 고지식한 사람의 음식리스트 비유만큼 고지식하진 않다... 나는 변덕도 심하기 때문이다... 내가 말한 고지식한 사람은 그걸 절대 안바꾸거나 주어진 시간동안 바꿀 가능성같은건 없는 가상의 존재를 상정한거라서, 지독하게 고지식하다는 점.)

이런식으로 정언논리상의 우연명제를 양화논리로 옮겼을때, 그 우연논리는 논리식을 쓰지 않는 한 험밀하지 않은 임시적이거나 비표준적인 방법이고, 불가피한 경우에도 처치-튜링 명제 이외에 잘 사용되지 않는 방식이다.

이러한 우연명제의 사용이 가능한데 실재로 사용시에는 이것을 회피하길 마련이다.

이것은 양화논리의 Ridiculous한 회피기제다.

참고로 배중률을 거부하는 경우에는 그것에 대한 판단 언어는 필연적으로 존재하므로 (왜냐하면 방정식의 경우 해가 두가지라서 배중률을 거부하며, 이러한 경우에도 수학은 판단 가능하단건 어떤 함수로 모뮬화된 튜링완전적 혹은 비결정추상언어적 술어 Φ에 대해, Φ(x) : P(x) = 0인 방정식은 Alkalic에서 증명했든 타당히 이것이 명제와 언어의 성질을 가지는 논리 판단에 대한 의미론적 동등을 통한 당연한 본질에 대한 한가지 해석이라는 사실에 근거하기에, 그 배중율을 거부해도 수학은 판딘 가능하단게 당연하다.)

아, 참고로, 술어논리는 술어에 자연어를 적을수 있지만 권장되지 않는다. 재대로 정의되기 위해서다.
얼마나 이상한가?... 잘 정의되지 않을거면 그 명제를 없에야하는데... 그러나 수리논리는 수학의 전유물이 아니기에, 아리스토텔레스를 탓할수밖에 없다.
에초에 그런걸 정의할수 있게 논리학을 만들었으니 토달지 말아야한다.

### 우연양화론적 양상논리구현론 : 크립키 모형을 통한 형식적 양상논리의 우연양화논리론적 접근 a.k.a. 양상논리의 기괴성

다음 술어를 보라.

P(v) : ◇v
Q(v) : "v일수 있다"

만약 Q의 언어가 양상논리라면 P = Q이다.

그러면 Q의 언어가 양상논리랑 상호번역되는 언어인 경우

Φ = P = Q 로 정의하겠다.

그러면 다가논리 주장명세에서, "언어는 철학을 가지고 그 철학의 그 윤리와 그 논리를 가진다"는 명제에 대해, "그 주장을 뒷밭힘하는 근거로서 그 평가가 그 논리에 대한 평가가, '옳다'는 평가값이 'x는 옳다'의 존재론적 언질이기 때문이다"라는 말을 달았는데,

이는 형식언어를 통해서 곧 말할 많은 방법을 통해 잘 정의된 자연어 혹은 언어 L에 대해, 그 우연양화논리적 해석에 있어서, 존재할수밖에 없는 "지옥"같은 상황에 빠진다.

즉, 언어 L은 UG에 의해 해석되기에 모든 수학 외 언어는 자연어니, 이러한 자연어 우연명제를 UG때문에 막을수도 없는데, 기괴한 양상논리의 존재성은 이 우연명제의 이용으로써 나타나므로 필연(항진 정리)이다.

에초에 그거에 맞는 언어적 모델을 구축하는건 식은죽먹기다.

## 우연양화논리론 구체구현

Necesurry(x) : □x : ModalLogicTranslatibleLanguage"x는 필연이다 : ¬◇¬x
Necesurization(x) : Theorem(x), x ⊢ □x
Able(x) : ◇x : ModalLogicTranslatibleLanguage"x일수 있다."

따라서 규칙도입계-공리계를 도입하면 이는 참임을 알 수 있다.

에초에 규칙도입계를 수학에서 쓰려면, 크립키-모델을 이용하기 위해 양상논리를 활용하면 된다.

### 결론

UG의 존재와 규칙도입언어의 특성과 수학에서 서술할수 있는 언어평가의 특성에 의해 필연적으로 양상논리같은 비표준 논리도 "언어는 철학을 가지고 그 철학의 그 윤리와 그 논리를 가진다"는 명제에 대해, "그 주장을 뒷밭힘하는 근거로서 그 평가가 그 논리에 대한 평가가, '옳다'는 평가값이 'x는 옳다'의 존재론적 언질이기 때문이다"라는 표준수리논리에만 적용되는줄 알았던 명제가 그 확장으로 언어에 대해 존재할수밖에 없고 이는 언어에 창발성에 기인한다.

## 2. 예외 논리의 구성가능성과 그 무한한 구조

어떤 무언가를 서술하는 글이 담긴 책이 있다 하자.
그 글에 대해 참으로 두고 그것에 대해 설명한다면,
그 글에 대해 거짓으로 두고 그것에 대해서도 설명해야한다.

한마디로 그 대상에 대해서 언어로써 전달 가능한 생각으로써
기능할 조건을 그 글에 요구한다면
필연적으로 그 글은 변별력을 필요로 한다.

따라서, 모든 언어적인 단순무식한 생각과 그 "주장함"(주장하는 행위)는 변별이라는 방법으로 구성할수 있으며,

이러한 측면에서 예외에 대해 서술하는것도 당언히 가능하다.

예외라는 측면에서 언어에 대해 변별한다면, 필요 이상으로 논리적인 생각이겠지만,

빈틈없는 주장으로써는 훌륭한 방법이고 선대의 지혜로써 고안된 추론방법이다.

물론 그 추론 방법은 지금에 이르러 완전히 폐기하고 뉘앙스만 언어화되어 이용되어 독립되게 만들어 그 원인을 잊고 눈을 가리비만 말이다.

어떤 참으로 말하는 AFFRIMO(긍정)적인 대상을 논리적으로 설명하는 빈틈없는 오랜 고민끝에 나오는 생각으로 ontological한 뉘앙스의 주장으로 새우고,
어떤 거짓으로 말하는 NEGO(부정)적인 대상을 예외적으로 매꿔주는 완성까지 있다면,

그건 휼륭한 어떤 질문에 대한 대답 규칙체계를 만든것이고 아주 잘 만들어진 노력의 산물일것이다.

내 말은, 이런게 일반적이므로 있고, 더 나아가,

이러한 명쾌한 이분 체계에 대한 해설로써 긍정 존재를 강제해주고 부정 예외를 추가해주는 구조를 만들수 있으며,

그것이 왜 수학도들도 타당하다 받아들여야 하는지 말하고자 하는거다.

### 존재강제구조 주장명세

존재강제구조란 논의계층 h와 그 아래의 계층 aₕ에 대해,
aₕ의 결함이 h로 전달되는걸 "반역"이라 명명할때 반역되지 않으며,
h가 일반으로써 설정되는것을 말한다.

우리 언어이 변별과 일반 구조에 의해서, 아무리 엄밀한 체계라도, 예외를 이용하여 서술하는 아이디어를 피할 수 없으며, 이를 보이지 않게 녹이는 수학같은 방법도 존재한다.

따라서 이러한 예외도 타당한 논리다.

심지어 기호증명용으로 구성도 되는 구체적이고 규칙적이고 엄밀한 체계다.

### 존재강제구조 구체구현

어떤 존재론적 언질적 존재를 만들어주는,
즉, 어떤 성질에 대한 한정까지 포함한 존재를 민즉어주는것.

먼저 ∃Φ(x)와 ∃x s.t. Φ(x)의 의미를 보자. 참고로 두가지는 같은 의미다.

항진술어 T에 대해서도, 함축기호 • 에 대해,

(∃Φ(x))(T(x))라는 말은 곧 (∃x s.t. Φ(x))(T(x)) 이며, (∃x)(Φ(x) • T(x)) 이므로, (∃x)(Φ(x) • T(x))이니 특히 이경우 (∃x)(Φ(x))라고 잡힌것이다.

자, 저 논리식의 의미를 봤으니,
이제 저런 가정을 하는것에 대한 서술로 존재론적 언질적 존재를 만들어주는 존재성애 대한 논의의 기호적 표기를 쉽게 이해할 수 있을것이다.

이런 존재를 설정해주는 공간으로써 높은 위계와 그것에 대한 응용 공간의로써 낮은 위계로,
논리에 그 위와 아래가 있다면, 계층적으로 예외를 이용한 논리의 서술의 일관성 문제가 해결될것이다!

존재를 설정해주는 공간을 어쨋든간에 절대적으로 존재하게 강제한점에서 기묘하고 신묘하다는 의미에서 실존에 비유하여, 실존공간이라 하고 h라 하겠다.
그리고 그 실존공간 h에 대해, 논리적으로 논의하는 그 논리에서의 논의공간, 즉 현실인 a를 aₕ라고 하겠다.

h와 aₕ의 정의는

V(∃Φ(x), h) → V(∃Φ(x), aₕ)

이며, 이를 계층 관계라고 한다.

논리에 있어 배중률이 없는 언어가 있을수 있다는것은 이미 이야기했으니 배경지식으로 탑제하고 태클걸지않고 갈수있다는건 당연하게 알것을 선언하겠다.

 h 규칙도입계(참고로, 규칙도입계로 동작하는 이유는 그 언어의 공리계가 생겼다면 그런거라 지금 서술 방식을 규칙도입계처럼 다루는거여서 그렇지, 규칙도입계라는 표현은 엄밀하지 않고, 논의계층이라는 말이 엄밀히다) 논리에 대해 aₕ 규칙도입계는 h에서 한 선언을 부정하여 h를 바꾸는 "반역"을 할 수 없으며 aₕ에 대해 선언은 h가 해줘서 제어 가능하고 자신은 결과를 받지 않지만,
aₕ에서는 스스로 예외규칙을 만들어 h에는 "반역"하지 않고 독자적으로 예외가 발생할 수 있다.

이처럼 예외를 가지는 언어는 계층을 가지고, 무한한 예외규칙의 경우, 계층은 무한하게 되어 구성된다.

## 뭐쓸지 까먹은 목차 작성중 ...
```

## 추가적으로 작성한 글들 (담론 내)

### 조어-초단순언어 개념

```
# 추가적으로 설계한 언어 : 조어-초단순언어 시스템

주의할점 : 여기서 정의한 말들에 "조어-"라고 이름붙인 단어는 죄다 내가 만들어낸 단어이므로 표준국어대사전에 존재하지 않는다.

또한 이 글은 기본적으로 내가 이전에 적은 글을 참고해야한다.

## 정의 1 : 조어-정언중심언어와 sentence-shapizer언어

조어-정언중심언어는 정언논리에서 취급하는 주어/숭어가 나뉜구조의 언어로, 이러한 언어를 언어의 본질이 아닌 한 시각으로 보는 시각이다. 다만, 보통의 언어는 구와 절을 가지는데 각각이 단어와 문장의 역할을 가지고, 동사가 문장의 역할을 가지고 명사가 대상의 역할을 가지는거에 대해, 각각이 주어 / 술어로 나뉘는것은 일상적인 언어에서 허다하며 그게 보통은 보편이길 마련이다.

다음과 같은 sentence와 shapizer가 언어 위에 정의되어있는 모델론적 언어 위의 형식 언어 L을 sentence-shapizer언어라고 하며, 이는 조어-정언중심언어이자 merge이외의 언어의 선형화를 피하기 위하여 람다로 계산되는 언어이다. 단, 자연어에 대한 술어는 그 자연어로 평가된다. 사실상 사전을 이용한 언어인 완전파생언어이다.
sentence(Φ, x₁, ..., xₙ) : Φ(x₁, ..., xₙ)
shapizer(k, Φ, x₁, ..., xₙ) = xₖ s.t. sentence(Φ, x₁, ..., xₙ)

Formal Grammer of L s.t. without Exception)

S, V, O중 O가 따로 존재하지 않으므로,

VS어순엔 Polandian Notation
Gₚₙ = (L, Lₘₐₜₕ, Pₚₙ, ".") [Pₚₙ := {x ↦ y | y = RegexProcessor("/\.\s([0-9][0-9]*)\s(.*?)/shapizer $1 $2/", x) ∨ y = RegexProcessor("/\.\s(.*?)/sentence $1/", x)}]

SV어순엔 Reverse Polandian Notation
Gᵣₚₙ = (L, Lₘₐₜₕ, Pᵣₚₙ, ".") [Pᵣₚₙ := {x ↦ y | y = RegexProcessor("/\.\s([0-9][0-9]*)\s(.*?)/$1 $2 shapizer/", x) ∨ y = RegexProcessor("/\.\s(.*?)/$1 sentence/", x)}]

이며, 여기서 Lₘₐₜₕ는 InfinityLambdaCalculusModel인 언어라서, 함수형 적용이 모두 Curring되어있다.

only on kuratowski's requational n-tuple system's model n.b. uncurried moddel : kuratowski-쌍 기반 제귀적 n-tuple 시스템에서의 모델, N.B. 커링되기 전의 모델임)
first(x, y) := x
last(x, y) := y
sentence := λx. first(x)(last(x))
shapizer := λx. (λn. λt. first(lastⁿ(t)) s.t. sentence(t))first(t)last(t)

## 정의 2 : 조어-근원단어와 조어-초단순언어

조어-근원단어란 조어-정언중심언어와는 달리 주어•서술어를 가리지 않고 같게 보는 품사 형식으로써, 오직 하나의 품사만 허용하여, 그를 "근원단어"라 하는것이다.

조어-근원단어의 방식으로는, 조어-정언중심언어중 sentence-shapizer언어의 언어-패러다임(프로그래밍 언어의 페러다임과 동일한 뜻이다. 언어의 아키텍쳐를 뜻한다)을 채택하여, 동명사 v-ing가 명사역할을 하고 명사 n은 ~is n이라는 뜻의 자동사로써(사실은 타동사처럼 꾸며도 되지만, 어짜피 sentence-shapizer언어에서는 목적어가 없이 죄다 늘어놓으므로) 이용되는 영어처럼, 단어 t가 술어 위치(.이 오고나서 바로거나 .이후에 숫자 이후 바로)나 단일 사용으로 쓰일때 t-ing로 해석되는 문장형 해석으로, 단어 t가 술어 위치가 아닌곳에서 쓰일때, 객체(Subject역할임)로 쓰이게 하는 방식인 "sentence-shapizer언어형 조어-근원단어 페러다임"이 존재한다.

조어-초단순언어는 "sentence-shapizer언어형 조어-근원단어 페러다임"에 해당하는 언어로써 다음 두가지 문법의미품사가 추가된다.

text of line이라는 뜻의 축약어 tol을 이용해서
`tol-x`라는 대명사가 존재한다.
`tol-x`는 x번째 라인의 텍스트를 가르키는 말이다.
이러한 문맥-민감 방식은 의외성을 만들다기엔, 속뜻과 겉뜻을 하나로 보아도 무방하므로, 말이 끝날때까지 끝난게 아닌 언어인것 뿐이다.

protologism의 축약어인 pro를 이용해서, pro- 접두사가 붙은 단어는 죄다 사전에 등제된 단어로, shapizer의 치역인 단어이다.

따라서, 기본 어휘를 자연어에서 파생하여 모든 어휘를 구성하는 매우 간단한 언어가 조어-초단순언어다.

### 조어-의성-초단순언어와 조어-의태-초단순언어

만약 조어-초단순언어의 기본 어휘의 출처가 자연어의 의성어라면 그것을 조어-의성-초단순언어라고 하며,

조어-의태-초단순언어의 기본 어휘의 출처가 자연어의 의태어라면 그것을 조어-의태-초단순언어르도 한다.

조어-의성-초단순언어는 의성어로써 객관적인 명명을 취한것으로, 그에 맞는 문자로써 문자가 있는것이고.

조어-의태-초단순언어는 의태어로써 객관적인 명명을 취한것으로, 그 말은 본질적으로 어떤 의태할 대상을 흉내내는 객괸을 가진것으로, 의성어의 언어-발음적 객관과는 다르게 이미지형으로 객관을 가진다.
```

### 언어 분석하기.

```
defs)
1. 문자셋이란 문자의 Set이다.
2. 언어 L은 형식문법 G_L을 가진다.
3. 언어 L은 문자셋이다.
4. 언어 L의 형식문법이란, G_L = (L, codom G_L, P_{G_L}, L_sym)이다. (단. 이건 일반적인 형식문법의 정의이기에 codon G_L이 다른걸 뜻하는기 아니라 컴파일 결과의 언어라는건 형식문법을 배웠다면 자명하게 알수있다.)
5. 형식문법 G_L의 시작기호란, L_sym ∈ L이며, L_sym는 문법을 읽기 시작하는 문자이다.
6. 형식문법 G_L의 문법규칙이란, P_{G_L}을 일겉는 말이다.
7. 문자열(string)은 쌍따옴표로, 문자(charactor)는 따옴표로 표기한다.
8. 모델론적 언어 L에 대해 그 집합 L의 기호의 문자 집합 9. L_chr은 모델론적 언어 L의 명세에 따라, 형식문법 G_{L_chr}을 가지며, 이를 명세의 문법화 (Grammerization of intetface)라고 한다.
10. 모델 M^L 이란 모델론적 언어 L을 그 명세에 대해 참이 되게 하는 구조체 혹은 귀결될 논리적 조건 혹은 값-배정(e.g. 진리값배정)으로, 명세의 문법화 언어 (interface-Grammerization Language) L_chr의 형식문법 G_{L_chr}를 만족시키는 모델 M으로써 정의하고 모델의 작동기제(Working Machanism of Model)으로 작동한다.
11. 모델 M^L의 작동기제(Working Machanism)란 그 모델에 명세한대로 기호의 의미가 부여되게 하는 동작이다. 예를들어 ZFC에서는 구조체가 그 자체로 참이 되기 위해, 그 구조체는 튜플로 그 안의 원소가 전부 참일 조건으로 하였다. 그리고 Alkalic과 같은 대수나 함수적 방법으로는, 그 튜플은 어짜피 다변수함수 입력을 한방에 일변수로 주는법으로 쓸 수 있으니, n변수에 대해 전부 논리곱하는 함수를 이용하여 그 체계를 구현 가능하다.
12. 언어 L의 문장 "x는 참이다"를 L"x는 참이다"로 표기하며, 이를 마크다운식-표기법 (Markdownic-Notation) 이라 한다.

theorem : 사고의 단위화)

Φ(x) : ko"x를 먹다."에 대해 Φ는 동사다.

근데 y = x s.t. Φ(x)하면 사실상 y가 things that Φ인 셈이니 y = ko"먹는거"겠다.

즉, 동사 Φ(x)에 대해 x. s.t. Φ(x)로 명사화 가능하고, 이는 생각이라는 의미의 단위에서 최소단위인 문장으로써의 의미를 가지는 동사의 언어적으로 공처럼 대상으로 취급되는 명사화 가능성이다.

행동은 그 존재론적 언질로 지칭 가능하다 : 사고의 단위화. (이는 언어의 서술력과 조어력이 떨어져있지 않다는걸 의미한다.)

theorem : 발음어)

발음어는 useipa라는 언어다.

표준 발음은 같은 발음이라도 구간의 길이에 따라 속도(Hz)가 다르기 때문에,

각 발음 시간의 연속적인 타임라인에서 속도(Hz)의 값을 함수식으로 표기한다.

일반 발음은 대괄호 안에 쓰지만 발음어 발음표기의 경우,

`[ipa기호](함수식)`으로, 연속적 속도를 명시하여 쓴다.

발음어에서는 발음표기 구문이 동사의 역할을 하고,

"~는 [ipa](함수식)발음이다"라는 뜻을 가지는데,

이는



useipa"x [y](z)" : ko"x는 [y](z)발음이다"



라는 뜻으로 정의된다.

위 정의는 한국어로 정의했지만 원래 영어로 정의해야한다.

ko대신 en을 쓰는걸 표준이라 했는데 쓰지 않은 이유는,

내가 영어실력이 딸려서 그렇다.

또한 자연어의 발음은 발음어로 표기할 수 있다.

theorem : 범용표음)

범용표음, 영문 Universal Phonogram,

약칭 up이란 발음어에서 서술하는 언어에 대해,

그 언어의 발음으로 언어의 표기를 재정의한것이다.

범용표음어란, 발음어에서 서술하는 언어 L에 대해,

그 언어의 문자셋을 쓰지않고 그 언어의 발음을 useipa로 사용하여 문자셋을 쓴 언어 L을 의미한다.

L의 범용표음어(Universal Phonogram Language Form of L)는 L_up이라 하며,

ko_up"[hɑŋɡɯl](함수식몰라ㅠㅠ)" : ko"한글"

식으로 작성한다.

즉 어떤 언어 L을 범용표음어로 만드는걸 "범용표음"이라고 하고

L의 범용표음이 "범용표음어"다.

정리하자면,

**어떤 발음어에서 서술하는 언어 L에 대하여 다음 문장이 성립한다**

useipa"x [y](z)" ↔ (L_up"[y](z)" : L"x")

**왜냐하면, 그게 L의 범용표음인 L의 범용표음어의 정의이기 때문이다.**

**또한, 범용표음어는 중요하다!**

보편 언어 없는 인간은 하등생물과 같다.

그러나 인간이 만물의 영장이라 자만할수 있는대에는,

보편 언어인 구어 (oral language) (즉, 범용표음어인 보편언어, 즉, 범용표음구어) 를 쓰는 하등생물이기 때문이다. (어떤 구어의 범용표음어 표현을 범용표음구어라고 한다.)

이것이 인간이 강하고 똑똑해지고 우월하고 고등생명체라 자부한 이유가 되고,

실제로 인간의 이성이란 언어에서 오는것이라는것이 과학적 펙트다.

즉, 인간이 고등해서 보편 언어를 쓰는게 아닌,

보편 언어를 써서 고등해진거다.

언어(=생각) 빼면 시체다.

사냥당해서 시체일수도 있고 ㅋㅋ

theorem : brokalang)

brokalang : broca가 broke된 사람도 쓸수 있는 언어.

대표적으로, 조어-의태-초단순언어나 조어-의성-초단순언어가 있다.

이상.

참고로 본인은 "깨끗히는 은는이가"라는 은는이가 증후군 (?) 식의 심한 손상이 있는 사람이 있을것같다고 촉이 오긴 하며, 이러한 베르니케(Wernicke)•브로카보다 더 원초적인 손상이 왜 소개되지 않았는지 궁금하다. 없는걸까?
모두 UG가 존재하는걸까?
과연 UG가 모놀리식일까? 컴포넌트로 나뉜 매우 다양항 feature의 라이브러리형으로 구분하기 어려운건 아닐까?

베르니케 영역이 언어의 의미론적 해석과 이해를 담당한다고 한다. 당연히 이해는 의미론적 해석에 있겠다.
Wernicke's area = Area that Semmentic Value of Voca인 셈이지 않나? 거의 UG의 핵심급으로 보인다.
그러면 문장 "담수는 소금이 없는 물이다"에 대해, 머릿속으로 "Q. 담수가 뭐지? A. 소금없는물"이 안된다는거 아닌가?

그렇다면 그게 내가 생각하는 말하지 못하는 자 아닐까...

내가 맞춰줄 타깃을 찾은것같다...

베르니케 실어증과 브로카 실어증을 쌍으로 걸린 사람은 브로카 실어증이 걸린사람에 비해서 압도적으로 brokalang을 못할것이다..

왜냐면, brokalang은 의미해석이 전제되여야 하고
그럴때 가장 쉬운 단어나열로 동작하기 때문이다.

일단 베르니케 실어증과 브로카 실어증을 쌍으로 걸린 사람을 SP(Semmetic Patient)라 하겠다.

NOTE : SP라 할 필요가 없갰다! 알고보니 전체(Global) 실어증이라고 동일한 뜻의 용어가 있다! 조어를 만들 필요가 없다 크하핫!

작성중...
```

## 보편-개연론

```
# 보편-개연론 (U-P(Universality - Plausibility) System)

앞으로 말하고자 할 개연성은

Logical Coherence (논리적 일관성(Logical Consistance) • 논리적 맥락성 • 논리적 개연성)

도 어느정도 맞고

Likelihood도 어느정도 맞다

그러나 Logical한 측면의 plausibility로 번역하는개 옳다.

귀납 추론을 합리화시키기 때문이다.

두 람다성 우연술어의 정의)

L♡x : L"x의 개연성이 타당하다 할만하다."

L○x : L"x는 보편적이다."

그리고 해당 언어 L은 논의 대상인 언어로써 생략하여 다음과 같이 적을수 있다.

♡x : "x의 개연성이 타당하다 할만하다."

○x : "x는 보편적이다."

개연성의 보편 원리)

"O○(♡x)"

(단. 양상논리에서 당위논리의 경우에는 `□`기호 대신 `O`기호를 쓴다는점을 기억하자.)

당위적으로, 마땅히, x 개연성이 타당하다 할만하다는 판단은 보편적이다.

즉, 개연성은 보편성을 가진다.

## 보편성

보편성은 그 언어에 속성이다.

언어가 변하므로, 보편성이 변한다.

그 사실을 알면 얼마나 언어가 많이 변하는지 세삼 체감하게 된다.

일상•사회생활을 하다보면 정말 보편이 그토록 짧은시간에 많이 변한다는걸 느끼게 된다.

다음 문장을 보자.

Φ(x) : "x는 논리적이다."

논리라는것의 실체는 x s.t. Φ(x)이다.

논리 = x s.t. Φ(x)다.

당연하다. 동명사꼴로 만들었으니까.

따라서, 논리가 성립하기 위해서는

다음 문장

"Φ(Φ(x))는 옳다"

이 옳다고 말한대로여야 한다.

즉, 언어는 논리를 가지기에, 다음이 되는거다.

Φ(x) : "x는 보편적이다"

보편 = x s.t. Φ(x)

이때,

"보편은 논리적이다"는 보편논리적으로 참이다.

즉, **논리적이라는것의 어감에 모두가 이치에 맞는것으로 동의할만한것이다**는 어감이 있다.

그게 왜 참인가?

논리 : "말이나 글에서 사고나 추리 따위를 이치에 맞게 이끌어 가는 과정이나 원리."

그렇다. 논리적이라는것이 이치에 맞으니까 그런 어감이 드는거다.

따라서, 보편이 논리적이라는것은
아오~~~ 욕나오도록
진짜 욕나와서 지우고 다시쓸정도로
아오~~ 너무 당연한 소리다.
```
# 수학이 뭔지 이해해보자.

아, 참, 참고로 수학이라는 이름도 웃기고 모호해보이는 작명이다 ㅋㅋ
차라리 정언함수학은 어떤가? ㅋㅋ 정언(Categoric)이 정해져 있는 뜻이라는 말이니 제격 아닌가?

폰 노이만이 충분히 기존 수를 다루는 목적에서 괴리됬다고 말했을 만 하다.

결론부터 말하자면, 수학은 "정상적" 보존 개념과 "그에 대한" 흐름, 즉 본질까지 (논리, 구조등등 다 포함) 전부 다룬다.
수학은 미치도록 형이상학적으로, 그 기초를 정의해서 정상적 보존 개념과 그 본질을 다룬다.
당연히 그 흐름이 정상적임을 깨면 안될거다. LoL

## 대상의 기하적 측면과, 올바른 대수식이 필연적으로 필요로 하는 논리

수리논리와 수학같은 참뜻(속뜻)이 곧 겉뜻인 언어 (단순언어)는 문장 x, y에 대해, x = y인 경우 뜻이 같다.

x = y : x ⊨ y, y ⊨ x (이때 귀결기호 혹은 만족기호는 귀결, 만족, 건전한 추론 (결론의 논리적(이치에 맞는) 도출) (= 증명되는 논리적 (수리논리적, 논리식값의 흐름) 흐름) 이 함축하는 모델링에서 그 명세나 모델(구성시키는 것 으로써의)로써의 그 구성 흐름의 본질(구성하는 명세-구현 관계, 만족관계의 구성용 측면) 포함))

따라서 의미론적 동등은 같은 뜻(본질)을 다루고, 따라서, 여러 접근 방식에서 보는 측면이 제각기 다른데, 이것이 돋 겉뜻의 의미적 해석 방식이기에, 해석에 자유가 있고, 본질적으로 하나를 가르키므로, 수학의 본질은 그 자유에 있다.

수학적 개념의 실용적 측면이란, 그 개념(본질)을 응용(사용)할때 나오는 해당 개념의 실용적인 측면으로써, 본질이 응용되어 시사하는 측면에 의한, 성질로, 그 본질을 설명할 때, 설명 대상인 본질이 드러난것이다.

어떤 대상을 실용적 측면에서, 기하적 표현으로 나타내어 해석했다고 해보자, 그렇다면 기하가 바로, 이때의 실용적 측면에서 쓰일 실용적 해석에서의 서술 방식, 즉 언어이고, 누구나 아는 사실이다.
따라서, 수학적 대상은 대게, 그것이 기하와 무관한 듯 해도, 실용적 측면에서의 기하적 응용에서 무관하지 아니할수 없다는것이 당연하다.

다음 술어를 보자

weirdHOL(p, Φ, x, y) : if (p) {∀x Φ(x)} else {x ⊼ y}

참고로 if문이 c스타일이라면, 이게 텍스트 문서여서 그런것이므로, 텍스트 문서가 아닌 버전으로 리마스터하면 TeX식으로 내가 바꿨을 수 있다.

weirdHOL은 술어논리를 서술하기에 제격인 언어이다. "p조건이 따라, 인자 Φ, x, y에 대해 Φ를 전칭 긍정하거나, (x, y)를 부정논리곱으로 부정연언문을 만들거나 한다." (joke : 아마도 이후 인자를 1-tuple이나 pair(2-tuple)로 정했다면, 그나마 이해할만한 프로그래머블 스타일이었을거다. 코드가 더럽지만 ㅋㅋ)

솔찍히 말하자면, "《a, b, c, d》"를 "weirdHOL(a, b, c, d)"로 치환하는 문법만 있다면, 내가보기에 이건 완벽한 수학용 형식 언어다 ㅋㅋㅋ

아래 식을 보자.

weirdHOL(1, f(t) = g(t), False, False)

이는 완벽히 모든 방정식을 표현한다.
그러나 우리는 보통 g(t)를 이항 (이항은 Könisberg Axiom에서 설명되는
동등성에 대한 기본정의) (Könisberg Axiom을 모름다면 Lipniz원리로 봐도 된다.) 하여

weirdHOL(1, f(t) = 0, False, False)

꼴로 쓴다.

(fun fact : g(x) = 0을 대입했더니 나온다 야호!)

따라서, 모든 항등식 혹은 방정식은 weirdHOL의 술어부분으로 구성되거나 구성시킬 수 있다.

weirdHOL(0, ⊥, x, y)

(joke : 윗 부분에 식에서 ⊥가 평가됬다면, 우리는 엿을 먹었겠지만, 실제로는 x ⊼ y가 된다.)

위 식은 1 - xy로 참이 1, 거짓이 0일때 모델링 가능하며, 1 - xy가 부정 논리곱이 되는 원리는 대수식의 논리적 흐름을 내가 해설한 내용 안에 있다.

따라서, 대수함수 명세계는 weirdHOL을 구성할 수 있으며, weirdHOL는 ZFC의 실수체와 그 함수를 구성할 수 있다.

즉, 이산적인 논리는 계산을 표로 검증가능하게 이산적으로 대수를 평가한다.

따라서, 정상적으로 동작하는 대수, 즉, 계산을 표로 검산 가능하여 정상적으로 중간에 값이 1씩 바뀌거나 생략되거나 하여 말도안되게 1 + 1 = 1같은 개소리가 나오지 않는 대수를 당연히 가정하고 말하자면,

이산 논리와 정상적인 대수는 본질적으로, 서로가 표현력이 충분할때, 서로 필요하다는것이 당연한 추론이자 귀결이며, 각각의 (수학이라는 학문을 구성하는, 혹은 논리식을 모델링하는) 응용적 측면에서 상호가 상호를 수반하고,

**정상적인 수식의 다룸이 논리를 수반한다.**

## 객체의 보존개념

무한한 테이프가 있다고, 가정하자. 각 테이프 안에는 테이프 자료형을 넣을 수 있다.

그렇다. 이것은 텐서(코벡터)와 유사한 객체를 표현하는 구조이다. 마치 람다나 무한람다가 각각 문법적 구문이나 문자열인데, 함수와 유사한것처럼.

de facto로 똑같은거다.

이제부터 모든 객체는 테잎으로 구성한다.
그것이 우리가 보고자 하는 모습으로 보는 방법이니까.

객체(OOP같은 객체)로써의 측면

자, T ≠ 0임은 T ≠ 0T임을 함축한다.
왜냐? T = 0T면, 0T = 0이기에 이는 모순이기에, 
T ≠ 0임은 T ≠ 0T임을 함축한다.

T + T = 2T이다. 반복된 합이 곱셈이다.

일단은 선형 사상에 의문을 가지지 말자. 
우린 그 명세를 지금 이용하는거다.

자, 그러면 우리는 신기한걸 알 수 있다.

V는 V'을 적용하여 까보기 전까지는 안에 있는 객체를 모든다 (joke : 슈뢰딩거의 고양이 이야기 아니고, 그냥 기호 표기를 편하게 하고싶어서 이런거다.)

X + X = 2X가 항상 성립하는 종류의 객체이기에, 

½V + ½V = V를 만족한다.

즉, V는 개임 아이템같은 마법찰흙이라, 어떤 대상을 자신의 미러디벤션에 가둬놓고, V를 부수는 객체 V'으로 접근하는거다.

V크기가 R배 줄어도 V의 보존개념을 우리는 새놔야 한다.

그러면, 모든 유리수는 표현 가능하고,

V + ¼V + V/9 + ••• = π²V/6 도 있을것이다.

이분탐색을 해보면 쉽게 알 수 있다. 수에 근접하는 방법이, 극한같은 방법이 보인다는것을.

선은 끊어지지 않은 점들의 나열이니, 이를 이용하여, 선분 OP에서 단위길이 OX만큼을 나누기 위해 점 X를 찍고, 직각으로 회전하여, OX'P라는 삼각형과 그와 합동인 OXP'을 그린후 OXP'에서, XP'과 평행한 선분 X'T를 T가 OX위에 오게 그리면, 1:R배가 이해될것이다.


코시수열같은 방법으로써의 꽤나 특이해서 잘못 서술하면 모호한 개념이 실수다.

내가 객체 이야기를 꺼낸 이유는, 결국에 수학은 보존 개념을 서술하기 위한 논리를 준비해서 다루는 학문이기 때문이다.

## 길이 보존

선분의 길이는 보존된다.
이것은 보존 개념의 기하적 해석이다.

객체는 보존된다.

x = x + 1일수 없다는거다.

이것은 이분법적 논리상의 보존개념 동등성의 기하적 맥락이다.

이 언어에서 이치에 맞는거란 간단한 규칙이다.

동일 시간 길이 보존 법칙이라는 규칙이다.

첫번째는, 길이는 제멋대로 늘어나거나 줄지 않는다.
두번때로, 길이는 제멋대로 나타나거나 없어지지도 않는다.
세번째로, 양이 있으므로, 비교가 된다. 같으면 같다.

원 (동심원) 은 원점 O 에서 거리가 OX인 선분 OX에 대해, X가 원주 위에 있다.

어떻게 시도해도 마찬가지다.

나는 개인적으로 유클리드 원론에 따라서, 무한차원의 내적공간을 상정하고, 나머지 제 5 공준을 따르지 않는 이상한 공간은, 대수적으로 구성한거지, 숭고한 기준에서의 근본적인 기하학이 아니라고 본다.
숭고한 기준이서 근본적인 기하학은, 유클리드의 기하학이다. 우리의 표상적이고 이상적이고 가장 근복적이고 순수한 백지의 상태이다.
또한, 실수가 아닌 수는 크기를 비교할 수 있는 수량으로 보기도 좀 거시기 해서, 나는 기하학이야말로 수학의 본질을 가장 잘 표현하는 응용용 도구라고 생각한다. (물론 본인의 감상이다.)

유클리드 기하학은, 그것을 제외한 타 수학분야와 상호 서술할 수 있으므로, 과정이 이르는 여러 과정이 서브루틴화 되었을때, 수학과 서로 동등하게 서술하는 수학의 이미지화라고 생각한다.

수지상새포가 항원을 보여주듯이, 이러한 기하학의 모습이 아릅답다고 생각한다.

# 참고할 글 (스크랩)

## 참고자료 1 : Alkalic

````markdown
# Alalic Preview

이걸 아주 아주 잘 발전시킬거임, 깃헙 커밋으로 ㄱㄱ

거의 됬네 기분좋다.

## DEFINIRION : Alkalic : Alkalic Linear-algebra + Königsberg Axiom + Lambda Incoding Calculate (구문론적 문제로 lambda형식만 유지하고, 폐지, 람다 지분은 없음)

### Alkalic Algbra

∀x (각각 유일)∃!n(x) s.t. n = ObjectID(x) ∈ Scala

 - AlkalicVectorSpace = Scalaᵗ [t := |Scala|]
 - AlkalicMetrixSpace = AlkalicVectorSpaceᵗ [t := |Scala|]
 - SetTheorem ∈ AlkalicMetrixSpace
 - Notation Definition m ∈ n ≡ SetTheoremₒᵢ₍ₘ₎ₒᵢ₍ₙ₎ [oi := ObjectID]

Alkalraum은 여기서, Scala가 객체의 집합으로 확장되어서, |Scala| = κ가 된다.

### Lambda Including Calculate (구문론적 문제로 lambda형식만 유지하고, 폐지, 람다 지분은 없음)

Alkalic Algbra서 AlkalicVectorSpace나 oidfield = Σᵢ ObjectID eᵢ에 대해, 입력받는 Tensor입력으로 ~~람다~~, 대수함수, Alkalic Algbra서 다가함수를 포함한 함수 구현.

---

폐지되었기 때문에

람다를 아예 삭제해서, 람다가 아닌 걍 연산 과정인 Subrootine으로 바꿨다.

Alkalic Algbra서 AlkalicVectorSpace나 oidfield = Σᵢ ObjectID eᵢ에 대해, 입력받는 Tensor입력으로 대수함수, Alkalic Algbra서 다가함수를 포함한 함수 구현.

하는 체계로 바뀜.

연산 괴정이다.

모든 미지수는 이 람다 체계에서 함수 내부변항으로 고정되어서, 두 함수의 합성에서 초기화되어 창출되거나, 아니면 인자로 된다. 따라서, 어떤 수학 이론은 인자를 가지며, 모델이나 진리값배정은 그 값을 넣는다. (어떻게든 대입됨)

변항은 이론에 인자로 설명 가능

### Königsberg Axiom, VectorAxiom, InaccessibleCardinalExistanceAxiom

⊢ KönigsbergAxiom(x, y, Φ) := (x = y → (Φ ↔ (Φ [x := y])))

이때 [x := y]는 단순히 의미론적 대입 연산자.

⊢ VectorAxiom : "모든 벡터 공간은 기저를 가진다"

다음 글을 읽어 보라.
```
먼저 중위표기결합자 * 에 대해, 다음과 같은 표기법을 도입한다, (*x)(y) ≡ y * x
f(x) ≡ (∈x)라고 공역이 치역으로 정의된 f와 g(x) ≡ (=x)라고 공역이 치역으로 정의된 g를 정의하겠다, 이떄, f와 g의 전사함수임이 당연하며, `≡`는 구문론적 등호다, 참고로 정의역은 집합임으로, 해당 집합이 존재해야 들어갈 수 있다, 또한 f와 g는 표기법이기 때문에, 실제 대수적 객체가 아니며, x ∈ f⁻¹(Φ)가 Φ(x)임은 당연하다, 참고로 공역을 치역으로 정의했다는 뜻은, 저 표기법이 표기하는 수학적 객체의 집합은 저 표기법이 표기하는 수학적 객체의 집합이지, 표기법에서 따로 정의하지 않기에, 최소한의 응용이 아닌 공역이 치역이 되지 않는 큰 응용을 하는것을 형식 언어 형식 문법 수준에서 금지한다고 하는것이다. (당연하다고 말한 내용들은 정의가 아니다, 태클을 걸수 있다.), 마지막으로 h̅는 h의 진리값배정이다. 진리값배정을 뜻하는 표기법이다.
외연 공리(Axiom of Extensionality)와 같은뜻인 명제를 보자, `(∀A∀B)(((x∈A) = (x∈B)) → (A = B))` ≡ `(∀A∀B)((f(A) = f(B)) → (A = B))`이기에, 외연공리는 f가 (전)단사함수임과 동치로, 외연 공리에 따라, 외연공리꼴의 다른 표현인 `f가 (전)단사함수이다`는건 외연 공리가 참일떄 참이다.
외연 공리가 의미하는 바는, 외연 공리가 만족되는 조건은, f가 일대일대응으로 동작하도록 정의된것과 같다,
따라서, 지금부터 f는 외연공리를 만족하는 f인 F로 재정의된다, F⁻¹도 외연 공리를 만족하는 f⁻¹과 같음이, f에 대한 F의 정의상 당연하다

짝 공리(Axiom of Pairing)와 같은뜻인 명제를 보자, ∃{A, B} = ∃{x | (x=A)∨(x=B)}인데 (x=A)∨(x=B) ≡ g(A)(x)∨g(B)(x) = (g(A)∨g(B))(x)로, ∃{A, B} = ∃{x | (x=A)∨(x=B)} = ∃{x | (g(A)∨g(B))(x)}이고, ∃{A, B} f({A, B})(x) = f({x | (g(A)∨g(B))(x)})(x) = (g(A)∨g(B))(x)으로, ∃{A, B}  f({A, B}) = g(A)∨g(B)이기에, {A, B} = f⁻¹(g(A)∨g(B))에서, ∃f⁻¹(g(A)∨g(B))가 짝 공리와 동치로, 짝 공리에 따라, 짝 공리의 다른 표현 `∃f⁻¹(g(A)∨g(B))`은 짝  보장될때, 항진이다.
합집합 공리(Axiom of Union)와 같은뜻인 명제를 보자, ∃{x | (x∈A)∨(x∈B)} ≡ ∃{x | f(A)(x)∨f(B)(x)} = ∃{x | (f(A)∨f(B))(x)}에서, ∃{x | (x∈A)∨(x∈B)} f({x | (x∈A)∨(x∈B)})(x) = f({x | (f(A)∨f(B))(x)}) = (f(A)∨f(B))(x)이므로, ∃{x | (x∈A)∨(x∈B)} f({x | (x∈A)∨(x∈B)}) = (f(A)∨f(B))서, ∃f⁻¹(f(A)∨f(B))임이 합집합 공리와 같은 뜻이고, 합집합 공리에 따라, 합집합 공리의 다른 표현 `∃f⁻¹(f(A)∨f(B))`은 합집합 공리가 보장될때, 항진이다.
이때, 합집합 공리과 짝 공리가 다 참이라는 "합집합 공리와 짝 공리가 보장됨 공리"라는 공리를 세우겠다, 이 공리는 합집합 공리는 합집합 공리의 논리식 표현 p와 짝 공리의 논리식 표현 q에 대해 p와 q가 항진이라는 뜻으로 정의된다. 합집합 공리와 짝 공리가 보장됨 공리와 같은 명제를 보자, "합집합 공리와 짝 공리가 보장됨 공리" = "`∃f⁻¹(g(A)∨g(B))`와, `∃f⁻¹(f(A)∨f(B))`임이 보장됨 공리" = "`∃f⁻¹(g(A)∨g(B)), ∃f⁻¹(f(A)∨f(B))`"으로, , 이는, h̅ = (f, g) ⊨ (∃f⁻¹(h(A)∧h(B)))과 같으므로, 우리가 가정한 "합집합 공리와 짝 공리가 보장됨 공리"에 대해 "합집합 공리와 짝 공리가 보장됨 공리"에 따라, "합집합 공리와 짝 공리가 보장됨 공리"의 다른 표현인 `h̅ = (f, g) ⊨ (∃f⁻¹(h(A)∨h(B)))`는 "합집합 공리와 짝 공리가 보장됨 공리"가 참일때 참이다.
멱집합 공리(Axiom of Power Set)는 멱집합의 존재성을 보장한다.

사실 이는 f가 아닌 F에서도 동일하기에, "합집합 공리와 짝 공리가 보장됨 공리"는 외연공리가 성립하는 F에 대해서 다룰수 있다면, "`h̅ = (F, g) ⊨ (∃F⁻¹(h(A)∨h(B)))`"이다.

치환 공리꼴(Axiom Schema of Replacement)의 다른 표현을 보자, 치환 공리꼴이란 무엇일까? 한마디로 치환 공리꼴은 함수 h에 대해, {h(x) | x ∈ A}의 존재성은 A가 존재해야 보장돼야한다는것이다. 한마디로, ∃A ⇒ ∃{h(x) | x ∈ A}이다. 이때, f({h(x) | x ∈ A})(x) = (∃v ∈ A)((h(v) =)(x)) = ((∃v ∈ A)(h(v) =))(x) 이므로, {h(x) | x ∈ A} = f⁻¹(((∃v ∈ A)(h(v) =)))에서, ∃A ⇒ ∃f⁻¹(((∃v ∈ A)(h(v) =)))임이 치환 공리꼴과 동치이다, 따라서, 치환 공리꼴에 따라 치환 공리꼴의 다른 표현 `∃A ⇒ ∃f⁻¹(((∃v ∈ A)(h(v) =)))`은 치환 공리꼴이 보장될때 항진이다.

치환 공리꼴도 f가 아닌 F에서도 동일하기에, 외연공리가 성립하는 F에 대해서 다룰수 있다면 "∃A ⇒ ∃F⁻¹(((∃v ∈ A)(h(v) =)))"이다.

분류 공리꼴(Axiom Schema of Separation/Specification)은 성질 Φ를 만족하는 부분집합이 존재한다는거다, 성질 Φ를 만족하는 부분집합이 존재한다는뜻은 ∀S ∃{x |(Φ(x)) ∧ (x∈S)}이며, ∀S ∃{x |(Φ(x)) ∧ (x∈S)} ≡ ∀S ∃{x |(Φ(x)) ∧ f(S)(x)}이고, ∀S ∃{x |(Φ(x)) ∧ f(S)(x)}라는건 ∀S ∃f(P) = Φ∧f(S)임과 동치이기에, 분류공리꼴에 따라 분류공리꼴의 다른 표현 `f(P) = Φ∧f(S)`은 분류 공리꼴이 보장될때 항진이다, 이후에 분류 공리꼴을 이용하여 집합론에 대해 논하겠다.

ZF안에 ZF를 만든다고 가정하면, 범주론적으로(함자에 대한 서술로) 접근할때, "∃A ⇒ ∃F⁻¹(((∃v ∈ A)(h(v) =)))"안에서 "h̅ = (f, g) ⊨ (∃f⁻¹(h(A)∨h(B)))", "∃A ⇒ ∃F⁻¹(((∃v ∈ A)(h(v) =)))"가 성립한다, 그러나 이것은 ZF내의 ZF에서만 성립한다. `"메타언어가 서술하는 "내부언어에 관한" 구문"`꼴이기 때문이다.

따라서,
ℙ1 : "∃A ⇒ ∃F⁻¹(((∃v ∈ A)(h(v) =)))"
ℙ2 : "h̅ = (f, g) ⊨ (∃f⁻¹(h(A)∨h(B)))"
를 따로 정의하겠다.

공집합 공리(Axiom of Empty Set)와 같은뜻인 명제를 보자, `(∃S ∀x)(￢(x∈S))` ≡ `(∃S ∀x)(￢f(S)(x))` 이고 `(∃S ∀x)(￢f(S)(x))`와 같은뜻인 명제 `(∃S ∀x)(f(S)(x) = F)`는 `x⊥y = x⊥ = ⊥y = ⊥ = F`인 `⊥`정의에따라서, `(∃S)(f(S) = ⊥)`임과 동치이다, 즉, `∃f⁻¹(⊥)`은 공집합공리와 동치이기에, 공집합 공리에 따라, 공집합 공리의 다른 표현 `∃f⁻¹(⊥)`은 공집합 공리가 보장될때, 항진이다.
무한 공리 (Axiom of Infinity)는 자연수 집합의 존재성을 보장하는 공리이다. "모든 자연수 x에 대해, (∃ℕ)(f(ℕ)(x))"는 무한공리와 같다,

정칙 공리 (Axiom of Regularity / Foundation)는 랭크 함수 Rank의 존재성을 보장한다.

이때, 무한 유향 비순환 가중 그래프 preZFSetThoeremModel에 대한 중복도 W를 정의하고, W(x, y) := int(x ∈ y)로 정의하면, (또한, 동시에, 멱집합의 존재도 보장하여 구성하면,)

멤버십 관계 ∈는 분류 공리꼴을 이용하여, 다음과 같이 재정의된다 ((x ∈ y) s.t. (x ∈ y) when (h(x) = Φ(x))) := F(y)(x) s.t. (∀P ∈ 2ᴬ)(F(P) = h(P)∧F(A)) (단. F는 가능한 한 전단사인 표기법이며, 현제의 정의에서 (∃h(P), F(A) ⇒ ∃(x ∈ y)라고 치역이 정의된다)
이는 분류 공리꼴을 만족시키는 정의이다.

preZFSetThoeremModel들 중에서, ℙ1, ℙ2를 만족시키는 preZFSetThoeremModel를 ZFSetThoeremModel라 할수 있는데, 이들 중 공집합과 자연수를 이론 내부에서 논하는 집합으로 가지는 ZFSetThoeremModel는 메타 언어로 동작할 수 있고, ℙ1를 만족시키는 preZFSetThoeremModel들 중에서 공집합과 자연수를 가지는 preZFSetThoeremModel는 ZFSetThoeremModel와 위계 이외엔 동등하다.

더 나아가서, 상수로써 자연수와 공집합을 가지고, 멱집합 연산과 ℙ1, ℙ2를 구성하는 연산이 정의되는 튜링 언어를 이용하는 형식문법 G 문법의 형식언어 L의 모델은 preZFSetThoeremModel이다. 따라서 FOL에서 HOL로 확장가능한 대수공리계에서 모델론과 구문론과 집합론과 논리까지 싹다 서술 가능하다면, preZFSetThoeremModel도 서술 가능하므로, 그런 대수공리계는 ZF와 동등하다. (이러한 모델의 존재성이 참이 된다는 전제하에)
```

저러한 대수 공리계는 존재한다, 예컨데 alkalic이 그렇다.

Königsberg Axiom은 alkalic을 구성하여, 저 조건을 만족한다. 따라서 ZF공리계와 Königsberg Axiom체제 (25.07.16 커밋 이전)는 ZFC랑 그 능력이 동등하다. (상호 서술)

VectorAxiom은 AC와 동치이다, 따라서 Königsberg Axiom + VectorAxiom은 ZFC와 동등하다. (상호 서술)

이때 다음 공리를 도입하자, 아래 공리계는 Alkalic-LinearAlgebra의 ZFC로 구성되었다
⊢ InaccessibleCardinalExistanceAxiom : ∃κ cf(κ) = κ ∧ κ > ℵ₀ ∀λ<κ, 2^λ < κ [cf(x) := least δ ∈ Ord s.t. ∃f : δ → x, (∀i < δ)(f(i) < x) ∧ (∀α < x)(∃i < δ)(α < f(i))]

이때 κ가 Alkalraum의 구성에 쓰인다.

Alkalraum은 κ로 그 크기가 확장된 Alkalic-LinearAlgebra의 객체를 Scala에 포함하는 Hilbertraum같은 (((Scala^κ)^κ)^....)^κ식으로 구성된 κ Rank Covector공간이며, 복소수나 분발복소수/이원수나 2ⁿ원수 등의 행렬표현에서 그 원래 집합의 원소 역할을 하는 객체로의 대응된것 등이 있을수 있는 실수 및 함수 및 객체들로 된 선형대수 텐서공간인데, κ크기를 보장하기에, Grothendieck 우주가 존재하는 ZFC를 표현할수 있어, 여기서 SetTheorem은 자동으로 Grothendieck 우주가 존재하는 ZFC로, 범주론이 서술된다.

## About

이전에 나온 CSFBAlgebra에서 모델론이 안먹히나 했는데 먹힘, 그래서 아이 새로 CSFBAlgebra를 정리(바꿈), 그게 Alkalic.

M = (ℕ, 0 = ∅, s(x) = x ∪ {x}) 대신

수열의 곱을 다가함수로 써서,

M = Π<ℕ, [0 := ∅], [s := λx. x ∪ {x}]>

같은 서수의 정의가 가능하다는 점에서,

이제 Structure와 변수 대입까지 함수 안에서 됬음.

이제 구조체도 non-structial 논리적 귀결에서 씀으로 쓸수있음

에초에 CSFBAlgebra를 대체할 목적으로 만든거니

나머지는 이하 생략.

### Alkalic-Proofmood

KönigsbergAxiom 에 따라서, 

 > 
 > 규칙 `using x = y → (Φ ↔ (Φ [x := y])))`
 > 
 > 원리 : `x = y → (Φ ↔ (Φ [x := y])))`서 `x = y`가 결론 (5번 라인)과 같음을 보임
 > 
 > ```Alkalic-Proofmood
 > □.1. using x = y → (Φ ↔ (Φ [x := y])))
 > □.2. x = y
 > □.3. Φ
 > □.4. Φ [x := y]
 > □.5. Φ ↔ (Φ [x := y])
 > ```

모든 추론은 규칙 `using x = y → (Φ ↔ (Φ [x := y])))`에서 시작되며, 규칙 `using x = y → (Φ ↔ (Φ [x := y])))`는 기본적으로 modus ponens 추론 규칙을 따르기에 타당 (valid)하다. (심지어 Königsberg Axiom이 항진인데, Königsberg Axiom을 제외하고는 대수 연산밖에 활용하지 않기에, alkalic은 건전하다)

(전건부정의 오류 하나 있어서 삭제함)

내부적으로 결론(5번 라인)이 참일때만 계속 동작함, 또한 결론은 리스트에 쌓이면서, 마지막 줄인 Theorem에 도달할때까지 Lemma가 리스트업되서, 문장이 참인지는 Lemma로 보임.

 > 
 > 규칙 : `Starting Listup Hyperthesis`
 > 
 > 미리 Hyperthesis나열을 시작함
 > 
 > 규칙 : `Quit Listup Hyperthesis`
 > 
 > 더이상 Hyperthesis를 받지 아니함
 > 
 > 규칙 : `Starting Another Subproof`
 > 
 > 새 스택프레임을 만들어, 새로운 부분증명을 시작함
 > 
 > 규칙 : `Quit Another Subproof`
 > 
 > 부분증명을 끝내, Lemma List에 추가하고, 스택프레임을 pop함
 > 
 > 규칙 : `APAristotel-y` (nonHyperVersion 형식증명 only)
 > 
 > HAPA Theorem이라는 외부정리를 이용하여서, y = x이고 y = z이면 x = z임을 보임
 >
 > 규칙 : `APAristotel-z` (nonHyperVersion 형식증명 only)
 > HAPA Theorem이라는 외부정리를 이용하여서, x = z이고 y = z이면 y = x임을 보임
 > 

### HAPA Theorem (Hyper Alkalic-Proofmood Theorem)

Alkalic-Proofmood nonHyperVersion 형식증명의 근거.

동시에 유일한 Alkalic-Proofmood HyperVersion에서의 형식증명

`y = x`, `y = z`가 가설일때,

규칙 `using x = y → (Φ ↔ (Φ [x := y])))`를 통하여, `y = z ↔ x = z`를 보인다, 즉,

문법상, `y = z → (y = z ↔ (y = z [y := x]))` = `y = z ↔ (y = z ↔ x = z)`이므로, 

y = z ↔ (y = z ↔ x = z)를 표현하기 위한 잉여적인 체계다.

(그치만 이전에 있었던 전건부정 오류때문에 또 고쳐야함 ㅠㅠ)

## Alkalic-Proofmood (Power Up - Version)

증명에 앞부분에 붙여야 할 한정사가 추가되었다, 부분증명을 만들어서 중첩 가능하기에, 각 기능을 동시에 붙일수 없다.

 - AristotelProof(비 명시시 기본) : 기존 증명 방식으로 증명
 - DavidHumeProof : Φₜ에 대해, t번 라인마다 매거적 귀납법을 쓰고, 옆 열에는 Φₜ가 귀납법 증명에 쓰이는 경우, 쓰는 칸이 된다. 맨 마지막줄에, 번호 없이, 귀납법 증명의 종류를 기재할때, `∴ Φₜ, Φₜ₊₁, ..., Φₖ ⊨ Φₖ₊₁` (강함), `∴ Φₖ ⊨ Φₖ₊₁` (약함), `∴ Mod(Φ) = ℕ` (일반적인 수학적 귀납법) 으로 기제한다.
 - EuclidianProof : 귀류법 (HegelianProof랑 다르다, 귀류법이다) ; 반증 마지막에, `∴ ⊥ ∴ ⊭ ¬
Φ ∴ Φ`를 놓는다. (`¬Φ`는 결론을 뜻한다.)
 - HegelianProof : 반증 (결론이 부정이 나오므로, "결론이 아니다"를 증명할때 쓰임; 왜냐하면, 기존 버전에서는 논리적 오류가 나오면 오류위치를 지적하고 프로그램이 종료됬기 때문에, 오류를 만들어 반증한 후, 종료하지 않는 AristotelProof가 필요했음)



또한 검증 프로그램 정지를 피하기 위해,

 - PreviewVersion : 이 부분•전체 증명에 대해서, 프로그램 정지 후 오류 지적을 제외하고, Preview리스트에 추가한다, 근거 없는 부분이라, 이걸 단 증명을 참고해서 에러나면, "Referance on Preview"에러 로그를 따로 뱉은 후 평상시 에러처럼 에러난다
 - DebugVersion : 오류가 나는대로, 디버그를 해주며, 훓고 지나간다, **프로그램 전체에 적용된다.**
 - ConjureVersion : 추측으로써, 정지를 피할곳에, `�`를 삽입한다, 이 부분•전체 증명은 가설(Hyperthesis)로 취급된다.
 - NormalVersion (비 명시시 기본) : 기존 방식



마지막으로, 다항식의 계산을 원활하게 하기 위해,

`Polynomial Simplify`라는 부분증명 폼을 넣고 다음을 인수분해하거나, `P(x) = 0`꼴을 풀면 (후자는 미리 `using P(x) = 0 Algorithm`이라고 명시) 오류 없이 증명을 받아들여준다.

A. `LinearSimplify`명령을 통해, LinearSimplify Theorem에 근거하여, 미지수가 여러개인 일차식을 정리한다

B. `Substracting [y := xⁿ]`명령을 통해, xⁿ을 y로 치환한 문장 `Φ`에 대해, `Substracting Variable`필드에 넣은 참인 문장 `y = xⁿ`에 따라서, Φ [y := xⁿ]가 나올때까지, 미리 일차식마냥 치환한 상태로 작업하게 해준다. (치환 변수 필드 논법; `Substracting Variable Field Proofs`)

C. `Solution (a, b, c, d, e)`명령을 통해, 2차 ~ 4차식을 인수분해(근의공식) / 전개(비에트의 정리)한다.

D. `TschirnhausTheoremSubsituate (n, a, b, x)`명령을 통해, `[x := t + b/na]`를 적용한다, 마찬가지로 증명의 원활함을 위해 Substracting명령에 근거한다 (사실 그럴 필요도 없이 구문론적으로 연산자를 정의해도 되는 간단한 문장(`[x := t + b/na]`)이지만)

E. 부분증명 문법에서 `synthetic division` 한정사로, 조립제법 이용 (생략표기가, 매거적 귀납에서 고정된 열의 다수의 행에대해 쓰이므로, 여기서는 쓸때, 행을 다항식으로, 계산 과정순이 열로 되므로, 돌려봐야하는 단점이 있다.)

F. `Alright synthetic division`한정사로, 일반적인 조립제법을 쓰고, 전처리 단계에서 synthetic division로 컴파일

G. 분배법칙을 위해서, `distribute[ 대상 ]` 안에 전부 넣어가지고, 이 증명 시스템용으로 있는 `분배법칙의 일반화 정리`에 따라, 분배함

H. `AlgebraicFormula` : 미리 증명한 곱셈공식을 이용해서, 계산되었음을 명시한다.

I. Gaussian Eimination or ERO & Subsituate : 가우스 소거 혹은 가감/대입

J. System of Quadratic Equations by Quadratic Form : 이차형식으로 연립이차방 풀이

K. System of Quadratic Equations by Cubic Form : 삼차형식으로 연립삼차방 풀이

L. Règle de Cramer : 크래머의 공식으로 풀이

M. `Extraneous Root is (□)` : 무연근 명시

N. `PolynomialFractionize` : 다항함수 분수화

O. `SolvePolynomialFraction` : 해당값 풀이

P. `Fractions Solution is (□)` : 해 명시

### 형식증명의 오토마타용 문법

`□.` 라인이 부분증명이라면, `□.line.`식으로 라인을 표기한다.
그리도, 라인과 라인 사이에 오직 whitespace및 `-`,`–`,`—`만 있을경우 해당 라인을 가독성 용도로 보고 주석처리한다.

또한, line표기에 앞선 점찍은 부분 앞에서 `|`부분이 문자열의 특정 열마다 이어지고, 끝나는 말단이 앞서 설명한 `-`꼴의 주석에 연결되어있다면, 해당 부분도 따로 오류처리하지 않는다.
그외에는, 열 구분자이기에 주석으로 보지 않는다

마지막으로, `[NOTE : ]`형식을 주석으로 본다.

마크다운 문서 내부에 위치했다면, HAlkalic-Proofmood(Hyper Version), Alkalic-Proofmood(일반 버전), PowerAP(Power Up버전)으로 코드 이름인 부분만 읽는다. 또한, 마크다운 부분에 부분증명 코드부분은, 부분증명으로 렌더링한다.

마지막으로 그렇게 html화되어 정리된 렌더링 뷰는, LaTeX 표기 기능을 추가해야만 할것이다.

(그럼에도 해당 html뷰는 아직 형식증명 검토가 안돌아갔으므로, 컴파일 상태인거지, 실행 상태가 아니다. 실행은 실행기에 돌려야, 문서 내부를 파싱해서, 부가적으로 제공된, [labare](https://faraway6834.github.io/unbeauty/privateNote/Proof/labare)•[unbare](https://faraway6834.github.io/unbeauty/privateNote/Proof/unbare) 코드와 함깨 해석하여(labare•unbare는 인터프리터 언어가 아니고, 정형 대이터 겸 사용자 편의 대이터 겸 Low Level 컴파일 언어다.), 검토된다; 이제보니 실행기보다는, 형식증명 검토기라는 명칭이 더 적합하다, 프로그래밍 언어는 하나도 실행하지 않고, 추론규칙을 재대로 활용했는지만 검사하여 검토작업(오류나 로그나 상태 표시)만 하기 때문이다.)

---

### 두번째 글 : `논리적으로 다룬다 전재할때, 대수식은 논리적으로 그 뜻이 해석 • 계산된다.`의 발췌

그렇지 아니하면, 논리적 해석 흐름에서 논리기호가 도출될수가 없다.

식의 계산은 그 값의 배정인 (x̄, f(x̄))와 같이 이루어지는데, 이 방식을 거부하는것은, 논리를 쓰지 않겠다는 말과 같다. (장자 왈 갓나서 죽은 아기보다 오래 산 사람은 없으니 팽조(760살이 넘게 살았다는 전설 상의 신선)도 일찍 요절한 사람)

#### 대수식의 논리적 해석 흐름에서 논리기호를 도출하자

먼저, 다음을 보이겠다

> 함자 `f :≜ (-F)` 를 정의해서, 여기에 대해,

`x = y 이면이 f(x) = f(y)`

이말은, 진리값 T, F를 다루는 식에서, F = 0으로 가정하고 푸는거나, F ≠ 0이 아닐때 푸는거나, 전부 x = y인 등식을 쓸때 f(x) = f(y)가 F와 무관히 동등함이 당연함으로, F = 0인 경우로 잠정적으로 취급하겠음

##### 대수식의 논리적 해석 흐름중 논리적 귀결관계의 도출

Step.1. 방정식을 만족하는 집합으로써의 모델집합이 해집합임을 보이자

먼저, 다음과 같은 다항식 함수 P를 정의하자.

> `P :≜ λA. λx. Πᵢ x - Aᵢ`

그리고 다음과 같은 방정식화 논리함수 Φ를 정의하자.

> `Φ :≜ λf. (f(x) = 0)`

그리고 마지막으로, 다항 방정식 ㅍ을 정의하겠다.

> `ㅍ :≜ φ • P`

그러면,

> `Mod(ㅍ(A)) = {x | x ⊨ (Πᵢ x - Aᵢ = 0)} = {x̄ | Πᵢ x̄ - Aᵢ = 0} = {Aᵢ | ∀i}`

임이 당연하다.

---

Step.2. 논리적 귀결관계의 도출

다항방정식 ㅍ(A), ㅍ(B)에 대해,

0. Mod(ㅍ(A)) ⊆ Mod(ㅍ(B))
1. {Aᵢ | ∀i} ⊆ {Bᵢ | ∀i}
2. ∀i Aᵢ = Bᵢ《주의 : 비약이다, 저건 배열을 정렬해야만 성립한다.》
3. ∃C P(B) = P(A)P(C)
4. P(A)|P(B)

으로,

> 
> 다항식 f, g에 대해 다항방정식 Φ(f) ⊨ Φ(g)
> 
> 이면이
> 
> f | g
>


##### 대수식의 논리적 해석 흐름중 진리값 배정되는 명제논리 결합자의 도출

¬x = T - x로 해석됨을 보이자. (경고 : 형식증명 아님)
A. proof of `x ≠ T ⊢ T ± x ≠ (1 ± 1)T`
0. `x ≠ T` (비 귀류법식 전제 문장)
1. `T ± x ≠ T ± T` (이항 by 함자 `(T ±)`)
2. `T ± x ≠ T ± T = (1 ± 1)T` (1번의 연장선에서 계산)
3. `T ± x ≠ (1 ± 1)T` (2번에서 식 요약) ⋯ ■

B. proof of `⊭ (1 + 1)T = 0 ∨ (1 + 1)T = T`
0. 먼저 part A by `⊭ (1 + 1)T = 0`와 part B bt `⊭ (1 + 1)T = T`로 나눠서 생각하자.
1.A. (1 + 1)T = 0 (귀류법식 전재 문장)
2.A. (1 + 1)T = 2T = 0 (1.A.번의 연장선에서 계산)
3.A. T = 0 ⊨ 2.A. ⊨ (1 + 1)T = 0 (연역)
4.A. ⊭ T = 0 ⊨ 2.A. ⊨ (1 + 1)T = 0 (연역)
5.A. ⊭ (1 + 1)T = 0 (연역) ⋯ ⊥
6.A. ∴ ⊭ (1 + 1)T = 0 (연역) ⋯ ■
1.B. (1 + 1)T = T (귀류법식 전재 문장)
2.B. (1 + 1)T = 2T = T (1.B.번의 연장선에서 계산)
3.B. T = 0 ⊨ 2.A. ⊨ (1 + 1)T = T (연역)
4.B. ⊭ T = 0 ⊨ 2.A. ⊨ (1 + 1)T = T (연역)
5.B. ⊭ (1 + 1)T = T (연역) ⋯ ⊥
6.B. ∴ ⊭ (1 + 1)T = T (연역) ⋯ ■

C.1. A, B ⊨ (x ≠ T ⊢ T - x ≠ (1 - 1)T) (A, B번에서 귀결)
C.2. A, B ⊨ (x ≠ T ⊢ T - x ≠ (1 - 1)T = 0T = 0) (C.1.번의 연장선에서 계산)
C.3. A, B ⊨ (x ≠ T ⊢ T - x ≠ 0)  (C.2.번에서 식 요약)
C.4. A, B ⊨ (T - x = 0 ⊨ x = T ⊨ x) (C.3.번에서 연역추론 : 대우) 《주의 : "x = T"의 의미를 "진리값 x가 참"관점으로 해석함.》
C.5. A, B ⊨ (T - x = 0 ⊨ x) (C.4.번에서 식 요약) 《주의 : 근거인 C.4.에서 "x = T"의 의미를 "진리값 x가 참"관점으로 해석함.》
C.6. C.5.번 내용 ⊢ ¬x = T - x (최종결론)《주의 : "x = T"의 의미를 "진리값 x가 참"관점으로 해석함.》
Q.E.D.

x ∧ y는 xy로 해석됨을 보이자.
T에대한 방정식 (T - x)(T - y) = 0의 해는
x = T ∨ y = T이다.
따라서, x = T ∨ y = T ⊨ T - (T - x)(T - y) = T고,
x ∨ y = T - (T - x)(T - y)로 해석된다.

이때 De Morgan's Law, ¬(¬x ∨ ¬y) = x ∧ y서

T - T + (T - T + x)(T - T + y)
 = xy이다.
 ⋯ Done.

##### 방정식의 의미 : 술어논리(함수논리)의 술어로써, 잠정적으로 특칭양화사를 사용해, 잠재적으로 전칭양화사를 사용함.

방정식 P(x) = 0이 불능이란것은

∄P(x) = 0란 뜻이며

∀P(x) ≠ 0이란 뜻이고 ⋯ ①



방정식 P(x) = 0가 불능이 아니라면

∃P(x) = 0이다. ⋯ ②



방정식 P(x) = 0이 부정이란것은,

부정방정식이므로,

∀P(x) = 0이다. ⋯ ③



①에서, 불능형 방정식 P(x) = 0에 대해,

P(x) ≠ 0은 부정형이고, ⋯ ④



부정형 방정식 P(x) = 0에 대해,

P(x) ≠ 0은 불능형이다 ⋯ ⑤


그렇다면 ③에 따라 다음을 정의하자,

> `Φ :≜ λf. (∃f(x) = 0)`
> 
> `P :≜ λf. (∃f(x) ≠ 0)

그러면 다음을 알수 있다.

④에 따라, Φ(f)가 거짓 이면이 P(f)는 부정형
⑤에 따라, Φ(f)가 부정형 이면이 P(f)는 거짓

Φ(f)가 참 이면이, f(x) = 0를 만족시키는 x존재
P(f)가 참 이면이, f(x) = 0을 불만족시키는 x존재

부정형 방정식을 만들고 싶다? 하면

¬Φ(f) = P(f), Φ(x) = ¬P(f)에서,

불능형 방정식 Φ(f)에 대해 부정하거나,
불능형 방정식 P(f)에 대해 부정하면된다.

술어 P에 대해
Mod(P) = ∅ 이면이 ∄P(x) 이면이 ⊭ P
이면이
Mod(¬P) = U 이면이 ∀¬P(x) 이면이 ⊨ ¬P

따라서, 방정식은 기본적으로 특칭 술어로써, 사용할수 있음
````

## 참고자료 2 : 의외성 정리
```markdown
# 의외성 정리

## 용어 정의

 - True Mean (참뜻) : 의외성(속뜻)
 - Shell Mean (껍대기 뜻; 쉘 민) : 겉뜻
 - 속뜻 없음 (Exceptless) : Shell Mean = True Mean
 - 초완전성 (Hyper-Completeness) : "This sentence is False"를 허용하는것.
 - Black and White Proposol : ⊢ (¬Hyper-Completeness)
 - Simply Mean Proposol : ⊢ Exceptless
 - 단순언어 : Simply Mean Proposol이 항진인 언어

### 흑백논리와 형식언어의 정체에 대한 고찰

Black and White Proposol를 공리로 하는 논리를 흑백논리라고 부를수 있음이 당연하다

또한 흑백논리중 단순언어인것이 형식언어인것이라도 보면 된다.

#### 정리 문단에 따른 보조설명

우리 언어는 보이는대로 해석해야하는것과 아닌것이 있어,

보이는대로 해석해야하는것을 단순언어 (이 경우 언어 해석에 예외가 없이 보이는대로 닥치고 그뜻이다)

그리고 단순 언어가 아닌 언어 (이 경우, 언어 해석에 여러 의외성이 끼어들기에, 단순히 보이는 뜻을 뜻으로 단정할수 없다)가 있다

또한 논리는 장자철학처럼 "갓나서 죽은 아기보다 오래 산 사람은 없으니 팽조(760살이 넘게 살았다는 전설 상의 신선)도 일찍 요절한 사람이다"가 맞을수 도 있지만,

흑백논리에서는, Black and White Proposol을 참으로 하여, x이면서 동시에 x가 아닌것은 불가능하다. (Fun Fact : 흑백논리이면 단순언어임이 논리적 귀결이다)

## 공리

1. 말의 뜻은 True Mean과 Shell Mean이 있다

## 정리

### TrueMean Theroem

Hyper-Completeness 일때도 "말의 뜻 ≠ True Mean"마저 True Mean으로 True Mean(결국 전제로 한 참인 문장에서 연역(이때는 초완전땜에 가능)으로 "말의 뜻 = True Mean")이고 (Hyper-TrueMean Lemma)

Hyper-Completeness 가 아닐때도, "말의 뜻 = True Mean"이므로, 말의 뜻 = True Mean으로 (Formal-TrueMean Lemma)

말의 뜻은 True Mean을 말한다. (TrueMean Theroem)

A. Formal-TrueMean Lemma
 - ¬Hyper-Completeness, ⊭ 말의 뜻 ≠ True Mean ⊢ 말의 뜻 = True Mean

B. Hyper-TrueMean Lemma
 - Hyper-Completeness, 말의 뜻 ≠ True Mean ⊢ 말의 뜻 = True Mean

C. TrueMean Theroem
 - 말의 뜻 = True Mean

Proof)

1. 말의 뜻 ≠ True Mean [Hyp]
2. Hyper-Completeness [Hyp]
3. "말의 뜻 ≠ True Mean"라는 점도 True Mean임
[Paradoxic Lemma]
3. "말의 뜻 ≠ True Mean"라는 점도 True Mean이고 참이기에, 말의 뜻 = True Mean임
4. 말의 뜻 = True Mean

이하에서,

말의 뜻 ≠ True Mean, Hyper-Completeness ⊢ 말의 뜻 = True Mean ⋯ (1)

1. 말의 뜻 ≠ True Mean [Hyp]
2. ¬Hyper-Completeness [Hyp]
3. "말의 뜻 ≠ True Mean"라는 점도 True Mean임 [Paradoxic Lemma]
4. 모순

이하에서, ⊭ 말의 뜻 ≠ True Mean ⊢ 말의 뜻 = True Mean

(1), (2) ⊢ 말의 뜻 = True Mean

Q.E.D.

#### 해설

항상 True Mean만 말의 뜻임을 증명하자,

True Mean이 뜻이 아닌 말이 있다고 가정하자,
그렇다면 그 말은 True Mean이 뜻이 아니라는 뜻이 True Mean이 된다

이것이 Paradoxic Lemma다

이하에서 Hyper-Completeness에 따라 참인 경우와 거짓인 경우로 나누어 논증하자.



상황 1. Paradoxic Lemma에서, Hyper-Completeness인 상황

Paradoxic Lemma가 참이될수 있으므로, Hyper-TrueMean Lemma가 참이다

상황 1 종료



상황 2. Paradoxic Lemma에서, 비 Hyper-Completeness인 상황

Paradoxic Lemma이 모순이므로, 전재인 "말의 뜻 ≠ True Mean"이 거짓이다.

따라서, Formal-TrueMean Lemma가 참이다

상황 2 종료



이하에서,

상황 1, 상황2에 따라, 연역,
항상 True Mean이 말의 뜻이 된다.

따라서, TrueMean Theroem이 참이다

Q.E.D.

### Exceptless Thorem

Exceptless ⊢ 말의 뜻 = Shell Mean

Proof)

1. Exceptless [Hyp]
2. 말의 뜻 = True Mean [TrueMean Theroem]
3. Shell Mean = True Mean
4. 말의 뜻 = Shell Mean [결론]

이하에서, `Exceptless ⊢ 말의 뜻 = Shell Mean`임이 당연하다.

#### 해설

앞서 증명한 TrueMean Theroem에 따라,

말의 뜻 = True Mean

Shell Mean = True Mean 이면, 그리고 이때만 Shell Mean = True Mean이다

(쉽게말해 A = B = C니 A = C)
```
