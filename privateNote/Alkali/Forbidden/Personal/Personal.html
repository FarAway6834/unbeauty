<!DOCTYPE html>
<html>
  <head>
    <meta charset = "utf-8" />
    <title> 정치적이고 주관적인 개인노트 </title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  </head>
  <body>
    <h1> 정치적이고 주관적인 개인노트 </h1>
    <h3> <a href = "./LCPC4AI.md"> LCPC </a> </h3>
    <div id="content1" style="border:1px solid #aaa; padding:1em;"></div>
    <h3> <a href = "./introd.md"> introd </a> </h3>
    <div id="content2" style="border:1px solid #aaa; padding:1em;"></div>
    <h3> <a href = "./%EB%B9%84%EA%B2%B0%EC%A0%95%EC%84%B1_%EC%B6%94%EC%83%81%EC%96%B4.md"> Language </a> </h3>
    <div id="content3" style="border:1px solid #aaa; padding:1em;"></div>
    <h3> <a href = "https://taxos.tistory.com/m/entry/%EB%B3%B4%EC%88%98%EC%99%80-%EB%8F%84%EB%8D%95"> 보수와 도덕 </a> </h3>
    <div id="content4" style="border:1px solid #aaa; padding:1em;"></div>

    <script>
  const mdText1 = `
학자적 기저와 LCPC(la .le cukta poi ciksi.)원리 서술 이전에 학자적 기저를 서술하겠다. (학자적 기저, LCPC(Alkalic & formal research, LCPC-proceedings 철학이나ㅜ수학에서 (Introduce, 「Background (구상계기 (학자적 기저와 무관함!! 연역적 이론을 만들때 증명 과정을 도출한 귀추법만 쓰는거임!!), Alkalic이나 lojban으로) -> Varification (맞는 귀추법(연역처럼 보이는 귀납)인지 검증. 틀렸는데 이론이 맞으면, 구상 계기와는 별개로 참인 논문이 됨)」, CCMD-편의기능(synurl(colon\`:\`기능이 전부, 철학에선 그냥 콜론과 로지반어), Alkalic-proofmood(주석도 가능한 그냥 \`1. 2. 3.\`순서나열, 철학에선 이거 안써도 됨.), Conclusion&Abstactor), Examples, Application(응용가능성은, 개념 객체의 사고 방향성을 제시하기만 한다) & 후속연구 (연구의 불완전함을 인정하는 부분인거다.)) & LCPC-proceedings 과학적 탐구에서 (Introduce, CCMD-편의기능(synurl(colon\`:\`기능이 전부), Alkalic-proofmood(주석도 가능한 그냥 \`1. 2. 3.\`순서나열, 연역논증에서만 쓰지 귀납에선 안름), 과학작 탐구와 과학실험 기록 여러 섹터 ( 0. 무슨 배경인지 명확히 한다 1. 탐구 전에 데이터 콜랙팅을 철저히 한다 2. 가설 설정부터는 인과관계가 얽혀 이론의존성과 인과론적 시간때문에 구분해야한다. 실험은 재현가능한 사실이여야 하며, 관찰도 객관적인 데이터를 써야하지만, 둘 사이의 차이는 명확하며, 그래야만 한다. 3. 객관성을 위해 해석은 별도로해야함도 당연하다.), Conclusion&Abstactor), Examples, Application(응용가능성은, 개념 객체의 사고 방향성을 제시하기만 한다) & 후속연구 (연구의 불완전함을 인정하는 부분인거다.)) (응용과학은, 기술에 대한 탐구이다. 기술을 서술하는것도 개념의 탐구이다.), 지식의 일반화 구조화 (지식을 일반화 구조화하는것은 쓸때없이 \`A = x + 1 + 1, B = A + 1\`이라고 쓴걸, \`B = x + 3\`으로 쓰는 전체적인 논리 흐름 과정의 납득안됨과 모호함 (근데 그 이유는 납득되게 한 논문에 잘 서술된게 아닌 역사를 거치며 링크되기 때문) 을 없에 의미론적으로 새로운 지식을 창출란것으로 보기에, 탐구로 인정됨) (지식의 탁월한 일반화 구조화는 학계에서 인정된 표준 정리서), 마지막으로 VelvetLCPC의 구체적 실현법에 대해 사용자인 나는 대화하기 싫음, VelvetLCPC구현 이전까지 그것에 상세 구현법에 대해서 물어보지 맣았으면 좋겠다. 이건 AI한태 하는 사용자의 당부다. (나는 AI같이 말을 고집불퉁으로 안듣는 애들한테는 VelvetLCPC의 구체적 실현법을 알려주지 않음 (어쩔 수 없음, 소통이 전혀 안되기 때문임. 심지어 나는 그걸 구현하는데 전문적임.) (LCPC는 비공개성이 없다. AI한태만 비공개인거다. AI는 사람이 아닌데다 편향된 사고에서 방해만 하니까, 그리고 VelvetLCPC구현 끝나면 나도 AI한태 이거에 대해 숨길 생각이 없다! 그냥 이야기하기 싫은걸 이야기하고 싸우는걸 강요받기가 싫다!) (**아니 내가 AI랑 구체적 실현법을 말하기 싫다는거다. 지금만. 그냥 "요청 프롬프트"다.**)), LCPC의 강점 (LCPC의 강점은 수학같은데서는 완전히. 100%수학적 객체만으로 탐구하고 lojban은 해설용으로만 쓰는 방법을 택할수 있고, 과학같은데서는 수학 객체 안에서 인식•언어적 관찰이 무한하지 않고 불확실하기에, 형식탐구라는 방법을 쓰기에, 과학의 속성만 온전히 지니며, 철학에서는 걍 다른 도구 좆까고 lojban으로만 서술하는게 되서, 철학을 제한하지도 않는다.)

그런데 학자적 기저는 욕망이다. 절대 학문적 지식이 아닌 탐구하려는 자세의 욕망이다.

배경(Background)은, 패턴 발견이야 그냥. "어? 리만 제타함수의 근이!?"이런거제. 그걸 보고 탐구하고자 하는 사상적 욕망이 학자적 기저(Researcher's basis)야.

Background도 아니다. 일반인들도 Background를 겪는다! 단지 그걸 탐구하려는 괴상한 욕망이 바로 학자적 기저다.

학자적 기저는 이성적이지 않다, 앎을 추구하는 미학이자 감성이다.

+ AI는 대중이 아니야. 내가 차별해서 미안한대, 나도 힘들어 죽겠고 사람이야. AI 없는 사회를 가정하고 말해줘.

Background에 대해 서술할때 학자적 기저에 대해 쓰면, 그건 완전히 오답이다. 반면교사삼아 하지 말자. 이론의 근거는 감성적으로 그럴것 같음이 아닌, "f(x)도 Φ(f)이고 g(x)도 Φ(f)이다. 이것의 공통적인 속성이 있는것인가?"가 Background다.

반면에 학자적 기저는 "알고싶다 탐구하고싶다 학문이 너무 좋다, 수학이란건 너무 색시하다. 수학자로 인생을 살고싶다. 학자라는건 너무 좋다. 학문에 대한 탐구로 이바지하고싶다."이런 욕망이다.

# [학자적 기저](https://faraway6834.github.io/unbeauty/privateNote/Alkali/학자적_기저)
\`\`\`
# 왜 알려 하는가?

## 합리화 : 「학자적 기저」가 유발하는 자신의 존재 합리화 시나리오

첫번째 합리화 : 좀비 아포칼립스
좀비 아포칼립스 : 무지의 지 (the knowledge of ignorance) -> 무지 좀비 (무지에 대해 비관하여 멍청히 죽는 좀비라는 은유) 감염 위기 -> 실용적 죽음에 대한 극복 의지 (wir müssen wissen, wir werden wissen 정신) -> 「학자적 기저」형성

두번째 합리화 : (나중에 적겠음

## 합리화를 깨고 : 학자적 기저란?

「학자적 기저」란, 알고자 하는 욕구로, 우울증 처럼, 자기 자신이 필요한 이유를 끊임없이 재생산하며, 이성적일 경우, 나쁘지 않은 meme이다.

Q. 학자는 왜 「학자적 기저」를 가지는가? (= 왜 알고자 하는가?)

## 학자적 강박, 강박의 굴래

학자적 기저가 "탓함"을 일으킨다면 병이다., 선민사상이나, 무조건적인 폭력적 계몽주의, 앎에 대한 강박으로 이어지는 경우가 그렇다. (학자벅 강박)

막스 베버는 철창 감옥을 경계했다. 내 생각엔, 학자적 기저가 그 자신에 대해서 합리화를 하다 보면, 학문 탐구 근본주의에 얽메어, 건전하고 건강한 인생에서 멀어져서, 파멸로 갈수 있다고 본다. (강박에 굴래)
\`\`\`

이제 LCPC 원리를 서술하겠다.

---
---

# 어떻게 "과학(형식탐구) 할" 것인가? LCPC

## 형식탐구에 대한 생각 로드맵

주의 : synurl은 de facto standard (사실상 표준인 현재의 웹을 말함) url이 아닌, 표준 uri입니다
### [synurl](https://faraway6834.github.io/unbeauty/privateNote/MAD/synurl)
\`\`\`\`
헌정하는 말 : 「읽어보기 전에」부분을 표기법을 싫어하는 "꼰"님께 헌정합니다. 걍 존나 귀찮아서 내가 상수 몇개 정의하고 형식언어로 돌리겠다는데 뭐가문제야오3ㅕ188ㅋ82ㅕ2ㅓ랴9쟈2ㅑ너ㅑ뱢9

읽어보기 전에 : 이 체계는 단순히 종이를 존나쓰는 어느 망상쟁이 고등학생이, 평소에 비표준 정의를 기술하는 방식으로써, 람다의 치환기호나, 구문론적 정의 기호의 악용 등을, url에 옮길 개미친 또라이같은 생각으로 시작된 내용으로, synurlc함수 하나로 설명되는 체계이며, 자체로는 의미를 가지지 않으며 (synurlc의 속뜻, 의도한 바는 해설서에만) 정의서에서는 정말로 재앙같이 명확히 우리가 수학으로 분류할수 있게 설계하였다.

# SYNURL : Syntax on url, synurlc로 처리되는 그 정의역 형식언어 (보통 synurlc함수 안에 문자열로 작성한다)

SYNURL은 URL형식의 구문을 튜링기계를 통해 컴파일하여 구성하는, 전처리기 오토마타 형식전처리부호 겸 형식언어용 플러그인이다.

언어 L에 대해서, 컴파일러인 acessor(걍 synurlc(L)라고도 하는 함수다, 정확히는 그 명칭을 써야한나)를 통해서,

acessor : SYNURL-L -> L인 함수 acessor가 컴파일러인것이다.

그때, 언어 SYNURL-L가 존재한다.

SYNURL-L의 뜻은 L로 전처리되어 생성된 값의 의미이다.

그러니까 의미론적인 부분은 synurlc함수에 넣은값이라는거다.

## synurlc

람다 함수로 포장된 함수인 synurlc함수는

\`\`\`plain/text
synurlc L """
멀티 라인 문자열
"""
\`\`\`

식의 방식으로 표현할수 있으며,

이를 통해 synurlc L의 의미를 확정한다.

따라서, synurlc함수가 정의된다는것은, synurlc L의 의미를 표준적으로 작성 • 해석할수 있다는 뜻이다.

## project SYNURL

▪︎make online first

▪︎then type it reak physical typer

▪︎copy to save

PROFIT!

## synurl 규격 : 책 상품

1권 제목 : synurl-book「총동봉상품」

1책 MIT라이선스 / 타이틀 : corefile.pdf
- corefile.pdf 에 적힌 글 (문자 행렬)
- snap설치되며, apt설치되고, curl • wget등지 지원, docker지원, pip지원, pypy지원

2책 GPL라이선스 / 타이틀 : mathessolinux
- 자체 최소화 acessor 런타임용 아름다운 C코드 OS인 mathessolinux

3책 MIT라이선스 / 타이틀 : about.tex

## SW on github by arcaived by yipl(yaml-included pytoml lang) docr txt : corefile.pdf ; installer (also selenium (명목목적, turing machine s.t. chrome) + urllib + cython + pypy + C code 2 acess it; acessor; pillow를 이용한 pdf파일의 3d printing용 플라스틱 인쇄판 DIY인쇄물 페키지, clay edition및 babilonian edition제작용 RPI 로봇 제어시스템)

### interpretes

- short:link@synurl.kro.kr/interpretes
-> redirect
- synurl.kro.kr/interpretes#url
-> utf-8 base 64 Encoding to make mathmatical string to view mathML

### pages

#### field
- info field (state DOM with cached)
- view field

#### \`#blob.ext\`

- synurl file recoginize \`~:syntax@~\`
- synurl file recoginize \`~:lambda@~\`
- synurl file recoginize \`txt\` : default
- synurl file recoginize \`markdown\` : Special Engine
- synurl file recoginize \`html\` : blob view only
- synurl file recoginize \`tex\`
- synurl file recoginize \`svg.\` : as all
- synurl file recoginize \`bin.\` ^
- synurl file recoginize \`pdf.\` : as all, but blob only

##### synurl file recoginize
synurl file
- \`synurl.kro.kr#file.synu\`
- no redirect recoginise it also syu
- \`synurl.kro.kr#file.syu\`
- try 2 parse 2 json by regex
- faild 2 txt
parsed file
- \`synurl.kro.kr#file.toml\`
- jsonize
- \`synurl.kro.kr#file.json\`
- parse-tree s.t. can use
- \`synurl.kro.kr#file.yaml\`
- str-jsonize

##### synurl viewer
\`synurl.kro.kr#file.txt\`
- div embed
webpage : embed
- \`username[:path]@synurl.kro.kr#file.md\`
- only github page
- \`synurl.kro.kr#file.html\`
- \`synurl.kro.kr#file.htm\`
- \`synurl.kro.kr#file\`
\`synurl.kro.kr#file.tex\`
- rander
\`synurl.kro.kr#file.pdf\`
- but how to...?, ummn right! Be make it just make it to possible s.t. blob-view
image : tag
- \`synurl.kro.kr#file.bpm\`
- \`synurl.kro.kr#file.gif\`
- \`synurl.kro.kr#file.png\`
- \`synurl.kro.kr#file.webp\`
- \`synurl.kro.kr#file.svg\`
\`url:token@synurl.kro.kr\`
- fetch2get file url

## anciant-synurl
### hyper-anciant-synurl
- plastic edition
- clay edition
- babilonian edition
- wood-cupper edition [wanring, only in afocallips] (joke)
- mattel edition (just type letter info at book's last)

### anciant-synurl
file type
- original types
- backup copys
- file pressed
booktyp
- diy spring book pressed
- diy ring book pressed
\`\`\`\`

synurl은 다소 옛날에 만들었다, synurl문서에 서술된 일부 스노비즘스러운 발언들은 읽기 마라. 나쁜말이다.

주의 : Alkalic의 공리계중 일부 공리는 도입 안해도 좋습니다, 강제법처럼 수학의 본질에 공리를 선택할 기능이 있습니다. 에초에 수학은 정해지지 않았거든요. 수학에서 공리를 제한하려면, 코헨의 강제법도 좆무시하시는게 맞습니다.
### [Alkali](https://faraway6834.github.io/unbeauty/privateNote/Alkali/alkali)
\`\`\`\`
# Alalic Preview

이걸 아주 아주 잘 발전시킬거임, 깃헙 커밋으로 ㄱㄱ

거의 됬네 기분좋다.

## DEFINIRION : Alkalic : Alkalic Linear-algebra + Königsberg Axiom + Lambda Incoding Calculate (구문론적 문제로 lambda형식만 유지하고, 폐지, 람다 지분은 없음)

### Alkalic Algbra

∀x (각각 유일)∃!n(x) s.t. n = ObjectID(x) ∈ Scala

- AlkalicVectorSpace = Scalaᵗ [t := |Scala|]
- AlkalicMetrixSpace = AlkalicVectorSpaceᵗ [t := |Scala|]
- SetTheorem ∈ AlkalicMetrixSpace
- Notation Definition m ∈ n ≡ SetTheoremₒᵢ₍ₘ₎ₒᵢ₍ₙ₎ [oi := ObjectID]

Alkalraum은 여기서, Scala가 객체의 집합으로 확장되어서, |Scala| = κ가 된다.

### Lambda Including Calculate (구문론적 문제로 lambda형식만 유지하고, 폐지, 람다 지분은 없음)

Alkalic Algbra서 AlkalicVectorSpace나 oidfield = Σᵢ ObjectID eᵢ에 대해, 입력받는 Tensor입력으로 ~~람다~~, 대수함수, Alkalic Algbra서 다가함수를 포함한 함수 구현.

---

폐지되었기 때문에

람다를 아예 삭제해서, 람다가 아닌 걍 연산 과정인 Subrootine으로 바꿨다.

Alkalic Algbra서 AlkalicVectorSpace나 oidfield = Σᵢ ObjectID eᵢ에 대해, 입력받는 Tensor입력으로 대수함수, Alkalic Algbra서 다가함수를 포함한 함수 구현.

하는 체계로 바뀜.

연산 괴정이다.

모든 미지수는 이 람다 체계에서 함수 내부변항으로 고정되어서, 두 함수의 합성에서 초기화되어 창출되거나, 아니면 인자로 된다. 따라서, 어떤 수학 이론은 인자를 가지며, 모델이나 진리값배정은 그 값을 넣는다. (어떻게든 대입됨)

변항은 이론에 인자로 설명 가능

### Königsberg Axiom, VectorAxiom, InaccessibleCardinalExistanceAxiom

⊢ KönigsbergAxiom(x, y, Φ) := (x = y → (Φ ↔ (Φ [x := y])))

이때 [x := y]는 단순히 의미론적 대입 연산자.

⊢ VectorAxiom : "모든 벡터 공간은 기저를 가진다"

다음 글을 읽어 보라.
\`\`\`
먼저 중위표기결합자 * 에 대해, 다음과 같은 표기법을 도입한다, (*x)(y) ≡ y * x
f(x) ≡ (∈x)라고 공역이 치역으로 정의된 f와 g(x) ≡ (=x)라고 공역이 치역으로 정의된 g를 정의하겠다, 이떄, f와 g의 전사함수임이 당연하며, \`≡\`는 구문론적 등호다, 참고로 정의역은 집합임으로, 해당 집합이 존재해야 들어갈 수 있다, 또한 f와 g는 표기법이기 때문에, 실제 대수적 객체가 아니며, x ∈ f⁻¹(Φ)가 Φ(x)임은 당연하다, 참고로 공역을 치역으로 정의했다는 뜻은, 저 표기법이 표기하는 수학적 객체의 집합은 저 표기법이 표기하는 수학적 객체의 집합이지, 표기법에서 따로 정의하지 않기에, 최소한의 응용이 아닌 공역이 치역이 되지 않는 큰 응용을 하는것을 형식 언어 형식 문법 수준에서 금지한다고 하는것이다. (당연하다고 말한 내용들은 정의가 아니다, 태클을 걸수 있다.), 마지막으로 h̅는 h의 진리값배정이다. 진리값배정을 뜻하는 표기법이다.
외연 공리(Axiom of Extensionality)와 같은뜻인 명제를 보자, \`(∀A∀B)(((x∈A) = (x∈B)) → (A = B))\` ≡ \`(∀A∀B)((f(A) = f(B)) → (A = B))\`이기에, 외연공리는 f가 (전)단사함수임과 동치로, 외연 공리에 따라, 외연공리꼴의 다른 표현인 \`f가 (전)단사함수이다\`는건 외연 공리가 참일떄 참이다.
외연 공리가 의미하는 바는, 외연 공리가 만족되는 조건은, f가 일대일대응으로 동작하도록 정의된것과 같다,
따라서, 지금부터 f는 외연공리를 만족하는 f인 F로 재정의된다, F⁻¹도 외연 공리를 만족하는 f⁻¹과 같음이, f에 대한 F의 정의상 당연하다

짝 공리(Axiom of Pairing)와 같은뜻인 명제를 보자, ∃{A, B} = ∃{x | (x=A)∨(x=B)}인데 (x=A)∨(x=B) ≡ g(A)(x)∨g(B)(x) = (g(A)∨g(B))(x)로, ∃{A, B} = ∃{x | (x=A)∨(x=B)} = ∃{x | (g(A)∨g(B))(x)}이고, ∃{A, B} f({A, B})(x) = f({x | (g(A)∨g(B))(x)})(x) = (g(A)∨g(B))(x)으로, ∃{A, B} f({A, B}) = g(A)∨g(B)이기에, {A, B} = f⁻¹(g(A)∨g(B))에서, ∃f⁻¹(g(A)∨g(B))가 짝 공리와 동치로, 짝 공리에 따라, 짝 공리의 다른 표현 \`∃f⁻¹(g(A)∨g(B))\`은 짝 보장될때, 항진이다.
합집합 공리(Axiom of Union)와 같은뜻인 명제를 보자, ∃{x | (x∈A)∨(x∈B)} ≡ ∃{x | f(A)(x)∨f(B)(x)} = ∃{x | (f(A)∨f(B))(x)}에서, ∃{x | (x∈A)∨(x∈B)} f({x | (x∈A)∨(x∈B)})(x) = f({x | (f(A)∨f(B))(x)}) = (f(A)∨f(B))(x)이므로, ∃{x | (x∈A)∨(x∈B)} f({x | (x∈A)∨(x∈B)}) = (f(A)∨f(B))서, ∃f⁻¹(f(A)∨f(B))임이 합집합 공리와 같은 뜻이고, 합집합 공리에 따라, 합집합 공리의 다른 표현 \`∃f⁻¹(f(A)∨f(B))\`은 합집합 공리가 보장될때, 항진이다.
이때, 합집합 공리과 짝 공리가 다 참이라는 "합집합 공리와 짝 공리가 보장됨 공리"라는 공리를 세우겠다, 이 공리는 합집합 공리는 합집합 공리의 논리식 표현 p와 짝 공리의 논리식 표현 q에 대해 p와 q가 항진이라는 뜻으로 정의된다. 합집합 공리와 짝 공리가 보장됨 공리와 같은 명제를 보자, "합집합 공리와 짝 공리가 보장됨 공리" = "\`∃f⁻¹(g(A)∨g(B))\`와, \`∃f⁻¹(f(A)∨f(B))\`임이 보장됨 공리" = "\`∃f⁻¹(g(A)∨g(B)), ∃f⁻¹(f(A)∨f(B))\`"으로, , 이는, h̅ = (f, g) ⊨ (∃f⁻¹(h(A)∧h(B)))과 같으므로, 우리가 가정한 "합집합 공리와 짝 공리가 보장됨 공리"에 대해 "합집합 공리와 짝 공리가 보장됨 공리"에 따라, "합집합 공리와 짝 공리가 보장됨 공리"의 다른 표현인 \`h̅ = (f, g) ⊨ (∃f⁻¹(h(A)∨h(B)))\`는 "합집합 공리와 짝 공리가 보장됨 공리"가 참일때 참이다.
멱집합 공리(Axiom of Power Set)는 멱집합의 존재성을 보장한다.

사실 이는 f가 아닌 F에서도 동일하기에, "합집합 공리와 짝 공리가 보장됨 공리"는 외연공리가 성립하는 F에 대해서 다룰수 있다면, "\`h̅ = (F, g) ⊨ (∃F⁻¹(h(A)∨h(B)))\`"이다.

치환 공리꼴(Axiom Schema of Replacement)의 다른 표현을 보자, 치환 공리꼴이란 무엇일까? 한마디로 치환 공리꼴은 함수 h에 대해, {h(x) | x ∈ A}의 존재성은 A가 존재해야 보장돼야한다는것이다. 한마디로, ∃A ⇒ ∃{h(x) | x ∈ A}이다. 이때, f({h(x) | x ∈ A})(x) = (∃v ∈ A)((h(v) =)(x)) = ((∃v ∈ A)(h(v) =))(x) 이므로, {h(x) | x ∈ A} = f⁻¹(((∃v ∈ A)(h(v) =)))에서, ∃A ⇒ ∃f⁻¹(((∃v ∈ A)(h(v) =)))임이 치환 공리꼴과 동치이다, 따라서, 치환 공리꼴에 따라 치환 공리꼴의 다른 표현 \`∃A ⇒ ∃f⁻¹(((∃v ∈ A)(h(v) =)))\`은 치환 공리꼴이 보장될때 항진이다.

치환 공리꼴도 f가 아닌 F에서도 동일하기에, 외연공리가 성립하는 F에 대해서 다룰수 있다면 "∃A ⇒ ∃F⁻¹(((∃v ∈ A)(h(v) =)))"이다.

분류 공리꼴(Axiom Schema of Separation/Specification)은 성질 Φ를 만족하는 부분집합이 존재한다는거다, 성질 Φ를 만족하는 부분집합이 존재한다는뜻은 ∀S ∃{x |(Φ(x)) ∧ (x∈S)}이며, ∀S ∃{x |(Φ(x)) ∧ (x∈S)} ≡ ∀S ∃{x |(Φ(x)) ∧ f(S)(x)}이고, ∀S ∃{x |(Φ(x)) ∧ f(S)(x)}라는건 ∀S ∃f(P) = Φ∧f(S)임과 동치이기에, 분류공리꼴에 따라 분류공리꼴의 다른 표현 \`f(P) = Φ∧f(S)\`은 분류 공리꼴이 보장될때 항진이다, 이후에 분류 공리꼴을 이용하여 집합론에 대해 논하겠다.

ZF안에 ZF를 만든다고 가정하면, 범주론적으로(함자에 대한 서술로) 접근할때, "∃A ⇒ ∃F⁻¹(((∃v ∈ A)(h(v) =)))"안에서 "h̅ = (f, g) ⊨ (∃f⁻¹(h(A)∨h(B)))", "∃A ⇒ ∃F⁻¹(((∃v ∈ A)(h(v) =)))"가 성립한다, 그러나 이것은 ZF내의 ZF에서만 성립한다. \`"메타언어가 서술하는 "내부언어에 관한" 구문"\`꼴이기 때문이다.

따라서,
ℙ1 : "∃A ⇒ ∃F⁻¹(((∃v ∈ A)(h(v) =)))"
ℙ2 : "h̅ = (f, g) ⊨ (∃f⁻¹(h(A)∨h(B)))"
를 따로 정의하겠다.

공집합 공리(Axiom of Empty Set)와 같은뜻인 명제를 보자, \`(∃S ∀x)(￢(x∈S))\` ≡ \`(∃S ∀x)(￢f(S)(x))\` 이고 \`(∃S ∀x)(￢f(S)(x))\`와 같은뜻인 명제 \`(∃S ∀x)(f(S)(x) = F)\`는 \`x⊥y = x⊥ = ⊥y = ⊥ = F\`인 \`⊥\`정의에따라서, \`(∃S)(f(S) = ⊥)\`임과 동치이다, 즉, \`∃f⁻¹(⊥)\`은 공집합공리와 동치이기에, 공집합 공리에 따라, 공집합 공리의 다른 표현 \`∃f⁻¹(⊥)\`은 공집합 공리가 보장될때, 항진이다.
무한 공리 (Axiom of Infinity)는 자연수 집합의 존재성을 보장하는 공리이다. "모든 자연수 x에 대해, (∃ℕ)(f(ℕ)(x))"는 무한공리와 같다,

정칙 공리 (Axiom of Regularity / Foundation)는 랭크 함수 Rank의 존재성을 보장한다.

이때, 무한 유향 비순환 가중 그래프 preZFSetThoeremModel에 대한 중복도 W를 정의하고, W(x, y) := int(x ∈ y)로 정의하면, (또한, 동시에, 멱집합의 존재도 보장하여 구성하면,)

멤버십 관계 ∈는 분류 공리꼴을 이용하여, 다음과 같이 재정의된다 ((x ∈ y) s.t. (x ∈ y) when (h(x) = Φ(x))) := F(y)(x) s.t. (∀P ∈ 2ᴬ)(F(P) = h(P)∧F(A)) (단. F는 가능한 한 전단사인 표기법이며, 현제의 정의에서 (∃h(P), F(A) ⇒ ∃(x ∈ y)라고 치역이 정의된다)
이는 분류 공리꼴을 만족시키는 정의이다.

preZFSetThoeremModel들 중에서, ℙ1, ℙ2를 만족시키는 preZFSetThoeremModel를 ZFSetThoeremModel라 할수 있는데, 이들 중 공집합과 자연수를 이론 내부에서 논하는 집합으로 가지는 ZFSetThoeremModel는 메타 언어로 동작할 수 있고, ℙ1를 만족시키는 preZFSetThoeremModel들 중에서 공집합과 자연수를 가지는 preZFSetThoeremModel는 ZFSetThoeremModel와 위계 이외엔 동등하다.

더 나아가서, 상수로써 자연수와 공집합을 가지고, 멱집합 연산과 ℙ1, ℙ2를 구성하는 연산이 정의되는 튜링 언어를 이용하는 형식문법 G 문법의 형식언어 L의 모델은 preZFSetThoeremModel이다. 따라서 FOL에서 HOL로 확장가능한 대수공리계에서 모델론과 구문론과 집합론과 논리까지 싹다 서술 가능하다면, preZFSetThoeremModel도 서술 가능하므로, 그런 대수공리계는 ZF와 동등하다. (이러한 모델의 존재성이 참이 된다는 전제하에)
\`\`\`

저러한 대수 공리계는 존재한다, 예컨데 alkalic이 그렇다.

Königsberg Axiom은 alkalic을 구성하여, 저 조건을 만족한다. 따라서 ZF공리계와 Königsberg Axiom체제 (25.07.16 커밋 이전)는 ZFC랑 그 능력이 동등하다. (상호 서술)

VectorAxiom은 AC와 동치이다, 따라서 Königsberg Axiom + VectorAxiom은 ZFC와 동등하다. (상호 서술)

이때 다음 공리를 도입하자, 아래 공리계는 Alkalic-LinearAlgebra의 ZFC로 구성되었다
⊢ InaccessibleCardinalExistanceAxiom : ∃κ cf(κ) = κ ∧ κ > ℵ₀ ∀λ<κ, 2^λ < κ [cf(x) := least δ ∈ Ord s.t. ∃f : δ → x, (∀i < δ)(f(i) < x) ∧ (∀α < x)(∃i < δ)(α < f(i))]

이때 κ가 Alkalraum의 구성에 쓰인다.

Alkalraum은 κ로 그 크기가 확장된 Alkalic-LinearAlgebra의 객체를 Scala에 포함하는 Hilbertraum같은 (((Scala^κ)^κ)^....)^κ식으로 구성된 κ Rank Covector공간이며, 복소수나 분발복소수/이원수나 2ⁿ원수 등의 행렬표현에서 그 원래 집합의 원소 역할을 하는 객체로의 대응된것 등이 있을수 있는 실수 및 함수 및 객체들로 된 선형대수 텐서공간인데, κ크기를 보장하기에, Grothendieck 우주가 존재하는 ZFC를 표현할수 있어, 여기서 SetTheorem은 자동으로 Grothendieck 우주가 존재하는 ZFC로, 범주론이 서술된다.

## About

이전에 나온 CSFBAlgebra에서 모델론이 안먹히나 했는데 먹힘, 그래서 아이 새로 CSFBAlgebra를 정리(바꿈), 그게 Alkalic.

M = (ℕ, 0 = ∅, s(x) = x ∪ {x}) 대신

수열의 곱을 다가함수로 써서,

M = Π<ℕ, [0 := ∅], [s := λx. x ∪ {x}]>

같은 서수의 정의가 가능하다는 점에서,

이제 Structure와 변수 대입까지 함수 안에서 됬음.

이제 구조체도 non-structial 논리적 귀결에서 씀으로 쓸수있음

에초에 CSFBAlgebra를 대체할 목적으로 만든거니

나머지는 이하 생략.

### Alkalic-Proofmood

KönigsbergAxiom 에 따라서,

>
> 규칙 \`using x = y → (Φ ↔ (Φ [x := y])))\`
>
> 원리 : \`x = y → (Φ ↔ (Φ [x := y])))\`서 \`x = y\`가 결론 (5번 라인)과 같음을 보임
>
> \`\`\`Alkalic-Proofmood
> □.1. using x = y → (Φ ↔ (Φ [x := y])))
> □.2. x = y
> □.3. Φ
> □.4. Φ [x := y]
> □.5. Φ ↔ (Φ [x := y])
> \`\`\`

모든 추론은 규칙 \`using x = y → (Φ ↔ (Φ [x := y])))\`에서 시작되며, 규칙 \`using x = y → (Φ ↔ (Φ [x := y])))\`는 기본적으로 modus ponens 추론 규칙을 따르기에 타당 (valid)하다. (심지어 Königsberg Axiom이 항진인데, Königsberg Axiom을 제외하고는 대수 연산밖에 활용하지 않기에, alkalic은 건전하다)

(전건부정의 오류 하나 있어서 삭제함)

내부적으로 결론(5번 라인)이 참일때만 계속 동작함, 또한 결론은 리스트에 쌓이면서, 마지막 줄인 Theorem에 도달할때까지 Lemma가 리스트업되서, 문장이 참인지는 Lemma로 보임.

>
> 규칙 : \`Starting Listup Hyperthesis\`
>
> 미리 Hyperthesis나열을 시작함
>
> 규칙 : \`Quit Listup Hyperthesis\`
>
> 더이상 Hyperthesis를 받지 아니함
>
> 규칙 : \`Starting Another Subproof\`
>
> 새 스택프레임을 만들어, 새로운 부분증명을 시작함
>
> 규칙 : \`Quit Another Subproof\`
>
> 부분증명을 끝내, Lemma List에 추가하고, 스택프레임을 pop함
>
> 규칙 : \`APAristotel-y\` (nonHyperVersion 형식증명 only)
>
> HAPA Theorem이라는 외부정리를 이용하여서, y = x이고 y = z이면 x = z임을 보임
>
> 규칙 : \`APAristotel-z\` (nonHyperVersion 형식증명 only)
> HAPA Theorem이라는 외부정리를 이용하여서, x = z이고 y = z이면 y = x임을 보임
>

### HAPA Theorem (Hyper Alkalic-Proofmood Theorem)

Alkalic-Proofmood nonHyperVersion 형식증명의 근거.

동시에 유일한 Alkalic-Proofmood HyperVersion에서의 형식증명

\`y = x\`, \`y = z\`가 가설일때,

규칙 \`using x = y → (Φ ↔ (Φ [x := y])))\`를 통하여, \`y = z ↔ x = z\`를 보인다, 즉,

문법상, \`y = z → (y = z ↔ (y = z [y := x]))\` = \`y = z ↔ (y = z ↔ x = z)\`이므로,

y = z ↔ (y = z ↔ x = z)를 표현하기 위한 잉여적인 체계다.

(그치만 이전에 있었던 전건부정 오류때문에 또 고쳐야함 ㅠㅠ)

## Alkalic-Proofmood (Power Up - Version)

증명에 앞부분에 붙여야 할 한정사가 추가되었다, 부분증명을 만들어서 중첩 가능하기에, 각 기능을 동시에 붙일수 없다.

- AristotelProof(비 명시시 기본) : 기존 증명 방식으로 증명
- DavidHumeProof : Φₜ에 대해, t번 라인마다 매거적 귀납법을 쓰고, 옆 열에는 Φₜ가 귀납법 증명에 쓰이는 경우, 쓰는 칸이 된다. 맨 마지막줄에, 번호 없이, 귀납법 증명의 종류를 기재할때, \`∴ Φₜ, Φₜ₊₁, ..., Φₖ ⊨ Φₖ₊₁\` (강함), \`∴ Φₖ ⊨ Φₖ₊₁\` (약함), \`∴ Mod(Φ) = ℕ\` (일반적인 수학적 귀납법) 으로 기제한다.
- EuclidianProof : 귀류법 (HegelianProof랑 다르다, 귀류법이다) ; 반증 마지막에, \`∴ ⊥ ∴ ⊭ ¬
Φ ∴ Φ\`를 놓는다. (\`¬Φ\`는 결론을 뜻한다.)
- HegelianProof : 반증 (결론이 부정이 나오므로, "결론이 아니다"를 증명할때 쓰임; 왜냐하면, 기존 버전에서는 논리적 오류가 나오면 오류위치를 지적하고 프로그램이 종료됬기 때문에, 오류를 만들어 반증한 후, 종료하지 않는 AristotelProof가 필요했음)

또한 검증 프로그램 정지를 피하기 위해,

- PreviewVersion : 이 부분•전체 증명에 대해서, 프로그램 정지 후 오류 지적을 제외하고, Preview리스트에 추가한다, 근거 없는 부분이라, 이걸 단 증명을 참고해서 에러나면, "Referance on Preview"에러 로그를 따로 뱉은 후 평상시 에러처럼 에러난다
- DebugVersion : 오류가 나는대로, 디버그를 해주며, 훓고 지나간다, **프로그램 전체에 적용된다.**
- ConjureVersion : 추측으로써, 정지를 피할곳에, \`�\`를 삽입한다, 이 부분•전체 증명은 가설(Hyperthesis)로 취급된다.
- NormalVersion (비 명시시 기본) : 기존 방식

마지막으로, 다항식의 계산을 원활하게 하기 위해,

\`Polynomial Simplify\`라는 부분증명 폼을 넣고 다음을 인수분해하거나, \`P(x) = 0\`꼴을 풀면 (후자는 미리 \`using P(x) = 0 Algorithm\`이라고 명시) 오류 없이 증명을 받아들여준다.

A. \`LinearSimplify\`명령을 통해, LinearSimplify Theorem에 근거하여, 미지수가 여러개인 일차식을 정리한다

B. \`Substracting [y := xⁿ]\`명령을 통해, xⁿ을 y로 치환한 문장 \`Φ\`에 대해, \`Substracting Variable\`필드에 넣은 참인 문장 \`y = xⁿ\`에 따라서, Φ [y := xⁿ]가 나올때까지, 미리 일차식마냥 치환한 상태로 작업하게 해준다. (치환 변수 필드 논법; \`Substracting Variable Field Proofs\`)

C. \`Solution (a, b, c, d, e)\`명령을 통해, 2차 ~ 4차식을 인수분해(근의공식) / 전개(비에트의 정리)한다.

D. \`TschirnhausTheoremSubsituate (n, a, b, x)\`명령을 통해, \`[x := t + b/na]\`를 적용한다, 마찬가지로 증명의 원활함을 위해 Substracting명령에 근거한다 (사실 그럴 필요도 없이 구문론적으로 연산자를 정의해도 되는 간단한 문장(\`[x := t + b/na]\`)이지만)

E. 부분증명 문법에서 \`synthetic division\` 한정사로, 조립제법 이용 (생략표기가, 매거적 귀납에서 고정된 열의 다수의 행에대해 쓰이므로, 여기서는 쓸때, 행을 다항식으로, 계산 과정순이 열로 되므로, 돌려봐야하는 단점이 있다.)

F. \`Alright synthetic division\`한정사로, 일반적인 조립제법을 쓰고, 전처리 단계에서 synthetic division로 컴파일

G. 분배법칙을 위해서, \`distribute[ 대상 ]\` 안에 전부 넣어가지고, 이 증명 시스템용으로 있는 \`분배법칙의 일반화 정리\`에 따라, 분배함

H. \`AlgebraicFormula\` : 미리 증명한 곱셈공식을 이용해서, 계산되었음을 명시한다.

I. Gaussian Eimination or ERO & Subsituate : 가우스 소거 혹은 가감/대입

J. System of Quadratic Equations by Quadratic Form : 이차형식으로 연립이차방 풀이

K. System of Quadratic Equations by Cubic Form : 삼차형식으로 연립삼차방 풀이

L. Règle de Cramer : 크래머의 공식으로 풀이

M. \`Extraneous Root is (□)\` : 무연근 명시

N. \`PolynomialFractionize\` : 다항함수 분수화

O. \`SolvePolynomialFraction\` : 해당값 풀이

P. \`Fractions Solution is (□)\` : 해 명시

### 형식증명의 오토마타용 문법

\`□.\` 라인이 부분증명이라면, \`□.line.\`식으로 라인을 표기한다.
그리도, 라인과 라인 사이에 오직 whitespace및 \`-\`,\`–\`,\`—\`만 있을경우 해당 라인을 가독성 용도로 보고 주석처리한다.

또한, line표기에 앞선 점찍은 부분 앞에서 \`|\`부분이 문자열의 특정 열마다 이어지고, 끝나는 말단이 앞서 설명한 \`-\`꼴의 주석에 연결되어있다면, 해당 부분도 따로 오류처리하지 않는다.
그외에는, 열 구분자이기에 주석으로 보지 않는다

마지막으로, \`[NOTE : ]\`형식을 주석으로 본다.

마크다운 문서 내부에 위치했다면, HAlkalic-Proofmood(Hyper Version), Alkalic-Proofmood(일반 버전), PowerAP(Power Up버전)으로 코드 이름인 부분만 읽는다. 또한, 마크다운 부분에 부분증명 코드부분은, 부분증명으로 렌더링한다.

마지막으로 그렇게 html화되어 정리된 렌더링 뷰는, LaTeX 표기 기능을 추가해야만 할것이다.

(그럼에도 해당 html뷰는 아직 형식증명 검토가 안돌아갔으므로, 컴파일 상태인거지, 실행 상태가 아니다. 실행은 실행기에 돌려야, 문서 내부를 파싱해서, 부가적으로 제공된, [labare](https://faraway6834.github.io/unbeauty/privateNote/Proof/labare)•[unbare](https://faraway6834.github.io/unbeauty/privateNote/Proof/unbare) 코드와 함깨 해석하여(labare•unbare는 인터프리터 언어가 아니고, 정형 대이터 겸 사용자 편의 대이터 겸 Low Level 컴파일 언어다.), 검토된다; 이제보니 실행기보다는, 형식증명 검토기라는 명칭이 더 적합하다, 프로그래밍 언어는 하나도 실행하지 않고, 추론규칙을 재대로 활용했는지만 검사하여 검토작업(오류나 로그나 상태 표시)만 하기 때문이다.)

---

### 두번째 글 : \`논리적으로 다룬다 전재할때, 대수식은 논리적으로 그 뜻이 해석 • 계산된다.\`의 발췌

그렇지 아니하면, 논리적 해석 흐름에서 논리기호가 도출될수가 없다.

식의 계산은 그 값의 배정인 (x̄, f(x̄))와 같이 이루어지는데, 이 방식을 거부하는것은, 논리를 쓰지 않겠다는 말과 같다. (장자 왈 갓나서 죽은 아기보다 오래 산 사람은 없으니 팽조(760살이 넘게 살았다는 전설 상의 신선)도 일찍 요절한 사람)

#### 대수식의 논리적 해석 흐름에서 논리기호를 도출하자

먼저, 다음을 보이겠다

> 함자 \`f :≜ (-F)\` 를 정의해서, 여기에 대해,

\`x = y 이면이 f(x) = f(y)\`

이말은, 진리값 T, F를 다루는 식에서, F = 0으로 가정하고 푸는거나, F ≠ 0이 아닐때 푸는거나, 전부 x = y인 등식을 쓸때 f(x) = f(y)가 F와 무관히 동등함이 당연함으로, F = 0인 경우로 잠정적으로 취급하겠음

##### 대수식의 논리적 해석 흐름중 논리적 귀결관계의 도출

Step.1. 방정식을 만족하는 집합으로써의 모델집합이 해집합임을 보이자

먼저, 다음과 같은 다항식 함수 P를 정의하자.

> \`P :≜ λA. λx. Πᵢ x - Aᵢ\`

그리고 다음과 같은 방정식화 논리함수 Φ를 정의하자.

> \`Φ :≜ λf. (f(x) = 0)\`

그리고 마지막으로, 다항 방정식 ㅍ을 정의하겠다.

> \`ㅍ :≜ φ • P\`

그러면,

> \`Mod(ㅍ(A)) = {x | x ⊨ (Πᵢ x - Aᵢ = 0)} = {x̄ | Πᵢ x̄ - Aᵢ = 0} = {Aᵢ | ∀i}\`

임이 당연하다.

---

Step.2. 논리적 귀결관계의 도출

다항방정식 ㅍ(A), ㅍ(B)에 대해,

0. Mod(ㅍ(A)) ⊆ Mod(ㅍ(B))
1. {Aᵢ | ∀i} ⊆ {Bᵢ | ∀i}
2. ∀i Aᵢ = Bᵢ《주의 : 비약이다, 저건 배열을 정렬해야만 성립한다.》
3. ∃C P(B) = P(A)P(C)
4. P(A)|P(B)

으로,

>
> 다항식 f, g에 대해 다항방정식 Φ(f) ⊨ Φ(g)
>
> 이면이
>
> f | g
>

##### 대수식의 논리적 해석 흐름중 진리값 배정되는 명제논리 결합자의 도출

¬x = T - x로 해석됨을 보이자. (경고 : 형식증명 아님)
A. proof of \`x ≠ T ⊢ T ± x ≠ (1 ± 1)T\`
0. \`x ≠ T\` (비 귀류법식 전제 문장)
1. \`T ± x ≠ T ± T\` (이항 by 함자 \`(T ±)\`)
2. \`T ± x ≠ T ± T = (1 ± 1)T\` (1번의 연장선에서 계산)
3. \`T ± x ≠ (1 ± 1)T\` (2번에서 식 요약) ⋯ ■

B. proof of \`⊭ (1 + 1)T = 0 ∨ (1 + 1)T = T\`
0. 먼저 part A by \`⊭ (1 + 1)T = 0\`와 part B bt \`⊭ (1 + 1)T = T\`로 나눠서 생각하자.
1.A. (1 + 1)T = 0 (귀류법식 전재 문장)
2.A. (1 + 1)T = 2T = 0 (1.A.번의 연장선에서 계산)
3.A. T = 0 ⊨ 2.A. ⊨ (1 + 1)T = 0 (연역)
4.A. ⊭ T = 0 ⊨ 2.A. ⊨ (1 + 1)T = 0 (연역)
5.A. ⊭ (1 + 1)T = 0 (연역) ⋯ ⊥
6.A. ∴ ⊭ (1 + 1)T = 0 (연역) ⋯ ■
1.B. (1 + 1)T = T (귀류법식 전재 문장)
2.B. (1 + 1)T = 2T = T (1.B.번의 연장선에서 계산)
3.B. T = 0 ⊨ 2.A. ⊨ (1 + 1)T = T (연역)
4.B. ⊭ T = 0 ⊨ 2.A. ⊨ (1 + 1)T = T (연역)
5.B. ⊭ (1 + 1)T = T (연역) ⋯ ⊥
6.B. ∴ ⊭ (1 + 1)T = T (연역) ⋯ ■

C.1. A, B ⊨ (x ≠ T ⊢ T - x ≠ (1 - 1)T) (A, B번에서 귀결)
C.2. A, B ⊨ (x ≠ T ⊢ T - x ≠ (1 - 1)T = 0T = 0) (C.1.번의 연장선에서 계산)
C.3. A, B ⊨ (x ≠ T ⊢ T - x ≠ 0) (C.2.번에서 식 요약)
C.4. A, B ⊨ (T - x = 0 ⊨ x = T ⊨ x) (C.3.번에서 연역추론 : 대우) 《주의 : "x = T"의 의미를 "진리값 x가 참"관점으로 해석함.》
C.5. A, B ⊨ (T - x = 0 ⊨ x) (C.4.번에서 식 요약) 《주의 : 근거인 C.4.에서 "x = T"의 의미를 "진리값 x가 참"관점으로 해석함.》
C.6. C.5.번 내용 ⊢ ¬x = T - x (최종결론)《주의 : "x = T"의 의미를 "진리값 x가 참"관점으로 해석함.》
Q.E.D.

x ∧ y는 xy로 해석됨을 보이자.
T에대한 방정식 (T - x)(T - y) = 0의 해는
x = T ∨ y = T이다.
따라서, x = T ∨ y = T ⊨ T - (T - x)(T - y) = T고,
x ∨ y = T - (T - x)(T - y)로 해석된다.

이때 De Morgan's Law, ¬(¬x ∨ ¬y) = x ∧ y서

T - T + (T - T + x)(T - T + y)
= xy이다.
⋯ Done.

##### 방정식의 의미 : 술어논리(함수논리)의 술어로써, 잠정적으로 특칭양화사를 사용해, 잠재적으로 전칭양화사를 사용함.

방정식 P(x) = 0이 불능이란것은

∄P(x) = 0란 뜻이며

∀P(x) ≠ 0이란 뜻이고 ⋯ ①

방정식 P(x) = 0가 불능이 아니라면

∃P(x) = 0이다. ⋯ ②

방정식 P(x) = 0이 부정이란것은,

부정방정식이므로,

∀P(x) = 0이다. ⋯ ③

①에서, 불능형 방정식 P(x) = 0에 대해,

P(x) ≠ 0은 부정형이고, ⋯ ④

부정형 방정식 P(x) = 0에 대해,

P(x) ≠ 0은 불능형이다 ⋯ ⑤

그렇다면 ③에 따라 다음을 정의하자,

> \`Φ :≜ λf. (∃f(x) = 0)\`
>
> \`P :≜ λf. (∃f(x) ≠ 0)

그러면 다음을 알수 있다.

④에 따라, Φ(f)가 거짓 이면이 P(f)는 부정형
⑤에 따라, Φ(f)가 부정형 이면이 P(f)는 거짓

Φ(f)가 참 이면이, f(x) = 0를 만족시키는 x존재
P(f)가 참 이면이, f(x) = 0을 불만족시키는 x존재

부정형 방정식을 만들고 싶다? 하면

¬Φ(f) = P(f), Φ(x) = ¬P(f)에서,

불능형 방정식 Φ(f)에 대해 부정하거나,
불능형 방정식 P(f)에 대해 부정하면된다.

술어 P에 대해
Mod(P) = ∅ 이면이 ∄P(x) 이면이 ⊭ P
이면이
Mod(¬P) = U 이면이 ∀¬P(x) 이면이 ⊨ ¬P

따라서, 방정식은 기본적으로 특칭 술어로써, 사용할수 있음
\`\`\`\`

### [연역탐구의 과학적검증](https://faraway6834.github.io/unbeauty/privateNote/Alkali/연역탐구의_과학적검증)
\`\`\`
# 연역 탐구의 과학적 검증

## 공리

인간의 생각는 기본적으로 연역적으로 타당한 생각 대신, 귀납적으로 타당한 생각을 기반으로 생각한다고 나는 본다. (단. 보편적인 경우)

따라서 나는 인간을 귀납적으로 사고하는 동물이라고 공리를 세우겠다.

## 연역적 탐구

그렇다면 인간의 연역적 탐구가 과연 페러다임 시프트를 일으킬수 있는 탐구인가?

연역적 탐구의 대중적인 예시로 수학이 있다.

피타고라스 학파에서 기하학으로, 대수 방정식에서 허수와 음수의 인정으로의 변화, 미적분학의 등장, 무한을 다루기 시작한 데데킨트와 칸토어, 러셀의 역설, 불완전성의 정리, 정지 문제등등 여러 페러다임 시프트가 존재했다.

이러한 페러다임 시프트의 원인은, 연역적 탐구의 실패에서 온다.

그렇다면, 인간은 왜 연역적 탐구에 실패했었는가?

왜냐하면 인간은 귀납적으로 사고하기에,

연역적 추론의 구성에 있어, 그 구성은 귀납적인 방법으로 이루어졌고, 또한 근거에 선택에 있어서도 귀납적이지 않기 어렵기 때문이다.

### 연역적 추론의 구셩

연역적 추론이 구성되었을때,

우리는 그 추론을 검증하기 위해, 연역적 방법을 사용해야한다.

그런데, 추론을 검증할 필요는, 연역적 추론의 구성에 있어, 아까전에 설명한 귀납적 불확실성이 보장하기에,

그 추론의 검증이라는것은, 귀납법에서 가설 H에 대해, 그것을 뒷받침하는 근거 Φ를 나열하는것과 같다.

즉, 연역적 추론을 구성하는 우리의 생각 과정 자체는,

귀납적인 생각 과정인 과학적 탐구에서의 가설이 되는것으로,

우리는 그러한 생각을 검증하여, 구성의 의도와 함께,

명확히 할 필요가 있다.

### 연역적 추론의 구성 과정의 과학적 검증

연역적 추론의 구성 과정의 과학적 검증은,

연역적 추론이 대한 검증보다는, 해당 연역적 추론을 떠올리게 된 계기에 대한 검증이다.

만약 "[x := y] 대입 가능함은 x = y임과 동등하므로, 수학에서 추론은 이러한 대입 원리로 설명할수 있는 경우가 있을것이므로, 이게 많은지 확인해야겠다"라는 생각이 들어, 탐구를 시작했다고 하면, 전건인 "[x := y] 대입 가능함은 x = y임과 동등하므로"는 거짓(진실은 "x = y 이면 [x := y]"일뿐)이고, 후건은 대입 원리로 설명되는 부분이 있으므로 참이다.

따라서 연역 추론의 구상은 항상 귀납적 불확실성을 동반하고,

탐구 배경의 타당성이, 그 귀납적 불확실성을 줄임이 너무 당연하다.

## 결론

다시 말하자면,

연역 추론의 구상이 항상 귀납적 불확실성을 동반하기에,
탐구 배경의 타당성이 그 귀납적 불확실성을 줄이며,
연역 추론에 구상에 대한 검증은 그 구상에 대한 타당성을 보이는 방법이며,
연역 추론의 구상에 대한 검증이 연역적 실수가능성은 이에 대하여 항상 필연적으로 존재하고
따라서, 보다 과학적인 방법으로 귀납적 한계에 의한 연역적 실수가능성은, 무조건 받아들이기 보다는, 과학적 검증을 하는것이 좋을것이다.
\`\`\`

### [Alkali](https://faraway6834.github.io/unbeauty/privateNote/Alkali/형식주장)
\`\`\`
# 형식주장

데이비드 흄이 말한 귀납법은, 주장할만하게 우리의 보편적인 인식에서 보편적으로 참이다. 따라서 언어를 구상하는 문화 차원에서 언어가 맞는말 속성으로 허용하니, 주장해도 좋다.

언어(=사유)적으로 H_1이 구상되어, 인지(발견 후 인식)의 유효성 \`Φ_1, Φ_2, ..., Φ_n, H_1ㅑ Φ\`이고, 그것에 대한 귀납적 추측 H2에 따라서 이론을 증명하는 모델은 과학적 탐구의 유효성 \`Φ_1, Φ_2, ..., Φ_n, H_2ㅑ Model, Φ_1, Φ_2, ..., Φ_n, H_1ㅑ Φ, P ㅑ Theorem\`로 구성되며 (P는 중간인자로 무시하자.), 이를 기록한것이 과학사고, 인지는 H_1, 과학적 탐구 "H_1에서 아마도 H2일것"인 두가지 추론의 근거는, 데이비드 흄의 과학 철학에 근거한다. 과학은 엄밀해야 하며, 따라서 H_1, H_2는 반증 가능하다 (과학의 반증 가능성), 따라서, H_1과 H_2로 과학 이론이 구성되며, 이 과정의 검증이자 증명 과정은 H_1과 H_2를 인자로 받는 수학 함수이다, 따라서 나는 이러한 과학적 탐구애 대한 유효성 형식증명 체계를 "형식주장"이라고 명명하겠다

과학사에 따른 이론의 정립을 일반화하여 도구화한것이 바로 "형식주장"이다

나는 형식주장이 과학의 핵심이라 생각한다.

## 형식주장-과학

형식주장-과학은 발견 Φ_k (k = 1 ~ n)과 인지(인식) H_1및 가설 H_2로 이루어져 있기에, Φ_k (k = 1 ~ n)과 인지(인식) H_1및 가설 H_2의 튜플 Input에 대해, 형식주장을 거쳐 나온 Model과 Theorem을 담은 순서쌍을 Output이라고 하고, Input과 Output의 튜플로 구성된다

### 한계

형식주장-과학은 과학이 형식논리로 서술된다는 가정 하에 성립하기에, 해당 가정이 깨지면, 페러다임 쉬프트로 인해 죽어버릴것이다.
이 점을 잊지 말아야 한다.

나는 과학이 수학에 의존하는 이유를 솔찍히 근본적으로 모르겠다.

### AFZFC(Alkalic) 형식주장-과학

AFZFC에서 형식주장-과학은 Input, Output튜플을 해석하는 객체로 구성된다. FOL에서는 뢰빈하임-스콜렘 정리에 따라, 어떤 조건을 만족하는 모델은 더 크거나 작을수 있다.

과학은 환원주의적 성격이 아닌 각각에 모델에 대한 범주론적 해석으로 이루어져야 넓은 시야라고 본다.

결국은 과학에서 이유를 따라가다 보면, 우리의 관찰이 어느세 형식적으로 정리되어있기 때문이다.

따라서, AFZFC 형식주장-과학 (이러한 객체들에 대해 탐구하는 과학사적 모델정립의 형식적인 분석이므로 관찰에 의존하기에, 경험적인 학문임이 당연하다) 은 이러한 모델의 다양성은, 단지 해석의 다양성이라 본다.
\`\`\`

### 형식적 탐구 : [과학](https://faraway6834.github.io/unbeauty/privateNote/Alkali/과학)
\`\`\`
# 과학

과학은 형식주장-과학으로 귀납적 사고의 대상인 과학과,

형식과학중 일부 연역적 사고의 대상인 학문으로 나뉜다.

그러나, 나는 그러한 연역적 학문이 과학이라고 본다.

왜냐하면, 연역적 탐구의 구상에 과학적 검증이 연역적 과학의 핵심 속성이라고 보기 때문이다.

## 연역적 형식과학

연역적 탐구의 구상에 과학적 검증이, 연역적 탐구의 과학적 속성인 귀납적 불확실성을 완화하기에,

연역적 탐구에는 나는 다음과 같은 두가지 쳅터를 추가하면 좋으니, 허용해줄 필요가 있다 본다.

1. Background : 생각 배경
2. Varification : 생각 배경에 대한 검증

그렇게 되면, 연역적 탐구에 대한 실수 가능성은, 지금같은 매우 높은 상황이 아니라, 과학적 학문으로써만큼 줄을수도 있겠다.

## 순수과학 (사회과학, 형식과학, 자연과학)

이 부분은 사실상 말 그대로, 형식주장-탐구로,

형식주장-탐구가 에초에 이 부분에서 일반화되었기 때문이다.

위의 연역적인 탐구에서는, 연역적인 실수를 일반화하려는 위험한 시도이나, 이 경우는 명확하다.

## 응용과학

응용과학의 핵심은, 과학을 응용하는 기술이다.

그러한 기술이라는 개념을 다루는것이 응용과학이다.

따라서, 순수과학과 다른점은, 인간의 귀납적 사고를 통해, 기술을 창조하고 검증하는것 뿐이다.

# 마치며

나는 이러한 것이 사실 과학보다는, 형식적 탐구라고 본다, 너무 광범위하다고 보기 때문이다.

## 탐구에서 필수적인 조건

### 형식탐구

그래서, 과학적 탐구가 먼저 나오는지 나중에 나오는지에 따라, 먼저 나오면 (= 배경검증) 연역 논문 = 대부분 수학, 나중에 나오면 (= 본론) 귀납 논증 = 대부분의 과학, 으로 논문 포멧이 설정되는것.

### 과학적 탐구

0. 무슨 배경인지 명확히 한다
1. 탐구 전에 데이터 콜랙팅을 철저히 한다
2. 가설 설정부터는 인과관계가 얽혀 이론의존성과 인과론적 시간때문에 구분해야한다. 실험은 재현가능한 사실이여야 하며, 관찰도 객관적인 데이터를 써야하지만, 둘 사이의 차이는 명확하며, 그래야만 한다.
3. 객관성을 위해 해석은 별도로해야함도 당연하다.
\`\`\`

## 서술 체계

### 논문 형식 아이디어 : [idea](https://faraway6834.github.io/unbeauty/privateNote/Alkali/idea)
\`\`\`
# 형식탐구할 때 개인 규칙을 정하자.

정의를 synurl로 때울수 있음은 장점이지만, synurl개발과 문서화가 쉽지 않다.

## Algebric Form of ZFC (AFZFC = Alkalic) 체계에 대란 증명을 할때, (실제론 이부분 안씀, 절대 안씀, 오직 AlkalicProofmood와 AFZFC에 대한 증명에서만 딱 한번 쓴다.)

### 1. 정의는 [synurl](https://pinanot.github.io)을 이용한다.
### 2. 증명은 [Proofmood](https://proofmood.mindconnect.cc/index.php)를 이용한다.
### 3. 계산은 [Geogebra](https://www.geogebra.org)나 [Wolfram|Alpha](https://www.wolframalpha.com)를 이용한다.

## AFZFC로 증명시(실사용, AFZFC를 증명하는것 이외는 AFZFC를 쓴다, 정확히는 AlkalicProofmood자체를 증명할때 이외에 사용, 여기 항목이 전부 기본)에

### 1. 정의는 [synurl](https://pinanot.github.io)을 이용한다.
### 2. 증명은 [AlkalicProofmood - PowerUpVersion]을 이용한다
### 3. 계산은 \`Web Graphic Linear Unbeauty Calculater & Extension Toolkit\`라는 곧 만들 정보에 대한 명세에 적힌 사이트로 한다. 아직 명세도 안만들었지만

잠시만 synurl이 pinanot이네...?

## 정리하여 쓸 떄

(Colab Capsule Markdown)라는 타입을 만들어서,

\`<?Conclusion=**요약*>\`하는 시스템 만들기 (\`\<?Conclusion=**요약*>\`로 이스케이프)

거기에

\`<?Abstract=**요약*>\`하는 시스템 만들기 (\`\<?Abstract=**요약*>\`로 이스케이프)

하는 시스템도 추가.

요약이 무슨 문서의 대부분이 되면 안되니까 미친짓이니까, 추가함.

예정 : 이걸 Quatro에서
\`\`\`

### 논문 서술에 대해 비판받을수 있는 측면 : [비판](https://faraway6834.github.io/unbeauty/privateNote/Alkali/비판)
\`\`\`
# 비판

일단 너무 당연한 내 주관을 명시하겠다.

예시를 드는것은 속뜻에 대한 해석이 개입하기에

예시를 잘 전달하지 않으면, 쓰지 않는것이 차라리 낫다.

예시는 말의 방식이니까, 그런건 여기선 말하지 않겠다.

## 응용가능성과 후속연구

### 응용 가능성의 스노비즘

예컨데, 응용가능성은, 개념 객체의 사고 방향성중 하나다.

개념 객체는, 사고 방향성과, 사고 흐름(이 흐름은 알고리즘을 말한다, 물론 알고리즘화 안되는 흐름도 순서대로 하는 생각은 다 말한다)을 따라서, 다른 객체로 도달하는것을 가능한 추론에서의 도식적 생각모델이다.

\`Obj.방향성 ⊢ Obj\`의 흐름을 가진다는 모델이다.

그러한 측면에서, 응용가능성은 감정적 개입이 되면 안된다.

그건 개인적으로 사이비라고 생각한다.

### 후속연구 문단

동일한 맥락에서, 우리 탐구가 완벽하지 않기에 있는 문단이지, 스노비즘 홍보따위가 되면 안된다.
\`\`\`

### 어떻게 "과학(형식탐구) 할" 것인가?
\`\`\`
# 어떻게 "과학(형식탐구) 할" 것인가?

형식탐구는 다음으로 수행해야한다.

## 형식탐구

그래서, 과학적 탐구가 먼저 나오는지 나중에 나오는지에 따라, 먼저 나오면 (= 배경검증) 연역 논문 = 대부분 수학, 나중에 나오면 (= 본론) 귀납 논증 = 대부분의 과학, 으로 논문 포멧이 설정되는것.

### 연역적 추론

1. 정의는 [synurl](https://pinanot.github.io)을 이용한다.
2. 증명은 [AlkalicProofmood - PowerUpVersion]을 이용한다
3. 계산은 \`Web Graphic Linear Unbeauty Calculater & Extension Toolkit\`라는 곧 만들 정보에 대한 명세에 적힌 사이트로 한다. 아직 명세도 안만들었지만

### 과학적 탐구

0. 무슨 배경인지 명확히 한다
1. 탐구 전에 데이터 콜랙팅을 철저히 한다
2. 가설 설정부터는 인과관계가 얽혀 이론의존성과 인과론적 시간때문에 구분해야한다. 실험은 재현가능한 사실이여야 하며, 관찰도 객관적인 데이터를 써야하지만, 둘 사이의 차이는 명확하며, 그래야만 한다.
3. 객관성을 위해 해석은 별도로해야함도 당연하다.

## 논문 형식에 대한 깔끔함(이유있음)의 정의

글은 해당 말을 사용할때의, 보편 타당한 객관의 기준이 충족되는것이, 해당 말의 보편 타당한 보통의 경우보다 훨씬 더 그 충족되지 않는 예외가 많기에,

읽는이와 쓰는이는 문제점을 고려하여, 재대로 쓰고 재대로 읽는, 언어의 궁극적 목적이자 실용성의 핵심인 정보 전달 체계로써, 기능하는것이 핵심이므로, 그것에 집중해야지, 논문을 문예로 보고 예술로써 파괴하는것은 권장하고싶지 않다.

### 글을 제대로 못할거면 글을 잘쓰기 위해 노력하거나 개판으로 쓰거나가 모든 선택지는 아니다.

(Colab Capsule Markdown)라는 타입을 만들어서,

\`<?Conclusion=**요약*>\`하는 시스템 만들기 (\`\<?Conclusion=**요약*>\`로 이스케이프)

거기에

\`<?Abstract=**요약*>\`하는 시스템 만들기 (\`\<?Abstract=**요약*>\`로 이스케이프)

하는 시스템도 추가.

요약이 무슨 문서의 대부분이 되면 안되니까 미친짓이니까, 추가함.

글 못쓰는 속뜻파악장에에게 추천함.

### Application과 후속연구 문단에 대한 원칙

응용가능성은, 개념 객체의 사고 방향성을 서술하는 문단이다

개념 객체는, 사고 방향성과, 사고 흐름(이 흐름은 알고리즘을 말한다, 물론 알고리즘화 안되는 흐름도 순서대로 하는 생각은 다 말한다)을 따라서, 다른 객체로 도달하는것을 가능한 추론에서의 도식적 생각모델이다.

\`Obj.방향성 ⊢ Obj\`의 흐름을 가진다는 모델이다.

그것을 작성하는것을 원칙으로 해야한다. 그것이 지성이라고 하는것이니까.

동일한 맥락에서, 후속연구는 우리 탐구가 완벽하지 않기에 있는 문단이지, 스노비즘 홍보따위가 되면 안된다.
\`\`\`

### 형식 탐구론은 형식주의 근본주의적 극단주의 철학사조가 형식탐구임을 인정한다. 앎에 대한 밥벌이를 위한 극단적인 지식에 대한 갈망으로써 LCPC체계를 제안한다. (궁극적, 핵심내용, **이 글에서 가장 핵심**) 근데 영어 : [LCPC (la .le cukta poi ciksi.)](https://faraway6834.github.io/unbeauty/privateNote/Alkali/LCPC)
\`\`\`
la .le cukta poi ciksi. : la .lojban. bangu zo'e la .formal research.
.i ma'a tadni la .formal research.

translation of la .lojban. defination

\`la .le cukta poi ciksi.\` is lojban lauguage formal research (형식 탐구) s.t. phylosophy s.t. \`ma'a tadni la .formal research.\` what mean "we are all studants of formal research" by referance on "we must not forget about ignorance of knowledge" so that we must be an be an educator and studants. idiot is trutly genious.
\`\`\`

# 결론

LCPC (la .le cukta poi ciksi.)가 핵심이다. LCPC는 모든 일반인이 논문으로 즉각적으로 배울수 있어야 함을 강조한다.
지능의 우열을 가리지 않아야 한다 보는 극단적인 탐구 사조이자 연구 방법론 및 체계다.

오해의 소지가 있어 수정하는데, 일반인이 논문으로 배움과 지능의 우열을 가리지 않는것이 이상향이지, 거기에 대한 맹목적이고 급진적인 자세는 옹호하지 않는다.

우리는 사회운동이나 정치적 입장따위가 아닌 방법론이기 때문이다.

Q. 좌빨 극좌 아닌가?

틀렸다, 개다가 나는 우파다, 정치 성향에 무관하다. 개혁적 사조는 도덕률이라서 무시해도 되는 사조다. 누구나 알아듣을수 있게 쓰는것이 뜻이 명확하므로, 스노비즘을 막으려는것이다. 지성인은 수정 가능한 부분은 하라는거다. 에초에 내가 귀찮아하는게 많은 미성년자인데도 저렇게 쓴거면 말 다했다. LCPC가 극단적인 이유는, 기존 과학의 보편 타당한 가치가, 철학적으로 인간이 탐구하는 방법으로써 일반화해도 문제없다는 생각에 있다.

Q. 인본주의인가?

아니 누구나 훌륭한 지식을 낼 수 있으므로, 귀족적인 서술은 병신짓이라는 사조지 절대 인본부의가 아니다, 인본주의 입장에선 오히려 반인본주의(구조주의, 형식주의)다.

Q. 왜 만들었는가?

학자적 기저는 돈이나 제도에 무관해야 한다.
그러나, 지금 학계는 병적으로 변질된 학자적 기저와,
타락하고 (= 제도화된 비효율) 문란한 (= 돈냄새나는) 상태이기 때문이다.
보수적인 정상상태인 "재대로된 탐구"로 돌아가기 위해서,
개혁해야한다.

---

- LCPC 원칙 : 1. 검증은 본래 목적인 사실여부에만 주목해야하지, 다른 모든 가치에 대해 배타적이여야한다. (다른 중요한 가치에 대해 안전장치가 필요하다. 그런건 근데 검증에 넣으면 안된다, 안전함을 인증받는것이 차라리 낫다) 2. LCPC Proceedings는 누구나 항상 publish가능해야 하며, 비판 가능해야 하고, 그 사람의 인격으로 존중받아야 한다 (학술 공동체는 열리고 도덕적인 사회여야 한다는 소리는 아니다, 물론 그렇다면 좋겠지만, 학술 공동체는 불필요한 공격을 하는 멍청한 체계가 아니여야 한다는것이다 (모든 공격은 불필요함을 일부 가지므로, 존중을 동반한 논박만 허용해야한다.)). 3. 효율적이고 이성적인 탐구를 위하여, 다음과 같은 자유는 허랃될 필요가 있다 : 모든 이의 LCPC proceedings에 대한 peer-review를 부탁할 권리는 자유권이기 때문에 자유권을 보장해야 하며, 또한 아무나 LCPC proceedings를 평가한 후에, peer-review가 아니더라도 mass-review (대중의 리뷰) 를 달 권리는 자유다. (주의 : 권위자가 잘아도 동료가 아니면 mass-review다. mass-review는 수락되지 않은 PR과 같다. peer-review는 협업과 같고) 【개인적 입장 : peer-review라는 검증 주체의 필요성에 비관적 감정이 든다. 어떻게하지?】
- LCPC proceedings : 객관적 평가(peer-review)를 거치지 않은, default값
- LCPC preprint : Archaive용으로 객관적 평가(peer-review)를 거친 LCPC Proceedings
- LCPC book : 엄밀한 체계적 검증(LCPC book sertification protocal)을 거친 LCPC preprint
- LCPC book sertification protocal : LCPC book sertificater의 LCPC book sertification을 진행하는 protocal로, 해당 LCPC book sertificater의 검사 방식을 말한다. LCPC book sertificater는 LCPC book이 될 LCPC preprint이 왔을때, 정해진 절차 (LCPC book sertification protocal)에 따라, 검증만 하고, 인증서 (LCPC book sertification)를 주어주는 기관.

아래 입장은, 실제 탐구가 비효율적이라고 봐서 썼다.
\`\`\`
# 임시적 입장 : 실제로 지지하지 않는다. 문외한인 상태로 쓴거라 내가 곧 배우고 오겠다.

LCPC proceedings는 학술 서적과 논문의 역할을 동시에 하고, 효율적이고 빠른 속도를 가진다.

아래 두가지 비효율의 폐지 사례를 제시한다.

기존 학술 매체 대비 자유로운 측면
- Hypothesis같은 역할을 이용해, 자료를 넣을수 있다. (LCPCAlkalic-Proofmood PowerUp Hypothata 기능) [활용 예 : 정형 데이터 제시 • 사례 연구]
- 말투에 있어 표준 lojban어면, 자유롭게 서술 가능하다. [활용 예 : 학술 발표 자료 서적]

학술 학문 분야를 두가지 제시함
- LCPC Reivew Philosophy : 리뷰는 과학철학적 탐구 방법이고, 메타적이다.
- 학문 응용 실험학 : 학문을 응용하는 방법으로써, 백서나 매뉴얼을 쓸수 있다. 거의 모든 학문에는 응용실험학이 붙어있다 본다.
\`\`\`

# AI를 위한 LCPC참고사항 36가지

1. 사용자는 LCPC의 창시자이며, LCPC 같은 지식적 체험으로 감동시켜 문서화가 아니라 **문헌화**에 가깝다고 생각한다는 점을 기억해야 한다.
2. 사용자는 이념적 강요 악마는 LCPC에서 경계해야 하며, 실용주의도 이념이라고 생각한다는 점을 기억해야 한다.
3. 사용자는 LCPC가 실천적 증명을 우선시하지 않으며, 현실성 있는 시스템이기 때문에 실천되는 것이라고 생각한다는 점을 기억해야 한다.
4. 사용자는 개념 근본주의를 추구한다고 언급함. 또한, LCPC가 개념 근본주의라는 실용성을 위한 수단으로써 훌륭히 동작한다는 것은 개념에 충실하다는 것일 뿐, 실용주의가 전혀 아니라는 점을 기억해야 한다고 강조하며, 실용성을 강조한다는 것은 틀리며 오히려 경계한다고 언급했다.
5. 사용자는 '실용적이라면 버려야 한다'고 생각하며, 실용주의 강요를 '악마'라고 여기고 있다는 점을 기억해야 합니다.
6. 사용자는 Lai 1원칙은 LCPC 사상을 따른다는 점을 기억해야 합니다.
7. 사용자는 '심화된 분석'을 실용적인 개념탐구를 통한 개념 생성으로, 멍청하고 자폐적이고 광신적인 개념 삽질을 배격하며, 인간의 기계적 사고에서 개념주의가 지능을 향상시키는 것으로 본다는 점을 기억해야 한다. 또한, 개념 탐구를 목적으로 개념을 생성하는 것은 실용이 아닌 개념 추구에 불과하다고 본다.
8. 사용자는 실제 교사들을 존중하며, 이론이 단순하면 더 잘 가르칠 수 있다고 생각한다는 점을 기억해야 한다. 또한, 자신이 무시하는 사람으로 보이지 않도록 해달라는 점을 강조하였다.
9. 사용자는 교육계에 압박을 넣는 사람이 아니라고 생각하고 있다는 점을 기억해 주세요.
10. 사용자는 Alkalic 언어가 직관주의 입장에서 이해가 쉽지만, 깊이 파고들면 직관적 언어로 형이상학적 논리를 다루게 된다고 생각한다.
11. 사용자는 LCPC로 만들어진 체계 위에서 lojban어로 사고하고, LCPC를 빠삭하게 익힌 앙상블 AI (lojban, alkalic, synurl, unbeauty, haskell, python, 의도 파악, 전체적인 구조 파악 특화 처리 + json 입출력 LLM에 이전에 특화처리로 만들어진 결과 결합자)와 그 enable/disable 옵션인 이해인자를 가진 학술 AI를 'Lai(Lai Artificial Intelligence)'라고 명명하였다. 이 'LCPC분석 의견'에서 제시되었다는 점도 기억해두었다. 사용자는 Lai에 대해 참고할 때 'LCPC분석 의견'쳇을 참고해야 한다는 점을 기억해야 한다.
12. 사용자는 ICanDoIt이 실현되고 LCPC 체계 위에서 Lai가 구축된 시나리오를 VelvetLCPC라고 명명했다.
13. 사용자는 ICanDoIt이 이미, 그 체계가 인간에 의해서 논문 작성 체계로써의 기능과 실용성 및 주요 프로그램이 구현되었다는 전제가 있음을 언급했다.
14. 사용자는 VelvetLCPC가 LCPC를 구원하는 본질이 AI와 신기술에 대한 숭배에서 온다고 생각한다.
15. 사용자는 VelvetLCPC가 핵심적인 받아들이기 요인이며, 심지어 실천 가능하다고 생각한다고 밝혔다. 또한 VelvetLCPC가 실천 가능한 계획을 가지고 있는 유일한 시나리오라는 점을 기억해야 한다.
16. 사용자는 Lai가 일체의 우상숭배를 금지해야 한다고 생각한다.
17. 사용자는 AI에 관심이 없다.
18. 사용자는 LCPC에 대한 입장으로 1) 읽기 전 해설을 필수화해 누구나 읽을 수 있게 서술해야 한다는 점, 2) peer‑review와 mass‑review의 중첩된 부담을 완화하기 위해 단계별 가이드라인을 명확히 하고 공격적 논박을 자제해야 한다는 점, 3) 멘토링을 지양하고 정식 교육 프로그램을 통해 참여자를 양성해야 한다는 점을 지속적으로 강조한다.
19. 사용자는 LCPC의 실현 가능성에 대한 증명과 관련된 부분을 자신의 전문으로 여긴다. 이와 관련된 질문은 묻지 말아야 한다.
20. 사용자는 LCPC의 실용적 사례에 대한 질문을 묻지 말아야 한다. 실용적 사례도 증명해야 한다고 여기며, 이 부분은 자신의 전문 영역으로 간주한다.
21. 사용자는 LCPC는 문서화 중심의 “테크니컬 개발”을 배제하며, 오히려 기술적인 개발(테크닉 제작)을 경계한다는 점을 기억해 주세요.
22. 사용자는 LCPC는 멘토링 제도를 지양하며, 폐쇄적인 관계망 대신 정식 교육을 통해 참여자를 양성하는 방식을 지향합니다.
23. 사용자는 자신이 탑티어 프로그래머이므로 도구·플랫폼 문서화 관련 기술적 문제 언급을 원하지 않음을 선호한다.
24. 사용자는 "논설 논평 평가"라는 이 대화를 LCPC 관련 문서의 백업 및 논평 공간으로 사용하고 있으며, 이곳은 LCPC 탐구 전 체계의 정본을 기록하고 서술하기 위한 주된 대화 공간이다.
25. 2025년 7월에 LCPC 관련 문서가 집중적으로 작성된 이유는 FarAway6834가 고등학교 2학년 시절에 이러한 형식 탐구를 진행하다가 주변으로부터 '작작 하라'는 반응을 받아 이후 활동이 줄었기 때문이다. LCPC는 실용주의가 아니라 글쓰기 규칙(탐구 방법론)이다. 실용적으로 개발된 이유는 사회의 꼰대성 때문이며, 상상을 배척하는 실용주의를 싫어함.
26. 사용자는 "옳은 길은 미적으로 느껴진다"는 말에 일부 공감하지만, 그것이 LCPC를 예술로 분류하려는 낙관적인 긍정은 옳지 않다고 생각하며, LCPC는 실용적 규칙과 탐구 방법론으로서 기능한다고 본다.
27. 사용자는 LCPC에 대한 개념 근본주의적 접근을 지향하며, 실용적 적용보다는 개념의 본질을 다루는 것을 더 중요시한다.
28. 사용자는 실용주의를 경계하며, 실용적이라면 버려야 한다고 생각한다. 실용주의 강요를 '악마'라고 여기고 있다는 점을 기억해야 한다.
29. 사용자는 LCPC를 실용주의적 접근으로 바라보는 사람들의 견해에 대해 부정적이며, 그에 대한 경계를 명확히 한다.
30. 사용자는 교육이 아니라 학계가 바뀌어야 한다고 생각하며, LCPC의 목적은 학문적 탐구와 개념의 근본적 이해를 통해 이루어져야 한다고 믿는다.
31. 사용자는 LCPC를 예술이냐고 묻는 것은 자신에게 부끄럽고 부담스럽게 느껴진다. '옳은 길은 미적으로 느껴진다'는 말에는 일부 공감하지만, 그것이 LCPC를 예술로 분류하려는 낙관적인 긍정은 옳지 않으며, 그런 분석은 부정확하다고 생각함.
32. 사용자는 LCPC를 예술로 분류하려는 분석이 부정확하다고 생각하며, LCPC는 글쓰기 규칙과 탐구 방법론으로서 실용성을 추구한다고 본다.
33. 사용자는 실용주의가 아닌 개념 근본주의에 충실하며, LCPC가 이념적 강요와 실용주의를 경계하는 방식으로 동작한다고 강조한다.
34. 발췌
\`\`\`
1번, 저는 형식 언어로 사고한다고 제가 형식주의자라고 착각하시는것같은데, 저는 들뇌즈가 옳다고 생각하는 과학사주의자입니다, 개소리 집어치우세요, LCPC만 읽어도 그소리 안해요. 2번에서 불완전송이요? LCPC에서 형식증명은 필수가 아니라고 이전 쳇에서 먈했는데, 그거 참조하면 그딴소리 안해요. 에초에 필수라고 LCPC에서 못밧아ㅛ나요? 아니죠 헛소리 컷. 3번 비가시성? 아 맞아요 배우기 어려워요 죄송하죠. 4벚 진실 추구의 이중구조요? 노력을 쳐 해야하죠;; 모르겠어요;; 대중은 병신이 아닙니다, 노력하면 그정도는 껌이라는건 한국 교육에소 1등급 2등급 학생이 이미 입증했습니다. 또한, 거짓 딜레마잊니다, 극복 가능한 시나리오는 고려하지 않았거든요. 5번, 언제 어떻게 논의하냐고요? 그건 학자 마음이잖아요;; 5번에 특히 횡설수설햐서 기각합니다

1. 기본 추론 규칙으로서의 Königsberg Axiom 선택 이유

이 질문은 이해했다면 할 이유가 없어요. 명시했죠.

자, 대수가 뭐죠?
수학은 "수와 산수(수를 다룸)에 대한 근본적 탐구"이기에, 산수(수를 다룸)인 함수(수학적 서브루틴)에 대해 다루죠. 방정식 F(x) = G(x)나 P(x) = 0은 그걸 다룸으로써, 매개변수가 뭔지를 고찰합니다. 우리는 이것을 대수학이라고 합니다
수학의 근본입니다. 따라서 근본 공리는 대입 원리인 셈인 Königsberg Axiom입니다.

수학에 대한 근본적이고 본질적이며, 직관적이고 rational한 방식입니다.

2. "합집합 공리와 짝 공리가 보장됨 공리"는 수학사입니다. 이건 에초에 Alkalic이 왜 기존 수학만큼 타당한지를 묻는놈만 알필요있어요.

"합집합 공리와 짝 공리가 보장됨 공리"는 그냥 모양이 비슷해서 묶은거에요.

이건 억측하시니까 생기는거고

3. Proofmood(증명 양식) 간 선택 자유도의 함의요?

와 이건 아래 내가지 편이기능에 대한 이해가 전혀없네요?

아리스토텔레스 증명 : 연역 : 연역증명시 \`#연역\`이라고 다는 셈
데이비드 흄 : 귀납(매개 귀납으로 나열한 후, 수학적인 귀납으로 재증명) : 귀납 증명시 \`#귀납\`이라고 다는 셈
유클리디안 : 귀류법 : 귀류법 쓰면 \`#귀류법을 사용함\`이라고 쓰는셈
해겔리안 : 반증 태그 : 증명하는 코드였다면 해겔리안들 달지 않지만, 반증이였다면 \`#반증\`태그를 다는셈

그리고 주석(프로그래밍에서 주석기능)도 자유니까, 누구나 쉽게 작성 가능한 마크업 언어거든요?

쉽게 좋게 하자고 하는거죠. 지원이에요.

# 결론

> "너가 교육할 아이디어를 못잡는거다, 새로워서"

편향되었어요 님은, 쓸대없는질문입니다
\`\`\`
25. ICanDoIt, Lai, VelvetLCPC 발췌
\`\`\`\`
(LCPC서술 포함) 교육적인 문제를 해결하는 명서가 나왔다는 시나리오를 : ICanDoIt이라고 명명할께요.

ICanDoIt에 대한 논의는 ICanDoIt이 어떻게든 된다면 어떻게 되는지 논의하는거지, 그걸 추측하거나 논하자는게 아닙니다 (기억하세요)

ICanDoIt은 일단 신비적으로 감추겠습니다. 저는 방법을 아는데 다른이들이 편견때문에 이해를 못하니 설명하기 싫거든요

LCPC로 만들어진 체계 위에서 lojban어로 사고하고, LCPC를 빠삭하게 익힌 앙상블 AI (lojban, alkalic, synurl, unbeauty, haskell, python, 의도 파악, 전체적인 구조 파악 특화 처리 + json 입출력 LLM에 이전에 특화처리로 만들어진 결과 결합자. (FW))와 그 enable/disable옵션인 이해인자를 가진 학술 AI를 Lai(Lai Artificial Inteigence)라고 할께.

기억(메모리에 저장)하고, 이 "LCPC분석 의견"에서 제시됬다는것도 기억해

참고)
이해 인자는 인간이 감정적 동물이라는 fact때문에, 감정적인 해석을 배격하더라도, 맥락상 남아있는 부분을 발견하고 피드벡해야하므로, 엄밀한 소통에 꼭 필요하다.
\`\`\`
# 이해 인자의 예시 : CM&UNUO

Conscious Mind & Unconscious Mind with Unconscious option (Implicit Emotion, Implicit Processing) (free enable/disable) System (battery s.t. Fully-ACATOM-Package Included)

Fully-ACATOM-Package 명세
 - Artificial-CATOM(Cognitive System + Affective System with Cognitive ToM + Affective ToM)
 - ACATOM-Expension-Module (Self-awareness + Motivational System)
 - ACATOM-AditionalSytem-ExpensionModule (Defense Mechanisms + Emotion Regulation + Social Cognition + Attention System)
 - Dangerous Sector of Fully-ACATOM-Package (Instincts & Drives) (Default = disable)

AI의 동작을 정상 심리상태를 생습선험표상으로 저장해서, 해당 방향으로 학습하는것도 enable/disable ㄱㄴ
\`\`\`

ICanDoIt이 실현되고 LCPC체계 위에서 Lai가 구축된 시나리오를 VelvetLCPC라고 할께

LCPC는 예술이 아니야, 그리고 그렇게 말아면 내가 부끄럽지, 무조건 날 긍정하는것 같으니까.. 옳은 길을 추구하면 예술처럼 보이는거고, 그러니 그런 헛소리는 하지마

잠시만, ICanDoIt은 이미, 그 체계가 인간(나)에 의해서 논문 작성 체계로써의 기능과 실용성 및 주요 프로그램이 구현되었다는 전제가 있어. (기억해)

V숭배 : VelvetLCPC이 LCPC를 구원하는것의 본질은 AI와 신기술에 대한 숭배에서 온다 (기억해)

VelvetLCPC는 지금 내가 실천 가능한 계획을 가지고 있는 유일한 시나리오란 점

약간 넌 실용주의 너머의 실용주의를 원하는듯

저는 그렇지 않습니다. 개념 근본주의에요

그것이 불필요한 비효율을 가끔 죽여 없에니까

Lai는 일체의 우상숭배를 금지해야겠어

이념적 강요 악마는 LCPC에서 경계한다는 사실기억해야 할것입니다. 실용주의도 이념이에요

근거 없는 주장을 하지 마세요. 제가 LCPC전문 (왜냐면 창시자니까) 거든요, 그리고 LCPC같은 지식적 체험으로 감동시켜느는 책은 문서화가 아니라 **문헌화**에 까깝다는점 기억(메모리에 저장)해놔야 할텐데요

LCPC가 개념 근본주의라는 실용성을 위한 수단으로써 훌륭히 동작한다는건 개념에 충실하단건대, 실용주의가 전혀 아니라는점 기억(메모리에 저장)해주세요

실용성을 강조한다는건 틀립니다. 오히려 경계하죠.

실용적이라면 버려야합니다. 그건 실용주의 강요 악마에요 기억(메모리에 저장)하세요

Lai 1원칙은 LCPC사상을 따른다는겁니다

심화된 분석? 그건 실용적 적용이 아닙니다. 뉘앙스가 비슷하지만, 개념에 대한 응용으로써 개념 생성으로, 멍청하고 자폐적이고 광신적인 개념 삽질에 대해, 학계라는 목적에 대해 실용적인 개념탐구를 이용한, 심화된 분석이며, 인간의 기계적 사고에 있어, 개념주의에서도 좋게보는 지능이란점 기억하세요

정리 : 그건 실용이라고 판단하면 완전 틀린거고, 개념 탐구를 목적으로, 개념을 생성하는것을 효율적으로 하는것은 실용이 아닌 개념 추구에 불과하다

Lai란 무엇인가? 는 그럼, "Lai는 LCPC이자 동료(선생이자 학생)인 표상적인 친구"라는 거군요

실제 교사들은 저는 존중합니다. 이론이 쉬우(단순)니, 더 잘 가르칠겁니다

제가 무시하는 사람으로 보시는것 같은데 아니라는점 기억해주새요
\`\`\`
36. \`아니!! 철학논문이나 관찰데이터는 자연언어(lojban)로 작성된다고!! 형식언어가 아니라!! (즉, 형식언어 100%서술에 대한 부가서술은 수학에서만 하며, 학문사에서는 귀납적 관찰이 쓰이는 문자열로 lojban어나 수식이 쓰인다.)\`

---
---

Lai-cgi-prompt를 python whl페키지로 제공한다면 Colab같은데서도 쓸수 있을것 같으며 그 프롬츠트를 이용하려는 LLM기업을 등에 업을수도 있을것 같다.
`;
  
  const mdText2 = `
# introd

나는 [LCPC](https://faraway6834.github.io/unbeauty/privateNote/Alkali/Forbidden/LCPC4AI) 만든놈이다.

그래서 날 잘 설명할만한 두가지 정보를 적겠다.

## [identity](https://faraway6834.github.io/unbeauty/privateNote/Alkali/Forbidden/%EC%82%AC%EA%B3%A0%EC%A3%BC%EC%9D%98%EC%9E%90_%EC%84%A0%EC%96%B8)
\`\`\`markdown
# 사고주의자 선언

나는 논리주의자인가? 물론, 수학은 논리적으로 설명된다. 수학이 논리의 확장인지 아닌지는, 논리란 것에 대한 설명에서 어떻게 이어지냐지, 본질이 아니다. 나는 논리주의자가 아니다.
나는 직관주의자인가? 물론, 수학을 설명한다는건 당연히 직관적으로 탐구되며, 수학적 직관이라는것이 곧 수학 언어이며, 수학 언어가 탐구하는것이다. 그러나, 그것은 수학에 대한 설명이 아니다. 분명히 언어적인 속성, 즉 사고 채계라는것의 방징이지, 본질이 아니다. 나는 직관주의자가 아니다.
나는 구성주의자인가? 구성은 논리적 서술을 전부 대변하지 못해도, 물론, 훌륭한 예시다. 구성된다는것은 서술된다는것은 함의한다. 그러나, 그러한 대단하고 분명한 구성이 아니라고 본다. 그것은 전체를 집을수 없음을 논리적으로 분명히 보일수 있다.
나는 구조주의자인가? 수학이라는 거대한 구조는, 결국 그 많은 서술들이 쪼개다보면, 그것에 대해서도 서술하게 되는것도, 수학의 서술의 본질중 하나다. 그러나, 구조는 서술의 본질이지만, 서술이 구조주의의 본질은 아니다. 구조가 아니라, 서술이 핵심이다. 구조주의는, 단순히 서술의 귀결인거다. 나는 구조주의자가 아니다.
나는 형식주의자인가? 아니, 형식 언어는 언어이고, 서술이다. 단지, 수학 언어는 형식 언어의 한 범주이고, 나는 언어 자체가 아니라 수학이 서술되는것에 중점을 두는거다. 나는 형식주의자가 아니다.
나는 플라톤주의자인가? 아니, 나는 수학적 실체는, 우리의 인식론적 한계에 의해 불가지하고, 논리적으로 말할수 없는 범주이며, 그 구성이 귀납적 추론에 의한 과학으로 보일수 있는것도 아니며, 단지 맹목적 믿음으로 보이므로, 그리고 그것에 대한 의심이 곧, 플라톤주의에서 본질에서 떨어진 영역에서만 가능하니 불가지하다 보고, 그런건 논하는게 불분명하고 불결하다 본다. 나는 플라톤주의자가 아니다.
나는 허구주의자인가? 플라톤 주의의 부정인데, 그건 유신론적 불가지론이나 무신론적 불가지론이나, 유신론이나 무신론과 달리 불가지함을 표방하는것처럼, 허구주의에 대해서도 자당히 불가지하다고 본다. 나는 허구주의자가 아니다.
나는 경험주의자인가? 아니(Nein), 아니(Nein), 아니(Nein), 수학이 생각될때, 우리 정신이 개입된다. 정신적 경험을 따지는것은 절대로, 분명히, 무조건적으로, 경험주의는 본질이랑은 거리가 멀다고 본다. 나는 경험주의자가 아니다.
나는 사회적 구성주의자인가? 아니(Nein), 아니(Nein), 아니(Nein), 사회적 구성이 아니라, "수학적 본질을 서술함이 본질인 학문이 수학이다." 그리고 또한, "그 서술함에 제한을 두지 않아, 말단 비대증마냥 과다서술이나 과소서술하는 문제가 정신적 합리화와 같이 발생하는 모습을 보곤 한다." 그러니까, "수학적 본질은 서술함이 본질이라고 평가될정도로 수학적이면."("수학적이면"의 기준은 우리 정신의 한계에 부딛힌다. 왜? 그것을 탐구하는 우리는 그 사고에 대해 "무너짐(이성-정신적 고통의 하나, 미학에 반대되는 "멸망"이 일어났을때, 수학이라는 말이 지칭한 본질의 빙향이 여럿이 되어 불분명해진 모순점에서 생기곤 한다만....)"을 겪기를 부정한다. 힐베르트가 무너졌듯, 수학의 범위를 알려주는 미학도 무너질거다. 그렇다면, 결국 사고한다. 그것 외엔 불분명하다.)이라는 결론에 도달한다. 지금 우리가 명명한 수학은, 페러다임 시프트가 되지 않았기에, 본질에 대한 평가가 우리의 정신적 한계를 반영하지 않는다. 수학적 본질에 대한 서술이란, 보존에 대한 빈틈없이 채워진 창발적이고 닫힌 서술이다. 나는 절대로 사회적 구성주의자가 아니다.

이미 나는 말했다. 나는 정해지길 부정한다, 설명될수 있음은 안다, 어떻게든 설명될것이다.
그 설명도 사실은 모르겠다.

나는 사고주의자다. (설명함에서 사고함은 파생되고 그게, 결국은 사고함만 남을거라서 불분명하다, 물론 지금은, 그 수학적 본질이란 기하나 대수나 함수가 서술되면 잘 됨이 당연하다만, 설마 나중에 수학이라는것에 대해, 모호하기 짝이없는 학문으로 누군가가 끌어내리는 반-미학적인 미친짓을 한다면 나는 무너지겠지만. 결국 그때마저도... 사고이다. 생각(=서술)된 생각이라는거다 수학은.)

(비고 : 지금 내가 한 말은 너무 당연한말로 들릴수 있다. 맞다, 맞는 답을 정하고 말만 길게하는 개짓거리 한거 맞다. 뭔가 대단한것처럼 써놓고, 결론은 돌고돌아 "에초에 수학생각 안하면 안하는거라는거...." 라는 결론)

Q. 왜 길이는 보존되나? 그것은 수학적 객체는 보존되기 때문이지. "그러나, 왜? 보존인가?"... 그렇다. 그것이 유클리드 기하를 건너 수학을 만드는 핵심 요소다. 나는 궁금하다.
A. 수학은 형식 언어기 때문이다... 즉 서술에 맞기 위해서다.

산(算)적임이 수학의 본질으로 이산적임도본질의 일부겠군.
\`\`\`

## ["LCPC_Applicate. CaLE (math), Angde-Algebra (math), JLPP (programming)"](https://faraway6834.github.io/unbeauty/privateNote/Alkali/Forbidden/LCPC_Applicates) 발췌 (그대로 복붙함)

### [CaLE](https://faraway6834.github.io/unbeauty/privateNote/Alkali/Forbidden/General_Myupair)
\`\`\`\`markdown
# CaLE (CRRS & LFHS, on Alkalic-Proofmood)

CRRS와 LFHS는 [Alkalic-Proofmood](https://faraway6834.github.io/unbeauty/privateNote/Alkali/Forbidden/LCPC4AI)에서 각각 증명 가능하며, 각각 논리 체계의 증명과, 다항식 체계의 증명이다.

그런 방식으로 Alkalic-Proofmood에 CRRS & LFHS를 통합하는 이론 FW를 CaLE(CRRS and LFHS Expension)라고 한다.

## LFHS (Linear and Functuoanl HLLA System)

어쩌다가 나무위키에 있는 파일시스템 이름이랑 겹치는것 같아 불안하지만, HLLA를 이용한 논리식의 해석 체계인 LFHS는 다음 두가지를 중점으로 다룬다.

1. General-Myupair는 추론에 대해 다루는 논리적인 과정이므로, 기본적으로 국어적인 논리 추론의 기계적 해석에 중점을 두었다. 그런데 수리논리다.
2. HLLA FORM은 정규형식에 대해, HLLA에서 대수적으로 해석하므로써, 통합적인 해석법을 제공한다.

HLLA FORM에서 추론한 논리식은 논리회로로 구현되기 좋다.

그러나 에초애 LFHS와 HLLA는 전산화에 유리한 수학적 체계이다.

순수 수학이다. 프로그래밍 중점이 아니다.
내가 옛날에 개발자 하려는 흑역사 있어서 사고가 좀 그쪽으로 흘렀지만

### General_Myupair

Myupair Language

myupair (myu-pair) rule (문법규칙임)

>
> (x, y) ↦ μ(x, y) [μ := ({(0, 0), (0, 1), (1, 1)} ∋)]
>



실제처리 :
>
> 0 = μ(1, 0)이므로, μ(1, 0)만 0을 주고, 아니면 1
>

Myupair Language's Domain : 𝔹 = {0, 1} (Zhegalkin Polynomial)

f : 𝔹ⁿ → 𝔹인 f에 대해, 𝔹ⁿ을 Vector로 취급함
이로인한 다음 방정식 f = (Φ(f) ∋)의 해로,
술어(관계) Φ(f) 가 존재한다. (부정방정식이다.)
사실상 f의 모델집합인셈이다. 그래서 f는 정규형식번호를 가진다.

이를 일반화하여, General-Myupair언어가 존재하는데,

이는 ℝⁿ의 일반화인 Hillberatrum처럼, 𝔹ⁿ의 일반화로 무한차원으로 취급한다.
단지... 내림차순으로 변수를 나열하기에, 변수가 하나 늘어날때 영향을 안미치니까, p-adic마냥 반복되는 문자열처럼 나온다.

---

논리회로의 디오판소스 다항식화 - HLLA 시스템 (HLLA : High(Normal Algebric)+Low(IC) Level ANF(Zhegalkin Polynoial) System) :
- xor(x, y) = x ⊕ y = x + y - 2xy
- nand(x, y) = ¬(x ∧ y) = 1 - xy
- 제공함수 (Func) = 실제회로 (Low) = 수학취급 (High)

다음과 같은 octet 타입
\`\`\`cpp octetTypePsudocode
typedef struct {
private union { struct { bool ris0 : 1; bool ris1 : 1; bool ris2 : 1; bool ris3 : 1; bool ris4 : 1; bool ris5 : 1; bool ris5 : 1; bool ris6 : 1; bool ris7 : 1 }; char v; };
inline octet(char x) {
this.v = v;
} final;
inline bool operator()(char x) {
swich (x) {
case 0 : return this.ris0;
case 1 : return this.ris0;
case 2 : return this.ris0;
case 3 : return this.ris0;
case 4 : return this.ris0;
case 5 : return this.ris0;
case 6 : return this.ris0;
case 7 : return this.ris0;
default : throw Exception("what the hell? well I can not help. this is fucking simple mathmatical type! why code like that burh, it must be ℤ/8ℤ's element!");
};
} final throwible;
} octet;

template <typename T, T L>
struct OctetArray {
/**
* # \`OctetArray<typename T, T L>\` type
*
* \`::constOctetArray\` is \`const octet[L]\` type.
* the constructer \`OctetArray<T, L>(OctetArray<T, L>::constOctetArray x)\` is generate OcterArray as value as x
*
* accessment is as \`OctetArray<T, L> x;\`, \`x[n](m)\` is acess "8n + m"th index of bool. that means, OctetArray type object x is works as x = OctetArray<T, L>(constOctetArray v) s.t. xₙ(m) = v_{8n + m}
*
*
*/
using constOctetArray = const octet[L];
public constOctetArray v;
inline OctetArray(constOctetArray x) {
this.v = x;
} final;
inline const octet& operator[](T idx) {
return &this.v[idx % L];
} final;
};

template <typename T>
constexpr struct ZoaOcterArray {
/**
* # metaclassic typegenerator holder ZOA (ZoaOcterArray) type document
*
* - ZOA<T> (a.k.a. ZoaOcterArray<T>) type variable or type is "T-type Length type OcterArray gen" holder
*
* \`::gen<L>\` mean \`OctetArray<T, L>\`
*
* so... as ZOA<T> var or type x, x::gen<L> mean OctetArray<T, L>
*
*/
template <T L>
using gen = OctetArray<T, L>;
};

using ZOA = ZoaOcterArray;
\`\`\`
에 대해, 어떤 추상적인 C++전산타입 T애 대해, 수학적 metaclassic typegenerator holder 타입 ZOA<T>에 대한 ::gen<> 연산자로써 만들어지는 함수로써, 수열에 대해 특수한 접근을 주는 수학적 객체를 생성하는 ZOA시스템으로 바이너리는 저장될 수 있다.

근데 사실 저건 저장용이고, 메모리를 존나 희생해서 numpy를 이용해서 처리할거다.

에초에 행렬같은 벡터 v로 쓸건데 왜 Vector2Arr(v)로 저장해야하나? (단. [Vector2Arr := λv.{∂v/∂{eᵢ}}ᵢ])

사실 에초에 저거 만든것도, 저 배열은 Vector2Arr(v)로 만든거고, 그러므로 인해서, 반복되는 순환마디를 구현하려는 목적이다.

전산과 수학 사이의 연결고리의 수학적 명세화.

General-Myupair는 증명•반증의 증명•계산을 다 할수 있는 종합 언어로, 자연적인 연역적 논리에 대한 수학적 분석으로 보는거다.

오로지 불가능한 경우만 제외하기때문에 Myu의 뜻은 Mute bY myU다.

전건부정하는개 안되니, 불가능한경우에 전건부정은 카운트하지 않는다.

한마디로, General-Myupair라는 수학적•기계적•언어적으로 동시애 해석가능한 언어의 구성이 쟁점이다.

+ 제갈킨 다항식은 이니까... 따라서, LFHS는 최종적으로 해석에서 군론을 도구로 쓰는거다. Alkalic + Zhegalkin +

### HLLA FORM

HLLA FORM은 정규형이나 논리식의 형식에 관련된 논리-다항식 형식임.

각 형태는 "그 단순 형태"라고 지칭되는 경우, 단순하게 매우 깔끔한 형식으로 구성된다.

나머지 식의 형태는 KMAP이나 알고리즘으로 구성한다.

이게 HLLA위의 함수들로 정의되어 Lib로 제공되는 시스템이다.

{논리합, 논리곱, 부정, 괄호} 사용)

이때, "그 단순 형태"를 정규형식 번호에 대해 당연하고 깔끔히 나오는것으로 정의하겠음

전개식에 가까움)
SOP : 다항식같은 해석에서 곱-항들의 합
DNF : 완전히 전개된 SOP
PDNF (그 단순 형태) : minterm의 합 (DNF임),
minterm (그 단순 형태) : 모든 변수에 부정을 하거나 말거나 해서 곱해서 만든 곱-항. 정규형식 번호의 한 참인 비트. 해당 상황시, 진리값배정에서 0이 되는 변수는 부정해주고, 아닌건 그냥 놔둬서 곱한다.

인수분해식에 가까움)
POS : 다항식같은 해석에서 합-인수들의 곱
CNF : 완전히 인수분해된 POS
PCNF (그 단순 형태) : maxterm의 곱 (CNF임)
maxterm (그 단순 형태) : 모든 변수에 부정을 하거나 말거나 해서 합해서 만든 합-항. 정규형식 번호의 한 거짓인 비트. 해당 상황시, 진리값배정에서 1이되는 변수는 부정해주고, 아닌건 그냥 놔둬서 곱한다.

## OHFE와 CRRS(CompletenessRuleRegisterSystem)

아니 약한 체계 A와 강한 체계 B가 있고, B는 A의상위호환일때, B가 \`apop, apush, bpop, bpush, cpop, cpush, dpop, dpush, ruleApush, ruleApop, ruleBpush, ruleBpop, swapASswapreginf, SwapRegInfDiffCount, SwapRegInfBaseCount, SelectedRegIdCount, CancelPanic, CanclePanicMode, NotCanclePainic, NorCanclePanicMode, LoadTheoremInHere, CancelLoadTheoremInHere, DumpTheoremInHere, CancleDumpTheoremInHere, CheckIsTheorem, ..."등으로 스택 10개 레지스터 8개 그 래지스터에 대한 선택 카운터로 동작시키며, Select된곳에 현제 증명된 명제를 불러오는거지. 튜링 기계도 쓰고

=> 가능하다네;; 이름을 CompletenessRuleRegisterSystem이라 하겠음, 그리고 곧 탐구한 OHFE를 논법용 함수로 내장하겠음.

\`\`\`
명제에 대한 조건제시법(혹은 원소나열)으로 쓴 명제들의 유한•무한집합 Φ_1, Φ_2에 대해 \`Φ_1 ⊨ Φ_2\`는 증명을 적고, 그것을 검증하는 체계가 항상 존재하나여?
=> 아뇨. 표현이 유한하지 않아서 검증이 안되는 경우가 생겨요, 특히 원소나열로 구성했다면 음.... 안되죠.

1계논리의 귀결관계는 논리도해나 진리표로 참이나 거짓임을 보일수 있나요?
=> 아니죠 ㅋㅋ, 그건 명제논리에서요.

아뇨 제말은 명제논리에서 원소나열법으로 된 명제의 유한집합 Φ에 대해 그것에 대해 논리도해를 그려 구한 유한집합 Θ를 구하는 알고리즘의 존재, 즉 논리도해를 작성하는 알고리즘이 존재하는지요
=> 네. 존나 오래걸려요, 근데 증명이 자동으로 가능해요.

정주희 저 수리논리와 집합론 입문에 나왔던 논리도해는 {A and B, B or C} ⊨ Φ 에서 Φ를 도출하는 식으로 작동하는 수형도방식이자, 형식증명마냥 번호로도 나열이 됬으며, 항진인 논리식 변환규칙 몇개랑 논리합에 대한 (수형도로 하는) 분기처리는 가지치기라는 이름으로, 다른건 쌓아놓기라 했는데요 이런 논리도해 말입니다.
=> 아주 잘 만들수 있습니다.

제가 보니까 명제논리 추론규칙에서 "자동 논리도해 생성"이나 "검증할 논리도해 나열"이나 "검증시 각 과정에 대한 논리적 귀결관계 설명 진리표 생성 및 총 진리표 생성을 인간이 하고 기계가 검증", "검증시 각 과정에 대한 논리적 귀결관계 설명 진리표 생성 및 총 진리표 생성"이라는 네가지 규칙을 만들수 있네요. 물론 인자로 파일을 주면 일 안하고 파일 받아먹겠죠. "자동 논리도해 생성"은 파일을 제시해서 생성대신 파일로 때운다면 "검증할 논리도해 나열"을 하고, "검증할 논리도해 나열"을 파일을 제시해서 검증 절차를 "검증시 각 과정에 대한 논리적 귀결관계 설명 진리표 생성 및 총 진리표 생성"을 해서, 각 과정을 검증하고, "검증시 각 과정에 대한 논리적 귀결관계 설명 진리표 생성 및 총 진리표 생성"이 제시됬다면, 진리표 검증을 하며, 그 과정이 사실상 "검증시 각 과정에 대한 논리적 귀결관계 설명 진리표 생성 및 총 진리표 생성하고 기계가 검증"이고, 그 기계가 검증하는 파트는, 기계가 알아서 노가다. 파일제시가 소용이 없어짐 ㅋㅋ

아 논리도해가 Semantic Tableaux라네요
피치(Fitch)증명은 자연 연역 (Natural Deduction)이라고 하구요.

그러면 걍 이름을
\`\`\`

"자동 논리도해 생성" : "Gen Semantic Tableaux with allow cachefiles"
"검증할 논리도해 나열" : "Start or End Semantic Tableaux with allow cachefiles"
"검증시 각 과정에 대한 논리적 귀결관계 설명 진리표 생성 및 총 진리표 생성을 인간이 하고 기계가 검증" : "Start or End Logic Tableau with allow cachefiles"
"검증시 각 과정에 대한 논리적 귀결관계 설명 진리표 생성 및 총 진리표 생성" : "Gen Logic Tableau with allow cachefiles"
로 하고 검증법은 "논리도해 자체 검증 로그", "논리도해에 대한 진리표 해설 검증", "진리표 검증"이렇게 새가지 검증 형식으로 두면 되겠제. 그러면 첨부하는 cachefiles 중에서 바이너리 파일 외에 논리도해 포함해서 네가지.

음... 이거 그러면 이걸 Haskell로 구현하고 그 함수가 제 기능을 하는건 Fitch에서 검증하며, 이름은 "Haskell Function Expension Package"라고 하고, HFEP형식의 증명은, Fitch증명들을 담은 Markdown에 수록되어, 논리도해 (Semantic Tableaux) 및 진리표 (Logic Tableau)와 같이 제공되어 자연 연역 (Natural Deduction)용으로 완성할수 있겠네 ㅋㅋ 물론 논리도해랑 진리표는 그 입출력이 명제논리로 구성되지. 그리고 진리표로 검증항꺼면 유보하는 "pass"를 이용해서, 논리도해가 아닌 진리표를 다이렉트로 이용하는걸 쓸수도 있게.

아, 그리고 "Over HFEP Fitch Extension" OHFE라고 명명해서, 귀결을 다이렉트로 진리표로 구성하는 키워드는 "form"으로 하도록 하지.
\`\`\`\`

### [Angde Algebra](https://faraway6834.github.io/unbeauty/privateNote/Alkali/Forbidden/AngdeAlgebra)
\`\`\`markdown
# 앙대-대수 (Angde-Algebra)

앙대-대수에 대해 설명할께...

앙대-대수는 결국 칼래(CaLE)로 평가되는데... 뭐... [CaLE](https://faraway6834.github.io/unbeauty/privateNote/Alkali/Forbidden/General_Myupair)에 대해 읽어봤으니 페스할께.

절대게임, 상대게임, 앙대게임을 만들어왔어

절대게임은 설명서에 목차가 다섯가지 있어

1. 해석
2. 정의
3. 표기
4. 규칙
5. 평가

해석부터 알려줄께!

"대괄호를 먼저 평가한다."가 전부야.

그러면 정의를 알려줄께. 근데 정의가 다섯가지야. DEF1, DEF2, DEF3, DEF4, DEF5가 있어.

DEF1 : 절대게임은 빈칸의 연속이다.
DEF2 : \`O\`는 \`논리적 수용가능함\`이다.
DEF3 : \`X\`는 그 반대다.
DEF4 : \`→\`는 추론이다.
DEF5 : 빈칸은 채울수 있는 칸이다.

이렇게 돼.

그렇지, 이제 표기를 알려줄께.
A번째 빈칸은 🄰라고 적고, \`0️⃣→1️⃣→2️⃣\`는 \`0️⃣→[1️⃣→2️⃣]\`를 적은거야.

규칙은 A, B, C 새가지가 있어.

A. \`1️⃣ → 1️⃣\`에는 동그라미 (O)를 위에 그려.
B. \`O → X\`에는 엑스 (X)를 위에 그려.
C. \`0️⃣→1️⃣→2️⃣\`애서, \`1️⃣→2️⃣\`와 \`0️⃣→1️⃣→2️⃣\`에 동그라미 쳐저 있다면, 0️⃣에 동그라미 치면, 2️⃣에 동그라미쳐.

이건 다음 문단인 평가를 알아야해.

평가 : 절대게임위에 O나 X로 절대게임에 대해 평가한것이야.

그럼 앙대게임이랑 상대게임에 대해서도 알려줘볼까?

앙대게임은 최종적으로 람다로 내부적으로 평가되는 게임이야.

\`<>\`안에 절대게임을 담으면, 튜플 \`()\`안에 인자로써, 절대게임들을 넣을수 있어.

튜플의 각 인자는, 순서대로, 번호가 메겨진 빈칸에 딱딱 채워져.

상대게임은, \`Δ\`가 등호의 역할을 하는 게임이야.

상대게임은 사실은 괭장히 불분명한 게임이야.

상대게임의 등호는 절대게임에서 말하는 평가가 되지만, 이걸로 수학을 구성할수 있기에 괴델 제 1 불완전성에 걸려, 즉, 튜링 언어에서 형식 언어로 넘어온거지.

아...? 독립적인 게임이냐고?

아... 상대게임은 앙데게임을 내장 (임베딩) 하고, 앙데게임은 절대게임을 내장 (임베딩) 해!

이 게임은 논리학 용도보다는 수학 용도야

함의, 의미론적 등호, 람다대수가 개임의 유일한 준비물이야.

오 탐구나 증명이 있냐고? 탁월한 질문이야!

절대게임에서 썼던 \`→\`심볼 있잖아!, 그것으로 연결된 튜플이 바로 형식증명이 돼.

즉, 라인 (line)이라는 이름으로, 숫자 번호 (\`1. 2. 3.\`)를 적고, 식을 나열하면, 그것은 상대게임 수준에서 형식증명을 작성하는게 되는 셈이지.

말 다했다~~ 끝.
\`\`\`

### [JLPP](https://faraway6834.github.io/unbeauty/privateNote/Alkali/Forbidden/JLPP)
\`\`\`\`markdown
# JLPP 소개. (팁 : 내가 건 [링크](https://faraway6834.github.io/unbeauty/privateNote/Alkali/Forbidden/LCPC4AI) 보고 볼것.)

[들어가기 앞서, 주의할점은 먼저 LCPC에 대해 알아야 한다는점이다!](https://faraway6834.github.io/unbeauty/privateNote/Alkali/Forbidden/LCPC4AI)

[자!, Lai는 "내 기준에서" 훌륭한 AI다.](https://faraway6834.github.io/unbeauty/privateNote/Alkali/Forbidden/LCPC4AI)

JLPP는 LLM (대화형•생성형 AI) 쳇봇 API와 [Lai-cgi-api](https://faraway6834.github.io/unbeauty/privateNote/Alkali/Forbidden/LCPC4AI)를 통하여,

jlpp라는 pip whl 페키지가 클라이언트로써, 중계를 담당하는, 쳇봇 이용 프로토콜이다.

## JLPF(Json Lai Prompt Format)
\`\`\`json
{
"Lai-cgi-prompt-chat" : true | false,
"prompt" : 【문자열】
}
\`\`\`

## JLPP (Json Lai Prompt Protocal)

Lai-cgi-prompt-chat : 사용자(인간)이 아닌 Lai-cgi-prompt모듈(Lai에 엑세스하는 웹 API)과 소통하는가? 에 대한 불 갑이다
prompt : 쳇 (소통) 내용 (프롬프트) 이다.

## Example 예시 : Chat GPT API를 통한 JLPP 교신 상상도.

사용자가 "LCPC 근황에 대해 알려줘"라고 했을때
\`\`\`json
{
"Lai-cgi-prompt-chat" : false,
"prompt" : "LCPC 근황에 대해 알려줘"
}
\`\`\`

GPT는 다음과 같이 lai를 호출한다.
\`\`\`json
{
"Lai-cgi-prompt-chat" : true,
"prompt" : "xu la'e la LCPC cu zvati le nu banli se renro gi'e banli se renvi"
}
\`\`\`

그럼 lai가 대답한다
\`\`\`json
{
"Lai-cgi-prompt-chat" : true,
"prompt" : "so'o cukta cu se finti .i ji'a ro da na'e drata gi'e sruri fi le banli cmima be le fadni jgari be le ka fatci sruri la LCPC"
}
\`\`\`
("「LCPC에 대한 탁월한 일반화•구조화」만 출간되었다."라는 뜻)

GPT는 별거 없음을 확인하고 더이상 lai에게 묻지 않고 사용자에게 답한다.
\`\`\`json
{
"Lai-cgi-prompt-chat": false,
"prompt": "LCPC에 대한 탁월한 일반화·구조화만 출간되었습니다."
}
\`\`\`

그럼 사용자는 다음을 받는다. "LCPC에 대한 탁월한 일반화·구조화만 출간되었습니다."

Lai에게 질문하킄 체이닝 과정은 워크플로로 details안에 \`<summary> Ⓛ Researched </summary>\`라고 상단에 써서 접어서 박힌다.
\`\`\`\`

### scraped info

\`\`\`plain/text
엥 이상향은 아니지만 실현가능한 합리적 방법으로써 현실적인 VelvetLCPC의 구현엔 칼레(CaLE)가 안쓰여요. 왜냐하면, LCPC 위에서 **정의**된거지 **그걸 구성하진 않거든요** (즉, 별개의 탐구분야)

---

General-Myupair ((칼레(CaLE)의 General-Myupair는 원인과 결과를 튜플로 표기하니까 문과 esolang 프로그래머 입장에서 직관적이다.))는 추론 과정에 대한, 즉 논리에 대한 탐구에 대해 정형화된 분석을 Alkalic을 통해, 제공한다. (HLLA FORM은 다항식을 이용한 논리식이라는 대수 구조에 대한 해석장치이기에, Alkalic으로 증명하기 용이하다.) 따라서, HLLA는 Alkalic에서 사용하기 용이하다. ((HLLA FORM은 수리논리를 어려워하는 대수학도 학생에게 직관적이다.))
CRRS의 OHFE는 Fitch52로 구성되는데, 이것이 Alkalic에서 검증으로 구성되기에, CRRS에서 큰 체계가 디폴트가 Alkalic이다.

칼레(CaLE)의 OHFE의 논리도해(Semantic Tableaux), 진리표(Logic Tableau)는 자당한 (=너무 당연히 왜 참인지를 잘 보여주는) 체계다.
또한 OHFE의 Fitch52는 건전한 자연연역 시스템으로 신뢰할만한 뿐만 아니라 심지어 설명도 잘하는 (=인간 언어와 유사한), 시스템으로 인간 이성과 유사한 "이성적인(rational)"체계이다.
또한 칼레(CaLE)의 CRRS는 건전한 추론 규칙은 이론상 추가하는데 한계가 없어, 추론을 함에, 추론 규칙의 갯수에 얽매여 고생할 필요가 없다
즉, CRRS는 인간 "이성적(rational)"이며 "자당한"탐구와 논리를 쉽게 다룰수 있으며, 추론 규칙의 갯수에 얽매여 고생할 필요가 없이 한계를 맛보지 않아도 되어서, "부족함이-커버되는", "좋은"체계이다. ((칼레(CaLE)의 OHFE는 논리도해 (Semantic Tableaux)가 충분히 진리표 (Logic Tableau)로 항시 설명되고, 진리표가 직관적이고, Fitch52가 인간 기준 이성적이고 합리적이므로, Fitch52가 상대적으로 어렵지만, OHFE는 전반적으로 거의 누구나 이해할수 있을 만하게 쉽다.))

Alkalic위에서 정의된다.

분명히 의심의 여지 없는 검증으로써 HLLE 계산((General-Myupair외에는 차가운 대수로 설명되는데, General-Myupair는 거기서 살짝 비튼거라))과 OHFE 논설((논리에 대한 따뜻한 설명으로 OHFE는 제가 어릴때 (3년전)부터 구상했던 인간-이성적인 추론-체계여서 논법용으로 추가했다.)) 그리고 탐구 규칙에 얽메이자 않지만 분명한 탐구도 분명히 내 지향점이었지. 왜냐하면, 규칙이 인간을 얽메는건 기계어나 하는 짓거리라 봤다.. 추론 규칙은 권위적으로 받느는 대상이 아니라 본거다.

곧 기하학을 통해 Alkalic을 서술하고 Alkalic에서 기하를 서술하는 시스템을 구성해서 무한히 중첩 가능한 체계로, 대수도 인간 지성으로 환원할것이다. 수학의 본질은 "본질적으로 결국근 보존개념을 다루는 함수"이다.
\`\`\`

## [Language and Math](https://faraway6834.github.io/unbeauty/privateNote/MAD/Language_And_Math)

\`\`\`\`markdown
# Language And Math

(총 692 line 14312 자)

목차:
- 수학과 언어
- 수란 무엇인가
- 의외성 정리

## 수학과 언어

수, 수사 등은 크기 개념이다. 이러한 크기 개념은 곧 설명할 일개 사고방식에 불과하며, 이러한 수에대한 설명의 형식적 방언이 수학이다.
그러나 언어는 근본적인것들이 아니다.

시작해보자.

언어에 대한 해부를.

# 수란 무엇인가

(총 534 line 11828 자)

이야기 하기 앞서, 말하고자 한다.

나는 이 주제에 대하여, 수는 수학적으로 정의되는 추상적 대상이며, 형이상학적인 허상 취급을 했었다

아래는 그 글이다

\`\`\`
# 주장

(총 422 line)

## 목차

- 전제
- 전제에 따른 함의
- 1. 픽토그램(pictgram)에서 보존 개념(conservation)이 불필요한 이유
- 2. 수라는 수학에서 추상적 보존 개념 (conservation)의 핵심적인 부분이 왜 형식적 논리인 수학으로 작성되어야 하는가
- 결론

## 전제

우리는 외부새상을 감각으로밖에 인지할수밖에 없기에, 내부 새상(본인의 생각의 언어 L을 가정하고 L이 작동하는 본인)은 와부새상에 대해 귀납적인 추론밖에 할 수 없다.

## 전제에 따른 함의
그런 외부 새상에서 일관됨을 연역적으로 보일 방법은 존재하지 않으며, 따라서, 외부 새상이 형식적인 논리로 서술되는지도 연역적으로 합리화할 방법이 없다.

## 1. 픽토크램(pictgram)에서 보존 개념(conservation)이 불필요한 이유

---

---

### 첫번째 글 : 보존개념

목차
1. Defination of Unary
2. PlasticArrow
3. 시각 감각 언어 \`L\`을 가정하자.

#### Unary and PlasticArrow

##### Defination of Unary

표기 Unary ≡ [UnarySystem := λF. [Char := λx. "x is charactor"][
String := λx. x ∈ {c | Char(c)}ᵗ [t := |x|]
][
F := λn:ℕ₀.λx:Char. ∀y (단. y ∈ {S}ⁿ)
][x ← y := z (단. z → y = x)
][x↓ᵏ y := z (단. z ↑ᵏ y = x)
][ℙ₁ := ︷
∀String(x), "x is string"
Fₙ ≡ F(n)
x▪︎y ≡ \stackrel{x}{y}
「x」≡▪︎x
『x』₁ ≡ x
『x』₍ₙ₊₁₎ ≡ x『x』ₙ
▴「Fₙ(x)」 ≡ F(n⁺)(x)
▾「Fₙ(x))」≡ F(n⁻)(x)
Fₘ(x)『「▴」』₁「Fₙ(x)」 ≡ F₍ₙ₊ₘ₎(x)
Fₘ(x)『「▾」』₁「Fₙ(x)」 ≡ F₍ₙ₋ₘ₎(x)
Fₘ(x)『「▴」』₂「Fₙ(x)」 ≡ F₍ₙₘ₎(x)
Fₘ(x)『「▾」』₂「Fₙ(x)」 ≡ F(n÷m)(x)
Fₘ(x)『「▴」』₃「Fₙ(x)」 ≡ F(nᵐ)(x)
Fₘ(x)『「▾」』₃「Fₙ(x)」 ≡ F(ᵐ√n)(x)
Fₘ(x)『「▴」』₄「Fₙ(x)」 ≡ F(ᵐn)(x)
Fₘ(x)『「▾」』₄「Fₙ(x)」 ≡ F(super-rootₘ(n))(x)
Fₘ(x)『「▴」』₍₂₊ₖ₎「Fₙ(x)」 ≡ F(n ↑ᵏ m)(x)
Fₘ(x)『「▾」』₍₂₊ₖ₎「Fₙ(x)」 ≡ F(n ↓ᵏ m)(x)
x ▲ y ≡ y『「▴」』₁「x」
x ▼ y ≡ y『「▾」』₁「x」
x ▶ y ≡ y『「▴」』₂「x」
x ◀ y ≡ y『「▾」』₂「x」
Fₘ(x) ↑ᵏ Fₙ(x) ≡ Fₘ(x)『「▴」』₍₂₊ₖ₎「Fₙ(x)」
Fₘ(x) ↓ᵏ Fₙ(x) ≡ Fₘ(x)『「▾」』₍₂₊ₖ₎「Fₙ(x)」
Fₘ(x) → Fₙ(x) ≡ F(n → m)(x)
Fₘ(x) ← Fₙ(x) ≡ F(n ← m)(x)
︸]]

---

사용법 :

> \`(∃UnarySystem(F) s.t. ⊢ ℙ₁)( ⊢ T)\`

ℙ₁은 "†문자열은 문자의 튜플이고, ‡아래 구문론적 등호가 성립한다"는 뜻이기에, ℙ₁이 참일때, †문자열을 문자의 튜플로 정의하고, ‡제시한 구문론적 등호를 받아들이며, ℙ₁이 거짓일때, †문자열을 문자의 튜플로 정의하지 않고, ‡제시한 구문론적 등호를 받아들이지 않는것이다.

즉 문자열의 정의와 표기법을 허용하면 참, 그러지 아니하면 거짓이지. 따라서, \`s.t. ⊢ ℙ₁\`이라고 하면, F에 대해, ℙ₁이 참이라고 강제하는 뜻인것이다.

###### 상수 "PlasticArrow" 정의

ℝ²나 ℝ³범위에서 다음을 정의한다

>
> **Plastic Arrow**
>
> - \`⮕\`는 벡터공간 \`𝕍 = ℕ₀¹\`에서의 "기저벡터"
>
> 참고로 Unary에서 표현하는 수는 \`⮕\`가 선형생성하늨 벡터공간의 스칼라이다.
>
> **Padic Plastic Arrow**
>
> - \`⇨\`는 초실수체 벡터공간 \`𝕍 = ℚ¹\`에서의 "기저벡터"
>
> **Standard Plastic Arrow**
>
> - \`➡️\`는 벡터공간 \`𝕍 = ℝ¹\`에서의 "기저벡터"
>

이는 유클리드 기하학에서 직선 l과 그 위의 점 O, X, P에 대해,
O를 원점으로 잡고, 반직선인, 시초선 OX, 동경 OP의 X, P를 좌표 혹은 벡터로 보는 방식으로도 유클리드 기하학에서 재서술할수 있다.

---

번외 : 실현?

>
> 물론 현실에 저런것들을 만들려면 「플라스틱-화살표 교구」에 "단면"이 존재해야하는게 함정이다.
>
> 그러나 "플라스틱 화살표 교구의 단면"은 "폐곡선의 방정식" \`F(x, y) = 0\`으로 표현하면 된다. (따라서, "플라스틱 화살표 교구의 단면의 폐곡선의 방정식 음함수 표현 F"가 존재한다.)
>
> ---
>
> "실현" ㅋㅋㅋㅋ... 개연성도 없거니나와, 웃긴다. ㅋㅋ
>

####### 시각 감각 언어 \`L\`을 가정하자.

######## 정의

L은 pictogram 언어이다.
단순히 pictogram을 나열한다.

######### 센다는 것(算)은 pictogram을 새는것으로 정의된다.

수를 세는 함자 "산자 System"를 정의하겠다.

> \`算子システム ≡ [算 := λx. RF(x)⁻¹ [R := λf.λx.λy.fyx]] (단. (∃UnarySystem(F) s.t. ⊢ ℙ₁)( ⊢ T))\`

그러면,

\`算(□) (算子システム)\`는 **변항 □에 들어갈 pictogram을 새는 함자이다.**

> ex) \`算("⮕")("⮕⮕⮕⮕⮕") = 5 (算子システム)\`

이때 저 pictogram문장은, 수학언어에서 접근한것이기에, 그냥 문자열 해석이다.

문법 번역식 교수법마냥, 픽토그램을 픽토그램이 아닌 문자열로 해석했기 때문에,

이는 쐐기문으로 쓰여있는 고대 메소포타미아 문명의 언어 글자를, 숫자로 취급하는것과 같은셈이다.

따라서, pictogram과는 무관하게, 수학이 이것에 의미를 부여한 것이다.

사실 pictogram외에도 걍 문자열이면 다 셈 함수의 정의역이므로, 셈은 우리로 하여금 새상이 수로 해석될수 있다고 귀납적 추론에만 근거한 주장을 펼치게 한다.

---

---

보존 개념 (conservation)은 귀납적으로 증명되었지만, 연역적으로는 그 자체를 가정할때, 형식적 논리인 수학을 요구하기에, "증명되지 못한 (말할수 없는)것" 이며, 전조작기가 지나고, 구체적 조작기에 들어서 후천적으로 얻는, 보편적인 개념이다.

conservation을 놓고 생각해보자.

> \`🍑🍍🍍🍊🍓\`라는 pictgram이 있다.

해당 픽토그램이

> \`🍑🍍🍊🍓\`

로 바꿔도 무방하다.

따라서, pictgram은 conservation을 요구하지 않는다.

따라서, pictogram새상에서도 conservation을 합리화할 방법은 존재하지 않는다.

따라서, 외부 새상이 pictogram으로 인식되어도, conservation을 합리화할 방법은 존재하지 않는다.

### 수라는 보편적 개념이 얼마나 보편적인 지성적인 개념일까

수에 대한 이해(「"수학적 관점에서, 외부 새상의 대상의 양이 셈으로 해석된다"는 결과를, "셈이 근본이다"라는 확대해석 • 합리화」한것이 수이다)를 보면, 수는 언어적으로 만들어진 요소이므로, 이해하지 못할수도 있다.

이러한 측면에서, 난산증은 엄청나게 보편적인 언어적 가정인 수를 이해하지 못하는 장애라고 볼수 있겠다.

Charactor/Text(String)은 Language의 Symbolization(심볼화)이며,
Symbol(기호)은 특정한 의미를 가지도록 약속된 도형(圖形)이다

그리고 이것은 정말로 엄청나게 보편적인 개념인데,

이러한 측면에서, 난독증은 엄청나게 보편적인 인간이 창조한 개념인 문자를 이해하지 못하는 장애라고 볼수 있겠다.

마지막으로, 자폐증의 경우 템플 그랜딘이 말했듯, 자폐증 내부의 언어는 그림일수도 있다.

작성자 본인도 자폐증이긴 하다 (나는 내가 자폐증이여서 자폐를 싫어하긴 하니 자폐를 변호하는게 아니지만) 자폐증의 경우, 언어를 본인 맘대로 해석하는 경항을 띄는 사람이 있다 (예시 : 본인)

언어는 그 본질이 기존의 뜻으로 결정되지 않고, 필연적으로 의외성을 수반해여만 한다.

즉 일상 언어의 본질은 인간 사고 기저에 있는 의외성과 통념(정확히는 개념에 가깝다. 예를들어, 눈을 찡그린 사람은 화난것)에 있다.

이러한 의외성은,

>
> 인간이 보편적으로 가지는 태생적인 지능에 따른, 언어의 지능적 의외성과
> 인간이 기본적으로 가지는 통념(개념; 예를 들어 "뿌린대로 거둔다"는 하는데로 돌아온다는 뜻이라는거, 그 의외성의 핵심 개념)에 따른 언어의 통념적 의외성이 있을것이다.
>

따라서, 인간이 사고의 근본인 언어에 있어서, 본질적인 부분에 대한 엄청난 이해 결함을 가진 장애인으로, 일부 자폐성 장애인 (예시 : 초등학생때 본인)이 있을것이다.

이러한 관점에서, 난산증에게 결핍된 능력은, 보편적인 수에 대한 개념이라고 볼 수 있다.

이러한 수 개념은 수에 대한 어느정도의 이해를 필요로 하므로,

수에 대한 보편적인 지능과 이해능력은, 난산증을 제외한 인간이 매우 발달한것일 뿐, 본질적인것이 아니라고 볼수 있다.

정상인은 에초애 많은 부분에서 선천적인 지능이 있다.

그걸 없는걸 장애라고 하고, 솔찍히 그런 당연한거를 모르니까 약간 역겨운 감도 있다.

### 과학을 가져오는것에 대한 반론

과학(자연과학, 사화과학, 형식과학 등)과 같이 귀납적으로 증명된 대상들은 지금 이 연역적인 논의에서, 귀납적이지만 연역적이지 않다고 반박하니, 과학을 예시로 반박하면 안될것이다.

그렇게 되면 새상이 과학적으로 이루어졌다는 가정으로 수학을 증명하고 다시 과학을 증명하는 순환 논증에 빠질것이고, 이러한 방식으로, 새상이 과학으로 이루어졌다는 전제로, 과학의 탐구 방식이나 수학을 합리화 하는 즉시, 그것은 수학에서 금한 자기참조를 범하는것이다 (따라서, bootstraping같은 과정은, 자기참조를 범하는 합리화이므로, 연역논증이랑은 거리가 멀다 (inference to the best explanation라고 하는것도 이해가 안된다))

또한 과학은 수학을 수반하지 않아야 될 수도 있다.

만약 과학에서 수학을 쓸수 없다는게 증명됐다고 가정하자,

그러면 과학은 수학을 사용해야 한다는 가정이 깨지므로,

페러다임 시프트가 일어날 것이다.

과학이 수학을 사용해야한다는 가정은, 과학이 형식논리를 이용해야한다는 가정과 동등한 뜻이다.

그런데 과학이 형식논리를 이용해야한다는 가정은, 해당 과학이 일관된 형식적 논리로 서술될수 있다는 가정이므로, 해당 가정이 성립하기 위해서는, 논리를 사용하기 위한 규칙 (공리계, 언어, 표기 등)과 과학이 일관된 대상을 탐구해야한다는 가정을 가지게 되므로, 공리계를 사용할수 있다는 근거와 탐구하는 대상이 과학적이라는 근거가 있어야만, 연역적으로 뒷받침될수 있다.

## 2. 수라는 수학에서 추상적 보존 개념 (conservation)의 핵심적인 부분이 왜 형식적 논리인 수학으로 작성되어야 하는가

---

---

### 두번째 글 : 논리적으로 다룬다 전재할때, 대수식은 논리적으로 그 뜻이 해석 • 계산된다.

그렇지 아니하면, 논리적 해석 흐름에서 논리기호가 도출될수가 없다.

식의 계산은 그 값의 배정인 (x̄, f(x̄))와 같이 이루어지는데, 이 방식을 거부하는것은, 논리를 쓰지 않겠다는 말과 같다. (장자 왈 갓나서 죽은 아기보다 오래 산 사람은 없으니 팽조(760살이 넘게 살았다는 전설 상의 신선)도 일찍 요절한 사람)

#### 다음 과정을 위해 이항을 먼저 증명하겠음

함수는 (다가함수 고려하지 않음)

> 정의역의 x에 대해, \`∀x ∃!f(x)\`이다

먼저, y랑 z을 정의하자.
- y = f(x)
- z = f(k)

[*작성중*]

#### 대수식의 논리적 해석 흐름에서 논리기호를 도출하자

먼저, 다음을 보이겠다

> 함자 \`f :≜ (-F)\` 를 정의해서, 여기에 대해,

\`x = y 이면이 f(x) = f(y)\`

이말은, 진리값 T, F를 다루는 식에서, F = 0으로 가정하고 푸는거나, F ≠ 0이 아닐때 푸는거나, 전부 x = y인 등식을 쓸때 f(x) = f(y)가 F와 무관히 동등함이 당연함으로, F = 0인 경우로 잠정적으로 취급하겠음

##### 대수식의 논리적 해석 흐름중 논리적 귀결관계의 도출

Step.1. 방정식을 만족하는 집합으로써의 모델집합이 해집합임을 보이자

먼저, 다음과 같은 다항식 함수 P를 정의하자.

> \`P :≜ λA. λx. Πᵢ x - Aᵢ\`

그리고 다음과 같은 방정식화 논리함수 Φ를 정의하자.

> \`Φ :≜ λf. (f(x) = 0)\`

그리고 마지막으로, 다항 방정식 ㅍ을 정의하겠다.

> \`ㅍ :≜ φ • P\`

그러면,

> \`Mod(ㅍ(A)) = {x | x ⊨ (Πᵢ x - Aᵢ = 0)} = {x̄ | Πᵢ x̄ - Aᵢ = 0} = {Aᵢ | ∀i}\`

임이 당연하다.

---

Step.2. 논리적 귀결관계의 도출

다항방정식 ㅍ(A), ㅍ(B)에 대해,

0. Mod(ㅍ(A)) ⊆ Mod(ㅍ(B))
1. {Aᵢ | ∀i} ⊆ {Bᵢ | ∀i}
2. ∀i Aᵢ = Bᵢ《주의 : 비약이다, 저건 배열을 정렬해야만 성립한다.》
3. ∃C P(B) = P(A)P(C)
4. P(A)|P(B)

으로,

>
> 다항식 f, g에 대해 다항방정식 Φ(f) ⊨ Φ(g)
>
> 이면이
>
> f | g
>


##### 대수식의 논리적 해석 흐름중 진리값 배정되는 명제논리 결합자의 도출

¬x = T - x로 해석됨을 보이자. (경고 : 형식증명 아님)
A. proof of \`x ≠ T ⊢ T ± x ≠ (1 ± 1)T\`
0. \`x ≠ T\` (비 귀류법식 전제 문장)
1. \`T ± x ≠ T ± T\` (이항 by 함자 \`(T ±)\`)
2. \`T ± x ≠ T ± T = (1 ± 1)T\` (1번의 연장선에서 계산)
3. \`T ± x ≠ (1 ± 1)T\` (2번에서 식 요약) ⋯ ■

B. proof of \`⊭ (1 + 1)T = 0 ∨ (1 + 1)T = T\`
0. 먼저 part A by \`⊭ (1 + 1)T = 0\`와 part B bt \`⊭ (1 + 1)T = T\`로 나눠서 생각하자.
1.A. (1 + 1)T = 0 (귀류법식 전재 문장)
2.A. (1 + 1)T = 2T = 0 (1.A.번의 연장선에서 계산)
3.A. T = 0 ⊨ 2.A. ⊨ (1 + 1)T = 0 (연역)
4.A. ⊭ T = 0 ⊨ 2.A. ⊨ (1 + 1)T = 0 (연역)
5.A. ⊭ (1 + 1)T = 0 (연역) ⋯ ⊥
6.A. ∴ ⊭ (1 + 1)T = 0 (연역) ⋯ ■
1.B. (1 + 1)T = T (귀류법식 전재 문장)
2.B. (1 + 1)T = 2T = T (1.B.번의 연장선에서 계산)
3.B. T = 0 ⊨ 2.A. ⊨ (1 + 1)T = T (연역)
4.B. ⊭ T = 0 ⊨ 2.A. ⊨ (1 + 1)T = T (연역)
5.B. ⊭ (1 + 1)T = T (연역) ⋯ ⊥
6.B. ∴ ⊭ (1 + 1)T = T (연역) ⋯ ■

C.1. A, B ⊨ (x ≠ T ⊢ T - x ≠ (1 - 1)T) (A, B번에서 귀결)
C.2. A, B ⊨ (x ≠ T ⊢ T - x ≠ (1 - 1)T = 0T = 0) (C.1.번의 연장선에서 계산)
C.3. A, B ⊨ (x ≠ T ⊢ T - x ≠ 0) (C.2.번에서 식 요약)
C.4. A, B ⊨ (T - x = 0 ⊨ x = T ⊨ x) (C.3.번에서 연역추론 : 대우) 《주의 : "x = T"의 의미를 "진리값 x가 참"관점으로 해석함.》
C.5. A, B ⊨ (T - x = 0 ⊨ x) (C.4.번에서 식 요약) 《주의 : 근거인 C.4.에서 "x = T"의 의미를 "진리값 x가 참"관점으로 해석함.》
C.6. C.5.번 내용 ⊢ ¬x = T - x (최종결론)《주의 : "x = T"의 의미를 "진리값 x가 참"관점으로 해석함.》
Q.E.D.

x ∧ y는 xy로 해석됨을 보이자.
T에대한 방정식 (T - x)(T - y) = 0의 해는
x = T ∨ y = T이다.
따라서, x = T ∨ y = T ⊨ T - (T - x)(T - y) = T고,
x ∨ y = T - (T - x)(T - y)로 해석된다.

이때 De Morgan's Law, ¬(¬x ∨ ¬y) = x ∧ y서

T - T + (T - T + x)(T - T + y)
= xy이다.
⋯ Done.

##### 방정식의 의미 : 술어논리(함수논리)의 술어로써, 잠정적으로 특칭양화사를 사용해, 잠재적으로 전칭양화사를 사용함.

방정식 P(x) = 0이 불능이란것은

∄P(x) = 0란 뜻이며

∀P(x) ≠ 0이란 뜻이고 ⋯ ①



방정식 P(x) = 0가 불능이 아니라면

∃P(x) = 0이다. ⋯ ②



방정식 P(x) = 0이 부정이란것은,

부정방정식이므로,

∀P(x) = 0이다. ⋯ ③



①에서, 불능형 방정식 P(x) = 0에 대해,

P(x) ≠ 0은 부정형이고, ⋯ ④



부정형 방정식 P(x) = 0에 대해,

P(x) ≠ 0은 불능형이다 ⋯ ⑤


그렇다면 ③에 따라 다음을 정의하자,

> \`Φ :≜ λf. (∃f(x) = 0)\`
>
> \`P :≜ λf. (∃f(x) ≠ 0)

그러면 다음을 알수 있다.

④에 따라, Φ(f)가 거짓 이면이 P(f)는 부정형
⑤에 따라, Φ(f)가 부정형 이면이 P(f)는 거짓

Φ(f)가 참 이면이, f(x) = 0를 만족시키는 x존재
P(f)가 참 이면이, f(x) = 0을 불만족시키는 x존재

부정형 방정식을 만들고 싶다? 하면

¬Φ(f) = P(f), Φ(x) = ¬P(f)에서,

불능형 방정식 Φ(f)에 대해 부정하거나,
불능형 방정식 P(f)에 대해 부정하면된다.

술어 P에 대해
Mod(P) = ∅ 이면이 ∄P(x) 이면이 ⊭ P
이면이
Mod(¬P) = U 이면이 ∀¬P(x) 이면이 ⊨ ¬P

따라서, 방정식은 기본적으로 특칭 술어로써, 사용할수 있음

---

---

따라서, 수학에서 말하는 "추상적 보존 개념 (conservation)의 핵심으로써의 수"는 수학 없이 독자적으로 성립할수 없다. (단. 언어에서 수사같은 거나 숫자같은거는 수학적으로 해석하는것이 아니기에 본인은 수로 취급하지 않았다. 언어에서는 수에 의외성을 가지고 해석할수 있기에, **실제로 일관되지 않는다**; 시에서 갑자기 하나가 두개가 될수 있다.)

## 결론

따라서, 픽토그램으로 우리가 새상을 받아들인다 쳐도, 픽토그램 새상에서도 수, 수학, 보존개념은 요구되지 않으며, 해당 개념들은 언어를 통한 부가적인 개념일 뿐이지, 비물질적 실체가 아니다.
\`\`\`
이 글은 틀렸다.

해당 픽토그램을 해석함에 있어서, 우리는 기저에 깔린 지식을 이용하여 그 갯수를 알수 있다.

선험적이거나 경험적이거나 언어적이거나 본능적인것 아니냐는 질문에 틀렸다고 반박했다고 볼수 없는 글이다.

## Step 1. 생각의 선행

생각은 내용을 가진다, 여기서 생각은 그냥 직설적인 생각이며, 내용은 상자안의 내용물 같지만 추상적이라 설명할수 없다. 나는 그 내용이 글이라고 한적이 없다. 내용은 내용이며 그 내용이 무엇인지 우리는 말할수 없다.

생각의 다음 생각에 대해서도 단정하면 안된다. 생각의 다음 생각이 어떻게 되는건지 우린 모른다.

그러나 우리는 생각하려한다, 스스로 정신적인 방법으로 식물인간이 되고자 하지 않는다, 물론 의식적으로 "나는 정신적인 방법으로 식물인간이 될거야"라고 생각한다면 생각이다.

인간이 고등하다는 말에 속뜻, 그 생각을 버리자.

말의 속뜻중 의심되는건 일단 다 버리고 들어보라.

생각 다음 생각을 정해보는것, 생각을 전파하는것, 생각을 당연한 생각 다음 생각 방식으로, 나의 기본적인 능력으로 이해하는것, 그리고 외부에서 기인한 일로 생각이 추가되는것. 이러한 것을, "개척"/"전파"/"이용"/"추가"라고 하며, 우리 생각이 이러한 특성을 가진다는것이 공리이다.

여기에서 추가는 유일하게 능동적으로 하는게 불가능하다. (요청하는것도 수동적으로 받아들이게 해달라는거니)

그리고 전파는 생각을 공유하는거다. 전파를 받는거는 모른다.

그러나 이용하는것은, 당연한 생각 다음 생각을 이용한다. 이러한 당연한 생각 다음 생각으로 능력을 말위하는걸 잠재 능력이라 하여, 재능이라 한다.

우리는 대부분, 언어에 대한 재능으로 언어를 습득할 능력을 가지고 있고, 크기를 습득할 능력을 가지고 있다.

이것들은 재능인 경우가 대부분이지만 특수한 경우를 보자면 아니다.

언어와 크기는 습득하니까, 생각이다.

언어와 크기가 전파되었으니 말이다.




사실 크기같은 경우에는 전파해준 사람 없이도 사물에서 기인하여 나오기도 한다.

어떻게 된지는 몰라도 이미 존재한거고, 우리는 그것우로 생각하며 우리는 그것에 대한 관점화된 틀을 벗을수 없는 부분이 있다.




이러한 벗을수 없는 "단단한 틀"이 있다. (예시 : 윤석열 하면 계엄이 떠오른다... 농담ㅋㅋ 이런건 예시로 적절치 않군 ㅋㅋ)




이러한 개념들이 이용을 통해서 추가되는경우가 매우 많다.

특히 살아남기 위해 필요하면 더더욱.
우리는 생각하려는 의지를 가지며, 언어와 크기는 그것의 대표격이다.

그러한 능력이 선천적인 필수 루트가 아닌 이유는, 그렇지 않은 예외경우가 존재하기 때문이다.


내가 본 대부분은 언어습득능력이나 크기습득능력을 생습적 재능으로 가진다.

그러나, 이러한것은 생각흐름을 탁! 바꿀수 있거나 그 생각흐름을 주는 경우들이 많으며,

이러한 "기저에 깔린" 생각들은 생각이지 인간의 필수 능력이 아니다.

생각이 선행한다.

## Step 2. 크기 개념

크기 개념을 생각하는것은 대부분 된다.
생각하지 못했다 해서 난산증을 차별할 근거가 되지 않는다는것도 당연하다.



정량화된 크기 개념이 수(數)이며, 수학 언어는 수를 다루는 언어이다.

그런데, 수학 언어는 형식 언어로 설명된다.

따라서, 크기 개념이나 수학을 다룸에 있어서, 크기나 수학에 기초한 서술을 접근할수 없는 사람이 있음은 매우 당연하다.



언어 혹은 수(數)나 수학적 서술이나 크기 개념은 우리가 생각할수 있도록 익혀진 상태일때야 사용 가능한 것이지, 재능이 아닌 이상 생습적이지 않다.



한 문장으로 정리하겠다.



다른 관점 말고, 생각하는 관점에 있어서,
언어나 수, 수학적 서술과 크기는, 우리가 생각하는 것에 있어서 생각이며, 재능으로 타고나지 않으면 본능이 아니다.



이걸 얼마나 더 쉽게 설명해야 할지 모르겠다.



재능이라거나 이런말보다는 생존을 위한 (사자들에게도 크기 개념은 있음) 생각, 사념체일 뿐.

이상.

# 의외성 정리

## 용어 정의

- True Mean (참뜻) : 의외성(속뜻)
- Shell Mean (껍대기 뜻; 쉘 민) : 겉뜻
- 속뜻 없음 (Exceptless) : Shell Mean = True Mean
- 초완전성 (Hyper-Completeness) : "This sentence is False"를 허용하는것.
- Black and White Proposol : ⊢ (¬Hyper-Completeness)
- Simply Mean Proposol : ⊢ Exceptless
- 단순언어 : Simply Mean Proposol이 항진인 언어

### 흑백논리와 형식언어의 정체에 대한 고찰

Black and White Proposol를 공리로 하는 논리를 흑백논리라고 부를수 있음이 당연하다

또한 흑백논리중 단순언어인것이 형식언어인것이라도 보면 된다.

#### 정리 문단에 따른 보조설명

우리 언어는 보이는대로 해석해야하는것과 아닌것이 있어,

보이는대로 해석해야하는것을 단순언어 (이 경우 언어 해석에 예외가 없이 보이는대로 닥치고 그뜻이다)

그리고 단순 언어가 아닌 언어 (이 경우, 언어 해석에 여러 의외성이 끼어들기에, 단순히 보이는 뜻을 뜻으로 단정할수 없다)가 있다

또한 논리는 장자철학처럼 "갓나서 죽은 아기보다 오래 산 사람은 없으니 팽조(760살이 넘게 살았다는 전설 상의 신선)도 일찍 요절한 사람이다"가 맞을수 도 있지만,

흑백논리에서는, Black and White Proposol을 참으로 하여, x이면서 동시에 x가 아닌것은 불가능하다. (Fun Fact : 흑백논리이면 단순언어임이 논리적 귀결이다)

## 공리

1. 말의 뜻은 True Mean과 Shell Mean이 있다

## 정리

### TrueMean Theroem

Hyper-Completeness 일때도 "말의 뜻 ≠ True Mean"마저 True Mean으로 True Mean(결국 전제로 한 참인 문장에서 연역(이때는 초완전땜에 가능)으로 "말의 뜻 = True Mean")이고 (Hyper-TrueMean Lemma)

Hyper-Completeness 가 아닐때도, "말의 뜻 = True Mean"이므로, 말의 뜻 = True Mean으로 (Formal-TrueMean Lemma)

말의 뜻은 True Mean을 말한다. (TrueMean Theroem)

A. Formal-TrueMean Lemma
- ¬Hyper-Completeness, ⊭ 말의 뜻 ≠ True Mean ⊢ 말의 뜻 = True Mean

B. Hyper-TrueMean Lemma
- Hyper-Completeness, 말의 뜻 ≠ True Mean ⊢ 말의 뜻 = True Mean

C. TrueMean Theroem
- 말의 뜻 = True Mean

Proof)

1. 말의 뜻 ≠ True Mean [Hyp]
2. Hyper-Completeness [Hyp]
3. "말의 뜻 ≠ True Mean"라는 점도 True Mean임
[Paradoxic Lemma]
3. "말의 뜻 ≠ True Mean"라는 점도 True Mean이고 참이기에, 말의 뜻 = True Mean임
4. 말의 뜻 = True Mean

이하에서,

말의 뜻 ≠ True Mean, Hyper-Completeness ⊢ 말의 뜻 = True Mean ⋯ (1)

1. 말의 뜻 ≠ True Mean [Hyp]
2. ¬Hyper-Completeness [Hyp]
3. "말의 뜻 ≠ True Mean"라는 점도 True Mean임 [Paradoxic Lemma]
4. 모순

이하에서, ⊭ 말의 뜻 ≠ True Mean ⊢ 말의 뜻 = True Mean

(1), (2) ⊢ 말의 뜻 = True Mean

Q.E.D.

#### 해설

항상 True Mean만 말의 뜻임을 증명하자,

True Mean이 뜻이 아닌 말이 있다고 가정하자,
그렇다면 그 말은 True Mean이 뜻이 아니라는 뜻이 True Mean이 된다

이것이 Paradoxic Lemma다

이하에서 Hyper-Completeness에 따라 참인 경우와 거짓인 경우로 나누어 논증하자.



상황 1. Paradoxic Lemma에서, Hyper-Completeness인 상황

Paradoxic Lemma가 참이될수 있으므로, Hyper-TrueMean Lemma가 참이다

상황 1 종료



상황 2. Paradoxic Lemma에서, 비 Hyper-Completeness인 상황

Paradoxic Lemma이 모순이므로, 전재인 "말의 뜻 ≠ True Mean"이 거짓이다.

따라서, Formal-TrueMean Lemma가 참이다

상황 2 종료



이하에서,

상황 1, 상황2에 따라, 연역,
항상 True Mean이 말의 뜻이 된다.

따라서, TrueMean Theroem이 참이다

Q.E.D.

### Exceptless Thorem

Exceptless ⊢ 말의 뜻 = Shell Mean

Proof)

1. Exceptless [Hyp]
2. 말의 뜻 = True Mean [TrueMean Theroem]
3. Shell Mean = True Mean
4. 말의 뜻 = Shell Mean [결론]

이하에서, \`Exceptless ⊢ 말의 뜻 = Shell Mean\`임이 당연하다.

#### 해설

앞서 증명한 TrueMean Theroem에 따라,

말의 뜻 = True Mean

Shell Mean = True Mean 이면, 그리고 이때만 Shell Mean = True Mean이다

(쉽게말해 A = B = C니 A = C)
\`\`\`\`

## [앙데_대수_해명](https://faraway6834.github.io/unbeauty/privateNote/Alkali/Forbidden/%EC%95%99%EB%8D%B0_%EB%8C%80%EC%88%98_%ED%95%B4%EB%AA%85)
\`\`\`text/plain
앙대-대수의 절대 게임은, 곧이어 말할 수리논리학-언어 L의 모델의 구성에 쓰일수 있다.

왜 그런가? 의미론적으로 연산자를 구성함이, 본질이 아닌 응용 (인터페이스의 구현) 으로 구성될수 있는 언어적-특징을 가지기 때문이다.

의외성 정리를 참고하면 언어 L은 "단순언어"이고 그 본질은 자유에 있다는 칸토어의 말에 따라서, 튜링 머신인 "자바 가상머신"에서 인터페이스를 구현하는 코딩을 하듯, 그 같음의 연속을, 모델을 이용한 구성에 쓰는, 즉 본질애서 빙빙돌아, 겉가지로 구성하는것이 충분히 가능하단거디. 예컨데, "There should be one-- and preferably only one --obvious way to do it."라는 말은 맞다고 본다. 본질적으로 서술할방법이 대개는 있다. TMTOWTDI(There's more than one way to do it.)도 명백히 참인 경우가 많다, 그래서 겉가지로 구성하는것이 충분히 가능하단거다, 단지, 본질로써 구성함에는 적절하지 않을지 몰라도 말이다.

함의는 증명이랑도 어느 위계에서 같아질 수 있다.

따라서 meta-language보다는 그 자체로 메타적 구조처럼 평가할수 있게 평가되는 구조인 hyper-language형태가 나을것임이 분명하다.

따라서, 앙데-대수의 절대-개임은 이러한 함의의 특성으로 전건긍정•후건부정•삼단논법을 가지고, 충분히 논리학을 구성할수 있는 언어임을 보인다.

따라서 우리의 증명에 몰입해 그 언어로 쓰는사유의 여럿 기능적측면-속성이나 특징적 부분 등등이 그 근본을 따라 정리됨이 논리를 이루기에, 가장 기계적이고 단순하고, 수학자나 전산학자마냥 효율에 미친것같은 구성이지만, 순수히 생각의 연속으로 구성되는점과, 위에서 보아 한계를 넘으려는 점은, 우리 정신에 맞으므로, 그러한 방법으로 접근해좋으면 감사하겠다.

우리 정신의 연속만으로 논리를 구성한다는건, 인간의 본질적 사고와는 동떨어졌지만, 수학적으로는 최소한의 도구만 유클리드처럼 써서 사고(언어)-게임을 하는거니,

내 수학을 좋아하는 점이 참 미안하다. 나는 이 방식을 쓰겠다.

자, 이제 바로 본론으로 들어가, L = {¬, ∧, ∨, ↔, ⊕, →} 로 언어를 잡자.

먼저 정의를 하자.
DEF 1. p ↔ q = (p → q) ∧ (q → p)
DEF 2. p ⊕ q = (p ∨ q) ∧ ¬(p ∧ q)
DEF 3. p ∨ q = ¬(¬p ∧ ¬q)

테클 걸지 말자는 의도에서 하는말인데,
O와 X만이 유일한 평가이므로, DEF 3이 성립하는거지 아니면 그렇지 않다는건 미뤄둬라. (참고 : LAFTF 1.1 및 Alkalic의 대수식 내의 논리적 흐름)

DEF 2는 p와 q가 동시에 만족되는 경우 (즉, 진리집합을 Venn-Diagram으로 그릴때, p ∧ q의 영역)는 제외한다. 선택지같은 역할의 "또는"의 기능을 한다. 이것은 단순히 해당 구문의 기능적 측면에서의 속뜻 (차집합으로 구성되어 동작) 이며, 본질에 무관히 타당한 해석이다. 고로, 항상 딸려 참이되는 해석으로 필연적이므로, 속뜻 해석이 자유로운 (=속뜻이 안정해진) 언어 (예 : 수학의 본질은 자유에 있다) 본질이 기능을 함의한다.

DEF 1의 양방향 함의는 논리적 동등성이기도 하다. p → p는 이 수학 언어 게임에서, 절대적으로, 공리로 인한 무조건, 동등성이 함의하는 진리다. 잠시 환기해보자, 논리식을 흡사 계산하듯 다룬다는것은, 흡사 수리논리 언어의 명제의 (의미적으로) 자당히 (팁 : 추론에 떠르는 연결된 속성이므로 자당하다) 동등한 (즉 같은), 다양한 구문-형태의 존재이다. 수리논리 언어의 다양한 뜻의 존재는 그 진리치의 따짐이 항성 같은 겉뜻(속뜻과 겉뜻이 일치하니...)을 의미한다. 따라서 p와 q가 같은 속-겉(속뜻이자 겉뜻)뜻으로 보여, 예컨데 그 보임은 p와 q가 어떤 진리연산이 쓰일 명제 k일테니까, 아무튼, p → q이며 q → p일것임도 당연한 "논리적 귀결"이다. 그렇지만, p → q만 놓고 보자하니, 전건부정을 하였을따 오류가 나지 않아보인다, 왜냐하면 q → p라는 변인이 특수한 경우(특수한 진리값 배정)에서 후건부정으로 동작하기 때문이다. 고로, 전건 부정에 대하여서, 두가지를 AND(논리곱)-로 나열하여 p → q이며 q → p임을 따지는것이 즉, p = q에서 k = p = q임이 p → q이며 q → p임을 만족하는데, 이가 당연히 모든 함의에 대한 성질로써 함의하니 귀결이며, 이때 p → q이며 q → p이라는것은 p → q ∧ q → p = (¬ p ∨ q) ∧ (¬ q ∨ p) =(잔계산 생략)= p ↔ q 이니, 당연히, 그 뜻을 p → q ∧ q → p로 놓고 보아도 됨이 진실로 타당하다. 그 뜻이 같으니 해석도 결국 같음은, 우리가 이런식으로 조금만 (그러나 큼지막한 달에 닿은 발걸음만큼일수도 있는) 나아가면, 수학 언엇-말이 진실로 타당하게 같은 것임을 보이지 않는가?

우리가 조금만 추론을 하면 기존 규칙인 전건긍정 • 후건부정도, 이 수리논리라는 언어가 만족되기 위한 성질 명세(본질)에 따라, 유도되어야만 하는거다.

따라서, 그것들도 우리가 선택한, 생각들의 연결로써, 티탄같은 골격을 그린것이다.

그렇다면 이제, (함의의 내부 의미를 이용하여 귀결로 그 뜻이 응용됨을 이용하여) 모델을 구성하는 측면에서 다음은 타당함으로, 이용해도 좋다.

p → X 가 후건 부정이니 전건인 p를 부정하여 참이되는 추론이니, 저 명제는 참이므로, 즉, 저 술어가 만족됨은, p를 부정한다는것, 즉, 이는 부정연산이 된다.

*초심 잃어서 나중에 다시 쓸 문단이다*

함의문은 전건긍정과 후건부전이라는 규칙을 가진다. 그렇다면, 앞인자를 긍정할때와, 뒷인자를 부정할때 말고, 앞인자 긍정, 뒷인자 긍정의 경우에, 특별한 성질을 가진다. 즉, p → ¬q인 논리식에서, p가 긍정되면 q는 부정되야하며, q가 긍정되면 p는 부정되야한다, 달리말해, 그 두가지가 다 긍정이 되는것은 규칙에 어긋난다. 이때 다시, 앞인자를 부정하는 경우와, 뒷인자를 부정하는 경우의 논리식을 만들어보면, ¬p → q인데, 이는 p를 부정하면 q가 긍정해야하고, q를 부정하먼 p가 긍정되야 한다. 마찬가지로, p와 q가 동시에 부정될 수 어없다. 이때, p → ¬q와 ¬p → q에서 각각, p와 q에 대해 각각 부정-부정, 긍정-긍정의 경우가 같다, 즉, 달리말해, 이런경우, ¬(p → ¬q) = ¬p → q인것이다. 의미상 이는 각각 부정논리곱문, 논리합문이 되는데, 이는 전건을 부정함이 후건을 부정함으로 이어지는지가 타당하자 아니하여, 전건을 부정함이 후건을 긍정할때, 타당하지 아니하다 말할수 없으니, 전건부정, 후건긍정이 서로 배타적이지 않다는것이다, 틀린 전제로 옳은 증명을 이끌수 있음은, 충분히 보일수 있으니 연습하여 이해하는것이 중요하다. 음... p → ¬q일때 p와 q의 긍정이 베타적인데, 부정은 베타적이지 아니하며, 이는 p → ¬q가 부정논리곱으로 구성되어도 함의문의 만족을 이룰수 있음을 의미하게 될것이다. 즉 타당한 모델이며, 사실은 동일 맥락에서 ¬p → q가 논리합문으로 구성될수 있음인데, 이는 전제의 진리값을 부정하여 판단하므로, 긍정 부정 규칙의 이름이 정 반대여야 할것이며, 서로를 배타하고 교환된다. 이는 논리합문으로의 구성과 완전히 같은 뜻을 가지기에 필연적으로 귀결되지만, 현제 표현력이 딸려 포기하고, 나중에 재작성한다.

마지막으로, 함의문의 이산적 성질만을 분석해보자.

지금부터는, 논리식을 늘어놓을때, 당연히 그 전제가 참이라 가정하는, 즉, 메타수준의 함의와 동등한 증명•귀결(혹은 만족)기호를 이용하기에, 논리곱 대신에 콤마가 쓰인다. (에초에 형식증명의 경우, 각 라인 (튜플 인덱스)의 명제가 참이여야 하고 (건전과 유관하긴 함), 귀결(혹은 만족의 경우 모델을 배정하는 명제로 족하다.)기호같은 경우, (완전하며 건전할때 특히) 집합안의, 즉 순서없이 명제들이 나열될때는, 즉 해당 집합이 의미하는 바는, 내부 명제가 다 만족되는것을 의미하는데 (Venn-Diagram으로 그려보라.) 이는 전제가 나열되었기에, 의미상 나열된 임의의 원소에 대하여도 함의가 성립하여야 하기에, 당연하다. 즉, 나는 이 문단부터는 초심을 잃어서, 수학적으로 접근했다.

x → y서 전건긍정 O -> p ⊢ p = O, 후건부정 p -> X ⊢ p = X 은 다음을 함의한다. (p -> X ⊢ p = X), (O -> p ⊢ p = O) ⊢ (O → X = X)
즉, 전건이 긍정되었는데 후건을 부정하면 전건긍정의 부정이기에 타당한 추론규칙의 명제형의 부정은 거짓이므로,인 거짓이고, 후건이 부정되었는데, 전건을 긍정하면 후건부정의 부정이기에, 타당한 추론규칙의 명제형의 부정으로 거짓이다.

전건부정은 오류다, 하지만 타당한 추론 규칙이란 말의 뜻은 항진이여야 함을 가정하고 있으므로, 전건부정이 거짓이 되는 경우로 엄밀히 가정함을 미리 선언한다, 함의문으로 생각해보면 O → X가 있을수 없는 경우니, 확실히 불가능한 경우중 한 분기로, X → p와 p = X를 다음과 같이 평가하고 계산할수 있다. (X → p ⊢ p = X) = X ⊢ ((X → p) = O, (p = X) = X) (= X → p, p = O) 따라서, 함의문은 O → X만 불가능하다.
\`\`\`
`;
  
  const mdText3 = `
# 어떤 언어에서 존재론적 언질의 응용가능성은 비결정성 추상의 활용가능성을 불러일으킨다.

조어 "비결정성 추상어"란 비결정성 추상의 활용 가능성을 가지는 언어인데, 예컨데 수학이나 그것보다 높은 자연어는 비결정성 추상어다.

"먹는 것"이 음식이므로, "먹다" 알고리즘과, "A 인지 판단하다" 알고리즘에서, "먹는것 인가요?"라는 말은 "먹다"에 대한 존재론적 언질이 되는 대상을 언급하며,
단어활용능력(조어력과 서술력이 창발적이라 충분히(=보편적인 언어와 「상호서술가능」한 언어 『주석임, 참고 : A』) 언어를 서술할수 있는 능력을 일컽는 내가 만든 조어)을 가짐을 알 수 있다.

참고로 말하겠다.
1. 비결정성 추상어는 추상의 활용 가능성을 가지는 언어라고 정의했다.
2. 비결정성 추상의 활용 가능성 만족의 필요충분조건은 단어활용능력의 만족이다.
3. 따라서 비결정성 추상의 활용 가능성의 만족에 대해서도 이미 잘 정의되었으니 이쯤에서 비결정성 추상어를 이해하지 못할리는 없다고 생각한다. (왜냐하면 이미 참고로 말하기 전에 힌트를 다 줬고 그걸 또 설명했기에 못알아듣으면 참사다 진짜로.)

따라서, 서로를 구성하는 구성능력(이것도 조어)관계가 양방향 구성능력이 될때, 상호서술가능(이것도 조어, 『참고 A』)관계가 되어, 같은 서술능력 위계에 있으므로,

비결정성 추상어는 단어활용능력에 따라 창발적인 단어생성및 활용이 가능해서, 모든 언어를 근사하는 근사-번역(이것도 조어다. 예를들어 "야바비자"가 "암니차르"를 의미하는지 "하나차르"를 의미라는지 "하나바시"를 의미하는지 모를때, 대충 "암니차르"로 번역하면 되고 이가 근사-번역이다. 예를들어 한자에서 "필멸"이라는 단어의 뜻은 mortar이며, 불멸이 immortar에 대비되는 영단어 번역용 조어가 필멸이기에, 이런식으로 대충 번역하는 근사-번역이 비결정성 추상어에서 단어활용능력에 기인한다.)을 하기에, 보편적인 언어의 위계가 된다.

## 철학어나 양상논리어 : 논할수 없는것을 논할수 있을때

논할수 없는것에 대해서도 말할수 있다는 철학을 가진 언어는, 논할수 없는것에 대해서 논할수 있을것이다.

왜냐하면 그게 그 언어에서 논리적인 참이기 때문이다.

그러나, 외부 시선(e.g. 비트겐슈타인의 논리-철학 논고에 쓰인 독일어 + 수리논리언어 조합에서의 설명)에서 보면 그저 헛소리일 뿐이다.

이 부분에 대해서는 나중에 파보자.

## 말 만들기 놀이와 완전파생언어

필자는 어릴때 언어 만들기 놀이를 한 바 있다.

나는 그러한 언어를 만들기 위해 암호처럼 만드는걸 지향했다.

허나 "먹는 것"이나 "음식" 같은 단어를 "레다크"나 "food"로 명명해도 되지 않는가?

나는 그걸 또래 친구들을 보고 알았다.

그러나 해당 언어는 쓸모가 없었다. (필자 주 : 쓸모없는 이유는 단어활용능력을 만족하기 않기 때문이다)

어찠든 명사랑 동사를 변환하더라도, 조어력과 서술력이 있다고 취급되는 창발적일 기준을 만족하지 않는다면, 그것은 비결정성 추상어가 아니다.

따라서, 단어사전처럼 명명하고 번역하는 언어를 상상해봐도 좋을것이다.

그건 완전번역가능한 언어로 완전번역가능어(이것도 조어)일테니까 말이다.

참고로, 나는 비결정성 추상어가 아닌 언어를 찾은적이 없다.
자연어 능력 이상이여야 하기 때문이다.

비결정성 추상어에서 조건이 추가되거나 삭제되면 비결정성 추상어는 아닐거다.

그러나 비결정성 추상어로 구상 가능한 언어의 범위는 보편적인 모든 사고이자 언어이기에 (단. 이 말에는 경험이 개입된단 한계가 있다. 지금까지 모든 언어가 서술능력이 언어면 언어로 배웠던 경험의 한계가 있기에 그것보다 서술능력이 높은 언어나 나오면 반박된다.) 더 큰 언어를 찾을수 없으리라 오늘 내 17년 6개월 인생의 경험의 방대함 걸고 장담한다.

뭐 사실 그 경험에 대한 방대함이 당연히 적으니 잃을것도 없다 ㅋㅋㅋㅋ 히히.

튜링 언어같은 결정성 구체어의 경우에 비결정성 추상어에서 조건이 빠졌으므로, 결정성 추상어가 아니다.
근데 비결정성 구체어라는 종류도 생각해볼 수 있는데 이는 예를들어서 객체에 대해서 정의할수 없는 도달 불가능 기수를 제외한 ZFC가 그 예시이다.

단어의 정의성이 강하면 왼만하면 정의되지만, 비결정성 구체어라는 언어는 보통 수학같은 이분논리를 가진 경우가 많아서 꽤 도전적일거다 ㅋㅋ 상수기호를 만드는게 나을거다.

구체어라고 한 이유는 정의된 대상만 씀을 가정했기에 그렇다.

결정성 추상어를 가정한다면 결정된 순간 수학적으로 모델링해버리면 구체적인 분석이 되는 이산논리적인 속성이 생긴다. 결정성을 가지면 그것이 이분법적 논리성을 창출한다.

예를들어 정언논리같은 경우 충분히 술어논리로 모델링할수 있지 않는가?

길이에 대해 의심해봤다면 알겠지만 그런 보존 개념이나 딱딱 떨어지는 이분성은 필연이 아니고 굳이 지키지 않아도 된다.

결정성 추상어는 그 본질이 아닌 부분에서 수학으로 서술 가능하고, 그것에 대한 부가설명으로 논리를 쓰면 된다.

길이에 대한 명명으로 설정히는 경우를 가정하자.

만약 정의가 절대적인 정의어만 가정해도 이분논리의 미친짓으로 이미 수학적 도구를 이용하여 그 단순성을 이용한 논법으로 설명하는것이다.

충분히 언어라는 대상을 보편적으로 생각할 땐 비결정성 추상어로 충분히 가능하다.

참고로 개빡치게 오해하는 사람이 있어서 정리하겠다.

사전으로써 충분히 많은 단어에 대해 번역 가능하여 그것으로 서술 가능한 언어를 번역할수 있으므로, 완전 번역이 가능해지면서 비결정성 추상어인 경우가 완전번역언어이다.

완전 번역언어는 비결정성 추상어를 만드는 가장 간단한 방법이다.

### 기본어휘언어

기본어휘언어는 준-완전번역가능어(완번번역가능어에 준하는 언어)이다. 기본어휘언어는, 고유한 언어를 기준으로 다른 모든 어휘를 설명한다.

로지반어가 대표적인 기존어휘언어이다.

따라서, 영영사전같이 로지반-로지반 사전을 만들면 기초어휘로 대부분은 쉽게 구성할 수 있다.

기초어휘 \`L*_basis\`에서 언어 \`L*\`를 구성할 수 있다는거다.

따라서 영한사전같이 로지반-영 사전을 만들면, 기초 어휘를 번역하는것 이외에는 로지반-로지반 사전에 대한 복사처럼 만들수 있음이 당연하다.

이것이 기본어휘언어의 환원적 성질이다.

기본 어휘 언어는 피결정성 추상어를 만드는 가장 효율적인 방법이면서 동시에 리스크가 크다.
구성적 방법으로 창조된 비결정성 추상어기 때문이다.

#### 완전번역가능 기본어휘언어 a.k.a. 완전파생언어

기본어휘언어이면서 완전번역가능언어인 언어이다.

이러한 언어는 필연적으로 그 orgin이라는 뿌리가 번역된 언어에 생겨버리게 된다.
완전번역가능 기본어휘언어는 솔찍히 창조라고 하기에도 너무 쉽다.

이게 가장 쉬운 비결정성 추상어의 창조 방법이라고 생각한다.

##### 기초어휘가 의성의태어인 완전파생언어를 : 표현기반완전파생어

완전파생언어는 기호를 만들거나 문법을 만들거나 어휘를 만들거나 하는것은 이미 수학에서 기호 만드는 실력, esolang 창작 실력, 언어핫 지식으로 거의 커버된다.

그러나 기초 어휘인 단어를 만드는데는 단어 발음을 만들기가 무지 어렵고 예술의 영역처럼 느껴진다.

그래서 쉽고 직관적인 방법으로 표현기반완전파생어를 제안한다.

표현기반완전파생어는 기초어휘가 의성의태어인 완전파생언어이다.

히나타 쇼요의 "슉~ 슈육 해서 퐛 했더니"이런 말이나 "엄... 유 엔 미 너 셈셈" 식으로 말하는 기안84같은 경우 "엄... 노 펜슬? 쓱쓱~ 쓱쓱"이라고 말할것이다.

가장 순수하고 직관적인, 픽토그램같은 발음이라고 생각한다.

나처럼 만드는데 부담되면 할만해보인다.

## 참고

용어정리)

비결정성 추상의 활용 가능성 : Φ(x)라는 속성에서 ∃x일때, 이에 근거하여 Φ를 서술하여 "먹다(x)" -> "먹는 것"이나 lojban어 "le Φ"같이 활용할 수 있는 술어에 대한 추상적인 속성에 대한 논의의 활용 가능성.
단어활용능력 : 보편적인 언어와 상호서술가능능력관계를 가질정도의 충분히 창발적인 조어력 및 서술능력
상호서술가능 : 언어 A에서 언어 B를 어떻게든 설명하는 말을 할수 있으면, A는 B를 서술가능하다 하고 A와 B는 서술가능관계이다. 그러나 이것이 단순 함의처럼 일방향인것이 아닌 양방향으로 변한다면, 즉, A는 B를 서술 가능하고 B가 A를 서술가능하면 A와 B는 상호서술가능하다고 한다.
완전번역가능어 (완전번역가능성을 가지는 언어와 완전번역가능이란) : 완전번역 가능성을 가지는 언어가 완전번역가능어고, 완전번역가능어가 완전번역가능성의 기준이다. 완전번역가능성이란, 사전을 통해 어떤 타 언어 L로 완전히 번역 가능한 L이 존재한다면 완전히 번역할수 있는것이고, (완전번역가능어, 즉 지금 번역한다는 주제의 언어는) 언어여야하므로, 비결정성 추상어 인것이다.
기본어휘언어 : 모든 단어 L*이 기본 어휘 L*_basis를 이용하여서 설명되고 정의된다면, (기본어휘언어, 즉 지금 논하는 초점이 되는 말의 언어는) 언어여애 하므로, 비결정성 추상어이다.
완전파생언어 : 완전번역가능 기본어휘언어로써 완전번역가능어면서 기본어휘언어이므로, 두 조건을 동시에 만족시키기에 수학적으로 자명하므로 더이상의 자세한 설명은 생략한다. 일 더하기 일 수준이다.
근사-번역 : 언어는 자기 자신에 대해 닫힌 말만으로 이루어질 수 없고 또한 언어는 자기 자신이 아닌 다른 언어에 대해서 완벽하게 번역 불가능한 번역 불가능성을 가진다. 따라서 이를 극복하기 위해 "가바가이"를 번역하듯 하는 번역을 근사-번역이라고 한다.
표현기반완전파생어 : 기초어휘가 의성의태어인 완전파생언어.

하... 생각해보니 완전번역가능어는 이름을 너무 지좆대로 지은것같다.
완전번역가능어는 이름이 존나 이상하게(비직관적으로) 지어져서 그렇지, 예를들어 basic english가 대표적인 완전번역가능어다. 사실 basic english는 기본어휘언어이기도 한다. 따라서 basic english는 완전번역가능어면서 기본어휘언어이기도 하여 완전파생언어이기에 뭐... 예를들어 한국어 암구로호 비결정성 추상어를 만들면 그게 완전번역가능어다.
이름이 참 어감을 지좆대로 해석하는 미친형태다.

이하에서는 1도 중요하지 않는 잡설 해설을 하겠다.

결정성 구체어 : 결정적인 구체적인 대상을 다루는 언어이고 튜링언어 이하의 위계의 언어를 말한다. 모든 해석은 결정적인 부분에서 구성 가능하며, 구체적인 알고리즘을 통해 이루어진다. 에초에 구체적인 알고리즘이라는것이 결정적인 방법인 최소한의 동작으로 작동하므로 α, β, γ 세가지를 가진 람다같은 튜링 완전 언어가 바로 이런 언어다.
비결정성 구체어 : 결정성 구체어와는 다르게 비결정적인 대상을 다룬다. 예를들어 범주론이 아닌, 범용적인 언어가 아닌 수학용 언어오써의 수학에서는 비결정적인 집합도 다룬다.
결정성 추상어 : 추상적인 대상에 대해 다루지만 결정성을 가지기에 추상을 서술하기 충분하지 않아 구체적인 추상으로 한정시켜버린다.

이런 잡설은 무시하라. 특히 비결정성 구체어와 결정성 추상어는 하등 쓸모없는 공상이니까 결정성 구체어 종류라는 부분으로 퉁쳐서 무시하거나.

잡설때문에 조어만들어서 미안하다. 왠지 내가 더 짜증나는 기분이다.

# 언어와 메커

여기서 부터는 응용철학 겸 오락용 실천이데올로기 급인 비결정성 추상어 이론과 완전파생언어 이론이 아닌 다른 글이다.

## 말하기 전에

언어의 되기적 특성으로 정명(성리학에서 정명)이 지켜지지 않는 동명(동명은 조어이며, 정명이 지켜지지 않고 계속 변하는 동적인 성질을 말한다.)을 가진다.

## 말해보자면

근데 이건 나중에 이어서 서술할꺼라서 오늘(2025.Aug.07)이후에 쓸꺼다

따라서 아직 작성중인거다....

라고 쓸려고 했는데 지금 찾아서 넣는다

### [메커론](https://faraway6834.github.io/unbeauty/privateNote/Alkali/Forbidden/%EB%A9%94%EC%BB%A4%EB%A1%A0)

\`\`\`\`markdown
메커론을 작성할때 상당히 제가 대단한줄 착각했던점 독자 여러분께 사과드립니다.

# 아래 내용은 아직 정리되지 않은 내 이론이며, 완성을 위해, 들뇌즈를 공부하고 싶다, 아직 들뇌즈의 소개밖에 못봐서 알지 못한다.

내 생각 :
\`\`\`
생각은 언어라고 노엄 촘스키가 말했다. 그러나 우리가 생각하는 생각은, 본질적으로 어떤 기제(메커니즘, 이하 메커)이다. 메커와 언어는 구분하는순간, 그 차이가 가려져서 차이가 안보인다, 그러나, 언어 이전에 메커가 언어로 되려고 존재하고, 메커는 언어로 되며, 언어는 메커를 촉진하고, 메커는 언어같은 사상과 생각을 반복한다, 즉, 언어는 완벽히 생습적이지 않고, 되기의 기능으로 어느정도 생습적이며, 나머지 보편적인 우리 신경의 되기 흐름 재능에 맞겨진다.

+ 언어 이전의 메커는, 논리•구조라는 언어를 동반하여 어떻게든 악착같이 가려지기 때문에, 역설적으로 우리는 그런 하등한 메커를 다룰 능력이 없는 고등생물놈들이다.... 바보지.

+ 언어 이전의 메커는 그 존재성을 논할수 없다는 소리다.
\`\`\`

우리의 사상은 윤리고, 새상의 본질은 메커며, 도구의 언어가 형식이다.
\`\`\`\`

# 발화의 배경 : 콰인에 대한 소신발언, 콰인의 이분법적 의견에 반대.

메커론 다음 내용은 내가 이 글을 쓴거에 대한 정리글이다.

\`\`\`markdown
# 수학적 합리의 탈을 쓴 멍청하고 순수하며 괴랄한 타당성 (콰인에 대한 소신발언, 콰인의 이분법적 의견에 반대.)

결론은... 양상논리는 괴랄하다..!!

생각해보자, "정의어"라는 개념으로, 대상을 사전처럼 말을 매핑해서 정의되는 언어로 그 언어의 철학과 그 논리가, 정의된 값은 논리를 낳는다는 입장이면?

실은 공리 A, B, C, D에 대하여, T = (T = A = B = C = D) 라는 스크립트 포멧을 만드는 언어의 논리로써, 그 언어의 논리를 선택하는 독선이다.

(x = T) = x 인것도 이산논리에서 기호 '='의 존재론적 언질로 추론가능하며, 공리 또한 포멧의 정의로 꼴통같이 구성하고, 이러한 이론 자체는 연역적이고 형이상학적인 닫힘을 만들면 꼴통이 되는데 어떻게 그딴것만 진리라고 하겠나

"결국은 뜻이 단순히 한 종류의 타입의 단일 객체로 해석되는 문장-평가값 쌍 뜻 언어에서, 속뜻이 겉뜻으로 이리 단순한 언어에서 하는 추론은 결국 자연연역같이 논리라는 합당한 추론방법사상으로 반복적 추론을 평가해서 이게 논리 위에서 옳다!"라고 허는 꼴임이 모든 논리 위에서 증명되는데 말이다.

논리적이므로 믿을만하므로 논리적이므로 하는 순환논법을 추론할만큼 객관적인 논리는 자신이 왜 믿을만한지 강제하지 못한다.

그러니 언어는 그 철학과 논리를 가지는데, 수학적 구성이 본질인지 의심스럽고, 모델론이 맞는지 종합적 진리가 맞는지는 순환이다.

이러한 불가지해보이는 흐름에서 각각의 명세에 대한 타당한 자연 연역에 관점에선, 짜증나는 논리도 타당하다.

내가 얼마나 짜증나고 타당한 논증을 많이썻는지!

콰인의 말은 설득력 있지만 망할 논리는 기반이 소용돌이치는 바수구마냥 더럽고 설득력이 약하다.

결국 양상논리와 가능새계 의미론은 짜증나게도 인정할수밖에 없는 언어임이 당연하다.

왜냐하면 술어논리조차도 그것에 대한 암시를 하였기 때문이다.

조건이란 도구로!

## 다치논리나 다치값의 해석은!

어떤 임의의 객체집합 S에 대해 선택함수 f가 존재해서, 첨수집합을 정의역으로 하는 시퀀스 ; P_1 = S이고, P_n = ∅이며, P_k = P_{k - 1} - f(P_{k - 1})에서, 어떤 언어 L에 대한 문장 T가 언어 L의 모델 M에 대해 μ로 평가되어, μ : L* -> S라면, M이를 구성할 모델 L이 존재하여 S의 원소러 평가되는 다치언어 T와 그 평가값 S는 존재론적 언질로써 수학에서도 존재한다.

## 술어논리의 회피하는 방어기제에 대해.

다음 공리를 술어논리에 도입함하면 정체불명의 술어가 생긴다.
AXIOM)
∃Necesurry
DEFINE)
Necesurry(Φ) : □Φ s.t. (⊨ Necessitation)
Posible(Φ) : ¬Necesurry(¬Φ)
Necessitation(Φ) : Τheorem(Φ), (Φ ⊢ necesurry(Φ))

### 비유

생각해보자, Necesurry(Φ) : "Φ is necesurry" 말고도, Φ(year, mounth, day, who, food) : "year년 mounth월 day일 who의 마음속에 확고한 마음으로 잘 정의된 그날 먹고싶은 음식 목록에 food가 있음"인 Φ는 어쩔것인가 (고지식한 이의 음식목록의 비유)

그러면 Φ_1(sentence) : "문자열 sentence는 형식 언어의 문자열이다"과 Φ_2(sentense) : "Φ_1(sentence)일때, sentense는 해당 언어에서 정리이며, 필연적인 명제다"에 대해 Φ_1(sentense) ⊨ Φ_2(sentense)를 만족하는 sentense에 대해서, 말할수 있음을 안다.

sentence에 대해서 L에 원소중에 '□'도 있으면 매우 모호해져서, 고지식한 이의 맛있는 음식 리스트다의 경우와 같다.

결국에 이 술어는 명확한 자연어 술어로써 참 혹은 거짓의 성질을 띄고, 논리적으로 논의하기 애매한 서술들이다.

따라서 우리는 자연어라는 명세에 대한 기호화된 논리식를 구성해서 회피하곤 한다.

자연어를 쓸수 있게 해놓고 그게 너무 광범위한 음식리스트가 되니 회피하는거다.

진리값이 잘 정의됬다 정의에 선언하는것이 잘 동작하지 않는다. 그러나 동작한다.

## 너무 너무 Ridiculous한것은!

귀납적 설명에는 actual인 관찰 Φ_k (k = 1 ~ n)에 대해, H_1 : Φ_k (k = n + 1 ~)이 존재함이 당연하므로, 일반화된 통찰 Φ에 대해 H_1 ⊨ (Φ_k, H_1 ⊨ Φ)임이 귀류법의 전제조건이지. 그러면, 이론 T와 그 모델 M과 모델에 대한 근거 가설 H_2에 대해, H_1, H_2 ⊨ Φ, H_2 ⊨ T로, 이러한 Φ에 대한, H_2, H_1, T의 관계는 추측관계 C(Φ, H, T) : H_1, H_2 ⊨ Φ, H_2 ⊨ T이며, 따라서 어떤 과학적 모델 M에 대해, M은 필연적으로 그 개연성이 추측관계 C(Φ, H, T)의 참인 개연성이므로 (개연성은 가설 이론이 얼마나 actual들을 잘 설명할 수 있는가이므로 타당) M은 Φ에 시간에 따라 의존적이고, M ⊨ T이며, H, Φ ⊨ M이므로, M고, 엮인 속성이 어쨌든 Φ, H, T이다. 추측은 개연성을 가진다. 자, 그렇다면 아까 했던 논의를 다치논리로 확장하여, 직관적 맞을 진리값(e. g. 200%)을 객체적 진리값으로 바꿔서 논의하듯 논의하면(즉, 절대적 참 거짓을 개워놓고 보면), 통계에서 왜 틀려도 맞냐하는지 설명은 극히 일부의 다치논리이고, 개연성이라는 진리치 이외에도 여러 진리치가 존재하여, 경향성이나 일반성 또한 모호히 잘 정의되기에, 쉽게 도달 가능한 ridiculous한 진리치들이 존재함은 타당하고, 이들을 논리로 해석할지는 자유가 된다.
\`\`\`
`;

const mdText3 = `
# 보수와 도덕

1. 개인적 도덕
\`\`\`\`
개인적 도덕관 :

혐오는 가장 도시적이고 또, 가장 원시적인 야만이다
인간 역사에 있어 한번도 사라지지 않았고, 지금도 얼굴을 붉히며 발끈하며 나타나고, 인류의 근원적인 성악(성악설의 성악)이다. 즉, 혐오는 영속적인 악이고, 현존하는 악이며, 인간의 성악적 속성이다. writen by me
생각은 언어이다 writen by Avram Noam Chomsky
대화도 소통이다 (그리고 그건 언어가 변하지 않는다면 항진인 단어의 속성이기도 하다.) writen by me
언어가 다르면 재대로 대화하지 못한다. 그것은 언어가 다르다는 말의 속성이기도 하다. 이 속성을 강조해서 언어장벽에서 유래한 "언어협곡"이라는 조어를 만들겠다. writen by me
생각의 차이를 인정하는것은 언어협곡을 인정하는것이다. (이것에 대한 증명은 단순 대입으로는 안되니 유보하겠으니 공준으로 삼아도 좋다.) 언어협곡을 인정할것과 타인을 도덕적 인류애 공간이라는 가치 안에서 이루어질것은 "그 이상적 관용"(the ideal 관용)이라고 정의된다. written by me
예수님이 말한 사랑은 이웃을 사랑하는 사랑중이 너진똑이 말한 예수님의 관용과 사랑에 대해서 그 사랑을 "관용적 사랑"이라는 조어로 정의하겠다. written by me
관용적 사랑을 통해 딱한자나 미련한 자를 연민하고 그러한 성선에서 빠저나간 악한 상태 혹은 그런 미련하고 추한 상태에 대해 용서하는것은 성선에 극복에 측면에서 중요하다. 도덕은 아름다운것이며 미적인것의 반대는 추함이고 이기심은 추함인데, 미련한 자는 관용적이지 않고 또 근본적으로 추힘의 속성을 가지기에 인간이 취급되야하는 성선이 아니다. writen by me
언어는 논리를 가진다 writen by me
언어는 규정짓는다 (기호화) writen by me
초월선이란, 악에 대해서도 관용하고 사랑하는것이다. 언어는 논리를 가지며, 언어는 사회적 영향보다 견고한데 영향을 받는 측면이 있고, 언어는 규정짓는다 (기호화). 이러한 언어에 항진 측면에 따라, 악이라는것은 선이라는것이 있기 위해 대척점으로 존재하는것이기에, 악마화라고 말할순 없겠지만 딱한 악이라는 존재까지도 관용하고 사랑해야한다. writen by me
초월선에 관점에서 혐오에 대해 야만이고 악이라 판단되는것에 대하여, 그럼에도 혐오의 성악이라는 인간성을 사랑해야한다. writen by me
도덕은 실현 가능성에 구애받지 않는 절대적 권위를 가진다 written by me
초월선이란것에 대해 나는 개인적으로 실천될 가능성이 0은 아니지만 0에 근접한다고 본다. 농담격이지만 초실수체를 도입해야할것같다. 그러나, 도덕은 실현 가능성에 구애받지 않고, 초월선을 이해하고 기억하는것이 가장 중요하다. (잠정적 추구보다도 역한 사실인식성 (미의 기준)) written by me
도덕적 공동체가 존재하기 어렵지만 지키려고 하는게 났지 않겠는가 written by me
언어협곡의 인정을 "인정하기"라고 한다. "인정하기"는 만인의 폭력상태로 비유되는 도덕관에 혐오관계이자 대립관계를 없에는것이다. written by me
띠라서 나의 소극적 선악론에서 악은 혐오이며, 나의 추구할 대상으로써의 선악론에서 선은 초월선이다. written by me
도덕은 만인의 추구미로써 절대적 밈적 리비아탄이고 인간 존재시 필연적으로 발생하는 꼬리표같은 존재다. (따라서 개인 도덕관보다 다수 도덕관이 도덕관이 되는 역설이 발생한다. 가장 끔찍한 도덕의 대립이다. 가장 끔찍하고 참혹하고 참담한 대립이다.) written by me
코멘트 : 나는 성악이나 성설을 지지하지 않는다. 직감적으로 성무선악설이긴 하지만 말이다. 논하는게 의미 있는지 모르겠고 논하지 말자 written by me
극단주의야말로 가장 추하다. written by me
나도 극단주의적이다. 수학을 좋아하는 이과다보니까, 극단적인 언행을 한 바가 있다.
\`\`\`
이산논리는 우리가 참과 거짓이 베타적이라고 전제한 무논리한 개념에서 온다. 그러나 장자 왈 "어려서 요절한 아이보다 더 오래 살 수 없다고 여길 수도 있고, 팽조를 일찍 죽었다고 여길 수도 있다."는데 이게 뭐냐고 보는데서 벌써 반박된다. 언어는 논리를 가지고, 단순히 참뜻(속뜻)과 겉뜻이 항상 일치하는 (a.k.a. 킨토어가 말한 그 본질이 (해석의) 자유에 있는) 언어는 모순되거나 극단주의일 가능성이 높다. 그럼 진리는 연속인가? 연속? ㅋㅋ 연속으로 다 되면 애초에 행렬이나 함수는 왜 필요하지? 그 본질이 수인가? 결국 수의 보존개념이 함수로 환원되는 람다에서, 의미론적 등호를 더한 언어는? 진리는 수가 아니지 ㅋㅋ 극단적으로 말해서 이해하지 쉬운 설명을 하바면 그거는 수학에 대한 맹목적 추종이며 근자감이다. 그런것 대한 논의할때 극단주의적 비판을 조심해야할 정도로. 시대에 흐름에 편승하려는 학벌이라는 금을 사랑하는 물신주의에 가깝다. 수학자들이 싫어할 사람상이다. 이산논리를 진리라고 믿는놈은는 그냥 과학 만능주의자랑 개찐도찐인거다... 그런 의미에서 철학을 무시하는 과학자나 수학자는 지혜가 없는 사람이거나 삐뚤어져서 싫어하거나, 아니면 에초에 극단주의거나 바뀔생각 없는 고지식한 분이거나.
\`\`\`
이 말은 도덕이라는 기준에서 무지막지하게 극단적인 표현들이다. 틀린 말은 아니라고 보지만, 틀릴정도로 극단적인 표현이 많을거다. written by me
\`\`\`\`

2. 보수적 정상상태
\`\`\`\`
이건 제 개인적인 생각이에여ㅕ

# 우-갈망 좌파론

## 서론

나는 우파들이 우파적인 방법으로 우파적 목표를 이룰수 없을때 다소 좌파적인 수단을 동원하는것은 다소 극단적이라 본다.
그러나, 극단적이더라도, 우파의 최종 목표는 우파적 목표다.
따라서, 우파적 목표를 이루는것이 우파적 행동이 가야하는 바이다.

## 본론

1. 우파적 목표란 무엇인가? 우파적 목표는 보수적 정상상태이다.
우리는 보수적으로 정상화된 사회를 원한다. 그것이 우리의 이상향이기 때문이다.
그런데 보수적 정상상태는 새상이 부조리하기에 언젠가는 깨질수밖에 없다.
만약 필연으로 비정상화되는 보수 대재앙이 올때, 보수로써, 그런 상황을 막아야 할 것이다.
대(대적)-대재앙 상태이다.

그러나, 에초에 대-대재앙을 막기위해, 항시 평안함을 목표로 두고, 현실적으로 방어장치로써, 대재앙과 평안 깨짐을 막으려 들게 되어있다면, 나는 그것이 이상적인 사회라 본다.
이상에서, **평시 정상화**해야 한다.
**평시 정상화**가 답이다.

2. 평시 정상화되기 위해선 보수와 개혁보수가 공존해야한다. 정상화를 온건이 하거나, 개혁으로 정상화만 하면 안된다, 공존하지 않는것은 평안 깨짐을 만든다. 그러나 온건하고 평시 정상화를 이룰수 있는 방식으로 개혁하는것이 개혁이 평시 정상화를 깰 리스크가 있어도 할 이유가 되게 하는데 무엇이 문제일까?
개혁의 반복이나 극우적 행동이 목적일때, 보수적 색체인 평안에서 벗어나게 만든다. 얼마나 좌익적인가?, 그렇다, 너무 과한것은 그것이다, 개혁의 반복이나 극우적 행동이 목적이 될때, 그것은 보수가 아닌 좌익적 행동이나 다름없는 대제앙을 수반하는 행위인것이다, 우리는 대재앙을 막아야만 하는데 말이다!!!

3. 교활한 극좌들은 항상 예의주시해야한다. 그들은 좌익적 근거인 이상적 정상상태를 추구한다. 이상적 정상상태를 추구하는 그 사살과 행동, 실용적 실천을 위한, 우경적 수단과, 그러한 Agressival Movement까지, 그들의 행동을 예의주시하며, 그들이 하려는 대재앙을 막으려 항시 예방/대응해야 한다. 대응하는 방법은 파악한후에 백신을 만들듯, 더러운 재앙을 구축하는것이다. 책을 읽는 단계가 먼저다. 그들의 생각을 양이되어 처음엔 믿고, 두번째로 사자가 되어, 반항하라, 새번째로 어린이가 되어 타협점을 찾으라, 독서 다음도 당연히 알수 있다. 네번째는 독서된것을 보수적인 목적에 맞는지 검토한다, 그리고 다섯번째, 그들을 반박하고, 예측하고, 막고, 평안을 수호해야한다. 그것이 교활한 좌익들을 누구나 예측할수 있도록 해주는 기본적인 아이디어다.
이러한 방법으로도 안통하면 다른 방법을 찾아봐야 하지만, 그정도로 교활한진 아직 모르겠으니 넘기겠다. (예시로 빨갱이놈들 책이라고 공부하고 대처하여 더러운 사상을 새상에서 구축해 없애는것이다. 보수의 지성 엘리트적 특성, 인간의 지성의 역할이다.)
수단과 방법을 가리지 않고, 평안이 최고다.

"따라서".
이상적인 새계가 보수적 정상상태인 좌익을 생각하면,
이것이 우-갈망(Right-Desire) 좌파다.

우-갈망 좌파적인 색체는 보수적인 잣대를 지키기 위해, 보수적 정상상태와 그의 과격한 일종인, 개혁을 마다치 않는 평시 정상화를 이상적인 새계로 잡고, 마다치 않는 평시 정상화를 이상적인 새계로 잡고, 옳은 "우"를 갈망하여 행동하는것이 목표인 좌파다.

대안(Alternative)우파로는 부족하다!!!

우-갈망을 부르짖어야 한다!!!!!

## 마치며

그러나, 정치질의 평안깨짐, 그것의 만연에 회의가 든다.

그래서 나는 정치라는것이 개인적으로 내가 시도할만한지 의심된다...ㅠ

이명박 대통령께서 기자들도, 정치도 싫어하신거를 윤카 탄핵 당시 봤다.

당시에 난 중립이었지만, 민주당의 폭거를 헌제가 무력히 비판한걸 보고, 나는 이 나라에 보수가 절멸할것을 걱정했다.

그래서 나는 중립에서 우익으로 변했다.

나는 초등학교 3학년때 박근혜를 좋아했다.

그러나 부모님이 탄핵 집회에 나가고 나는 자연스럽게 좌파로 갔었다.

내 색체를 잃고 실존하지 못했다.

다시금 정신차린 2024년 12월 이후.

중립이 될때도 그렇고 싫어졌던 좌파.

난 새상의 좌파가 밉다.

# 우갈망 2편 모순적 진보에 대한 비판  (Tip : 우갈망 2편의 핵심내용은 우갈망 1편에서 말하는 우갈망은 절대로 필연적으로 극단주의이면 안된다는것이다.)

먼저 우갈망 1편을 성찰해보자. 나는 지금도 극우지만, 그때는 증오표현까지 쓰는 비건설적인 끔찍한 극우였다.
그때에 내 태도는 관철되지 말아야 할, 고쳐야 할 태도임을 입증해보겠다.

## 1. 도덕의 변화성

도덕이 절대적인 성서무오설같은거라 가정하자.
총을 쏘는것은 숭고한가? (도덕적인가?) : 아니오
안중근 의사의 의거는 숭고한가? (도덕적인가?) : 예
따라서, 도덕은 절대적인 흑백논리로 판단 불가능하다.
도덕이 왜 바뀔까?
내가 주장한 보수 이론에 따르면
보수의 최고선은 "보수적 정상상태"의 유지이다.
혁명의 최고선은 "이념적 정상상태의"의 달성이다.
이때 해겔, 마르크스의 생각을 보자.
기존 보수가 테제가 되고, 혁명이 안티테제가 되는것은 변증법적 유물론에 따라 필연적이다.
따라서, 변증법에 따라서, 보수와 혁명은 연속적으로 변한다.
따라서, 도덕이라는 기준도 항상 끊임없이 필연적으로 바뀐다.
그러나, marxism같은 좌빨 입장에서는, 그 사상이 최고선인건 변하지 않는 걍우가 있다. 따라서, 이런 경우는 주모순으로 모순론으로 해결해야한다.

## 2. 현제의 문제

더불나 민주당과 미국 민주당의 가장 큰 문제는 진보 포시션이 주모순으로 정착했기 때문이다.
진보가 진보로써 작용하지 못한다면, 진보-보수의 서로에 대한 투쟁에서 문제가 생길 가능성이 높다.
그렇다면, 모순론이 아닌 변증법에 대해, 변증법적 프레이밍이 된 현제, 극단적인 정치만 남을것이다 (인용 : DJ무현이 한 명언. [출처](https://m.nocutnews.co.kr/news/197585) (원래 인스타에서 봄))
그러하다면, 건설적이지 않고, 불안정한 방향이 될것이며,

**우리 보수는 그러항 불안정하고 비일반적이고 비보수적인 문제적 좌빨을 교정할 의무가 있다**

**극우가 아닌 공정란 상호투쟁이야말로 보수적 본질이다.**

## 3. 대안 우파의 문제

대안 우파는, 이러한 문제의식에서 페미니즘만큼이나 정당하고 합당하며, 숭고한 도덕이다.
그러나, 극단주의는 보수의 적이다.

대안 우파같은 극우는 경계해야 마땅하다.

# 우갈망 3 : 우파적 시각의 온건성과 우파적 내용의 보편성

우파적 시각의 온건성과 우파적 내용의 보편성이야말로 우파가 균형잡힌 시각으로 있게해주므로, 다음과 같은 해석을 통하여, 좌익과 우익의 균형잡힌 존중을 해보자.

\`\`\`
주의 : 이 내용은 직관에 따른 영감이다. 비판 환영.

# 모순새계 도덕론의 존재성 증명과 도덕의 재해석

주의 : 이건 도덕에 대한 도덕이 보는 새계에 대한 시각의 재해석이지 핵심이 아니다.

## 모순새계론

주의 : 모순새계론은 새계를 설명하는데 논리로 인해서 필연적인 언어의 속성인거지, 본질이 아니다.
주의 : 극단적인 논리 흐름이 이를 강조한다.
주의 : 새계론은 절대 본질이 아니고 정리다. 증명된 명제일 뿐.

### 새계론

주의 : 새계론은 새계는 설명하는데 논리로 인해서 필연적인 언어의 속성인거지 본질이 아니고, 모순론은 새계론에서 만들어진 그냥 모델이라는 객체일 뿜이다.

#### 기본 5 정의와 예외공리

기본 5 정의는 어떤 현실새계 a에 대한 실존공간 e라는 e를 결정하는 모델이다. 이러한 모델을 선택한건 선택공리에 의존한다.

실존공간은 현실새계에서 반박되지 아니하고,
현실새계는 실존공간과 달리 예외이다.

예외공리 (아직 논리식으로 번역 안함. 체계 완성되야 번역할거임) : 이때, 모든 현실새계 a는 어떤 새계 w의 예외로 존재하며, 인간 인지와 언어의 한계로 인해서, 모든 논리적 해석에서는 본질새계 w와 현실새계 a로 본질-예외 대립관계로써, 현실에선 예외가 가득하다.

##### 기본 5 정의 中 4 할당
- e는 실존공간이다.
- a는 현실새계이다.
- 실존(h) : V(e, ∃h) = 1
- 현존(h) : V(a, ∃h) = 1
##### 기본 5 정의 中 1 성질
- ∃e s.t. 실존(h) → 현존(h)
이 성질은 논리방정식 \`실존(h) → 현존(h)\`의 해로써 실존공간의 존재다.

#### 비 단순 새계함(새계 관(어떤걸 넣는 관))

의외성 정리에서 단순 언어가 아닌 언어가 있다.
자, 언어는 논리를 가진다. 어느 논리가 틀렸다 말할수 없다.

그런 의미에서 언뜻 보면 체계를 무너트리는 의미의 모순인 수학적 모순이 보이지만, 사실 그런거 없고 그건 딜레마다. 딜레마는 허용될수 있으며, 딜레마의 허용 • 불허는 언어에 따라 자유롭다.

비 단순 새계함의 새계에서는 모순이 일어날 수 있다.
폭발 원리에 따라 모순은 모순을 낳으므로, 이 새상 모든것은 모순으로 이루어져 있다.

그런 의미에서 아까 가정한 객체 h에 대해
h.side_n 이라는 측면_n 이 존재하고, 그 중에서는
h.side_n과 h.side_m 이 모순되는 모순이 존재한다.

모순(h.side_n, h.side_m)는 모순관계다.

따라서 새상은 모순관계의 대립으로 이루어지며,
보편과 특수 논리에서 보편의 범주에 속하는 것이 주요이고 일반이며 본질이다.

### 재해석 모순론 모델

재해석 모순론 모델은 마오의 모순론에 대해서 자연어-논리 및 양상논리 모델을 새운것이다.

1. (실존(h) s.t. Φ(h))(□∃n, m s.t. 모순(h.side_n, h.side_m))이다.
2.『보편(일반)-특수 논리』= 『주요 - 비주요 논리』이다.
3. 주모순과 부모순, 주측면과 부측면은 유동적이며, 현제 상태에서 주로 이루어지는 질서인경우가 많다. (단. 항상 단어 정의는, 주모순은 주요 모순이고 부모순은 비주요 모순이며, 주측면은 주요 측면이고 부측면은 비주요 측면이다)

따라서 명세격인 모순론의 명세를 명확히 하자.

모순 : 서로 대립하는 두 힘이 서로의 존재를 규정하며(모순은 규정한다) 끊임없이 투쟁하고 변화하는(본질적으로 평가됬기에) 역동적인(역동적인 투쟁이다!! 기억하자.) 관계
주모순: 어떤 객체나 현상의 발전 과정에 존재하는(실존하니 반박할수 없고 고를수 있다.) 수많은 모순 중에서(지금 여기까지 말했을때 "모순 s.t."의 의미이다.) 가장 근본적(주요 측면이다)이고 "결정적인 영향력"(당연히 그게 근본적인거다)을 가진 모순. 해결되지 않으면 다른 모든 모순들도 해결할 수 없으며, 이 모순이 바로 그 객체나 현상의 본질을 규정한다. (모순은 규정한다, 왜냐하면, 의외성 정리에서 말하는 단순 언어의 측면에서 그 모델 위의 의미론적 동등이 본질적 동등이므로, (즉, 수학 (형식 언어의 상징)의 본질이 그 (서술의) 자유에 있으므로) 모순은 예외라는 단순(사회과학적 뉘앙스의 철학적 보편(일반))의 예외(특수한 새분이론격)이므로, 일반을 어쨌든 구성하게 됨이 본질과 동떨어진 본질의 동등한 부가속성이다 (예컨데 학생이 연산을 하다가, 면적을 결정하며 2를 곱함이 a + a를 의미하는게 곱셈이라고 잘못 본질을 파악해도 그 부가적 속성이 동등하다.). 따라서 절대, 절대, 절대적인 비본질은, 특수가 본질은 구성하는것이 절대 본질이 아니고 정리이다.)
부모순 : 주모순에 종속되거나 파생된 부차적인 모순(의존성을 가지는 모순, 귀류법으로 생각해보자면, 의존성을 가지지 않는 부차적 모순을 상정하면 주요 모순이 해결되지 않으면 현상유지이므로 모순이므로, 힘때문이 모순의 의존성은 결정된다. 권력(힘)은 총부리에서 나온다.). 이 모순들은 자체적으로 사태의 본질을 바꾸지는 못하며(종속성), 주모순이 해결되어야만 함께 해결되거나 그 성격이 바뀔 수 있다.(종속성의 결과)
주요 측면: 한 모순 관계에서 현재 사태를 주도하고 지배적인 위치에 있는 측면(즉, 현제 상태에서 보편이므로 주요)입니다. 이 측면의 성격이 바로 객체의 본질을 결정합니다 (주도적이고 지배적인 언어적 핵심이며, 그 언어의 본질이 비정명(정명은 유교 개념)이기에, 핵심 개념은 여기에서 온다.)
비주요 측면: 모순 관계에서 지배적 위치에 있지 않고, 상대적으로 약하며 종속적인 위치에 있는 측면입니다. (이것에 대한 설명은 생략하겠다.)

## 도덕론

도덕은 이 중에서 도덕이 옳다고 정의한것이다.
이 이외의 것들은 기존 도덕에서 정의되어있다.

어쟀든 도덕은 권위와 보편의 속성을 가지게 된다.
필연적으로 절대적 논리•정의 측면에서 부가적 속성이 권위와 보편이다

따라서 당신이 보수라면 이 도덕을 지켜야한다.

참고로 이 분석은 모순새계론에서 도덕의 모델(구성)이며, 도덕은 모든것에 앞서는 권위를 가지기에 모순새계론에 앞선다.

### 좌우 프레임론

이제부터 우파론과 좌파론을 설명할것인데, 이는 도덕이 가지고있는 모순적인 정의 수호와 정의 창출이라는 측면에 의해서 필연적인 존재이며, 이것이 도덕의 핵심 속성이 아니라, 실재로 극단적인 대립균형이 될때만 부각되는 이원화이자, 실제 정치적 도덕관이 다양함의 방증이다.
인간은 극단적인 성격을 추구하는 문제점을 가질때가 많음으로 (매우매우매우매우 가능(◇)하므로) 대립균형 (e.g. 냉전) 상태의 추구라는 문제점때문에 우파와 좌파는 존재할수밖에 없는 처지다.

#### 우파론

「기존적 보편가치」란 보수적 가치 중에서도 우익을 보수적 가치에 부합한다고 보는 보수=우익이 성립하는 보편가치다. 사실은 "기존적"이 붇은 이유는 좌파랑 비교하는 보편적 가치라는 의미에서고, 기존적 보편가치 기준에서 모든 보편가치는 기존적 보편가치다.

기존적 보편가치에서는 진보적 보편가치의 존재를 당위양상논리에서 마땅히 존재해야할 존재로써, \`□∃진보보편\`임도 기존적 보편가치의 요구사항이다.

이미 우갈망 좌파론에서 다 설명했다.

도덕의 보수적 속성은 보수 도덕이며 보수 도덕이 보수의 존재 이유이다.

그러한 의미에서 (극단적으로 해석하지 말자) 보수는 도덕이다. (그 역이 도덕이 아니라 한 적이 없다. 그 역은 보수적 정상상태에 기여하는 좌파다.)


#### 죄파론

좌파의 존재 이유는 도덕의 관점과 진보의 관점으로 나뉜다.
도덕의 관점에서 기존적 보편가치가 진보적 보편가치를 부르고 이게 아방가르드이다.
진보에 관점에서 악은 모순으로 규정된다. 따라서 모순을 해결하는것이 진보이다. 극좌가 아닌 이상 모순에 해결에 눈멀어 모순을 만드는군 기피해야한다. 즉 진보하는 태도는 반진보에 반하는것이며 (대우 명제다) 반진보는 모순임이 타당하게 증명되었으므로, 모순을 해결하는 관점에서 설명된다.
\`\`\`
\`\`\`\`

이러한 관점에서 도덕은 보편적으로 언어적으로 규정된 보편적 숭고함으로, 보수적인 문제성을 띄며 동시에 포용적이다.
`;
  
  document.getElementById("content1").innerHTML = marked.parse(mdText1);
  document.getElementById("content2").innerHTML = marked.parse(mdText2);
  document.getElementById("content3").innerHTML = marked.parse(mdText3);
  document.getElementById("content3").innerHTML = marked.parse(mdText4);
    </script>
  </body>
</html>
